#![feature(prelude_import)]
//! # Elefren: API Wrapper around the Mastodon API.
//!
//! Most of the api is documented on [Mastodon's website](https://docs.joinmastodon.org/client/intro/)
//!
//! ```no_run
//! # extern crate elefren;
//! # fn main() {
//! #    run().unwrap();
//! # }
//! # fn run() -> elefren::Result<()> {
//! use elefren::{helpers::cli, prelude::*};
//!
//! let registration = Registration::new("https://mastodon.social")
//!     .client_name("elefren_test")
//!     .build()?;
//! let mastodon = cli::authenticate(registration)?;
//!
//! println!(
//!     "{:?}",
//!     mastodon
//!         .get_home_timeline()?
//!         .items_iter()
//!         .take(100)
//!         .collect::<Vec<_>>()
//! );
//! # Ok(())
//! # }
//! ```
//!
//! Elefren also supports Mastodon's Streaming API:
//!
//! # Example
//!
//! ```no_run
//! # extern crate elefren;
//! # use elefren::prelude::*;
//! # use std::error::Error;
//! use elefren::entities::event::Event;
//! # fn main() -> Result<(), Box<Error>> {
//! # let data = Data {
//! #   base: "".into(),
//! #   client_id: "".into(),
//! #   client_secret: "".into(),
//! #   redirect: "".into(),
//! #   token: "".into(),
//! # };
//! let client = Mastodon::from(data);
//! for event in client.streaming_user()? {
//!     match event {
//!         Event::Update(ref status) => { /* .. */ },
//!         Event::Notification(ref notification) => { /* .. */ },
//!         Event::Delete(ref id) => { /* .. */ },
//!         Event::FiltersChanged => { /* .. */ },
//!     }
//! }
//! # Ok(())
//! # }
//! ```

#![deny(missing_docs, warnings, missing_debug_implementations,
        missing_copy_implementations, trivial_casts, trivial_numeric_casts,
        unsafe_code, unstable_features, unused_import_braces,
        unused_qualifications)]
#![allow(intra_doc_link_resolution_failure)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;

#[macro_use]
extern crate log;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate doc_comment;
extern crate hyper_old_types;
extern crate isolang;
#[macro_use]
extern crate serde_json;
extern crate chrono;
extern crate reqwest;
extern crate serde;
extern crate serde_qs;
extern crate serde_urlencoded;
extern crate tap_reader;
extern crate try_from;
extern crate url;
extern crate tungstenite;





use std::{borrow::Cow,
          /*
          io::BufRead,
          */
          ops};

use async_trait::async_trait;
use reqwest::{Client, RequestBuilder, Response};
use tap_reader::Tap;
/*
use tungstenite::client::AutoStream;
*/

use crate::entities::prelude::*;
use crate::page::Page;

pub use crate::data::Data;
pub use crate::errors::{ApiError, Error, Result};
pub use isolang::Language;
pub use crate::mastodon_client::{MastodonClient, MastodonUnauthenticated};
pub use crate::registration::Registration;
pub use crate::requests::{AddFilterRequest, AddPushRequest, StatusesRequest,
                          UpdateCredsRequest, UpdatePushRequest};
pub use crate::status_builder::{NewStatus, StatusBuilder};

/// Registering your App
pub mod apps {






    /*
    type Stream = EventReader<WebSocket>;
    */




































    /*
    /// returns events that are relevant to the authorized user, i.e. home
    /// timeline & notifications
    ///
    /// # Example
    ///
    /// ```no_run
    /// # extern crate elefren;
    /// # use elefren::prelude::*;
    /// # use std::error::Error;
    /// use elefren::entities::event::Event;
    /// # fn main() -> Result<(), Box<Error>> {
    /// # let data = Data {
    /// #   base: "".into(),
    /// #   client_id: "".into(),
    /// #   client_secret: "".into(),
    /// #   redirect: "".into(),
    /// #   token: "".into(),
    /// # };
    /// let client = Mastodon::from(data);
    /// for event in client.streaming_user()? {
    ///     match event {
    ///         Event::Update(ref status) => { /* .. */ },
    ///         Event::Notification(ref notification) => { /* .. */ },
    ///         Event::Delete(ref id) => { /* .. */ },
    ///         Event::FiltersChanged => { /* .. */ },
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    fn streaming_user(&self) -> Result<Self::Stream> {
        let mut url: url::Url = self.route("/api/v1/streaming").parse()?;
        url.query_pairs_mut()
            .append_pair("access_token", &self.token)
            .append_pair("stream", "user");
        let mut url: url::Url = reqwest::get(url.as_str())?.url().as_str().parse()?;
        let new_scheme = match url.scheme() {
            "http" => "ws",
            "https" => "wss",
            x => return Err(Error::Other(format!("Bad URL scheme: {}", x))),
        };
        url.set_scheme(new_scheme).map_err(|_| Error::Other("Bad URL scheme!".to_string()))?;

        let client = tungstenite::connect(url.as_str())?.0;

        Ok(EventReader(WebSocket(client)))
    }

    /// returns all public statuses
    fn streaming_public(&self) -> Result<Self::Stream> {
        let mut url: url::Url = self.route("/api/v1/streaming").parse()?;
        url.query_pairs_mut()
            .append_pair("access_token", &self.token)
            .append_pair("stream", "public");
        let mut url: url::Url = reqwest::get(url.as_str())?.url().as_str().parse()?;
        let new_scheme = match url.scheme() {
            "http" => "ws",
            "https" => "wss",
            x => return Err(Error::Other(format!("Bad URL scheme: {}", x))),
        };
        url.set_scheme(new_scheme).map_err(|_| Error::Other("Bad URL scheme!".to_string()))?;

        let client = tungstenite::connect(url.as_str())?.0;

        Ok(EventReader(WebSocket(client)))
    }

    /// Returns all local statuses
    fn streaming_local(&self) -> Result<Self::Stream> {
        let mut url: url::Url = self.route("/api/v1/streaming").parse()?;
        url.query_pairs_mut()
            .append_pair("access_token", &self.token)
            .append_pair("stream", "public:local");
        let mut url: url::Url = reqwest::get(url.as_str())?.url().as_str().parse()?;
        let new_scheme = match url.scheme() {
            "http" => "ws",
            "https" => "wss",
            x => return Err(Error::Other(format!("Bad URL scheme: {}", x))),
        };
        url.set_scheme(new_scheme).map_err(|_| Error::Other("Bad URL scheme!".to_string()))?;

        let client = tungstenite::connect(url.as_str())?.0;

        Ok(EventReader(WebSocket(client)))
    }

    /// Returns all public statuses for a particular hashtag
    fn streaming_public_hashtag(&self, hashtag: &str) -> Result<Self::Stream> {
        let mut url: url::Url = self.route("/api/v1/streaming").parse()?;
        url.query_pairs_mut()
            .append_pair("access_token", &self.token)
            .append_pair("stream", "hashtag")
            .append_pair("tag", hashtag);
        let mut url: url::Url = reqwest::get(url.as_str())?.url().as_str().parse()?;
        let new_scheme = match url.scheme() {
            "http" => "ws",
            "https" => "wss",
            x => return Err(Error::Other(format!("Bad URL scheme: {}", x))),
        };
        url.set_scheme(new_scheme).map_err(|_| Error::Other("Bad URL scheme!".to_string()))?;

        let client = tungstenite::connect(url.as_str())?.0;

        Ok(EventReader(WebSocket(client)))
    }

    /// Returns all local statuses for a particular hashtag
    fn streaming_local_hashtag(&self, hashtag: &str) -> Result<Self::Stream> {
        let mut url: url::Url = self.route("/api/v1/streaming").parse()?;
        url.query_pairs_mut()
            .append_pair("access_token", &self.token)
            .append_pair("stream", "hashtag:local")
            .append_pair("tag", hashtag);
        let mut url: url::Url = reqwest::get(url.as_str())?.url().as_str().parse()?;
        let new_scheme = match url.scheme() {
            "http" => "ws",
            "https" => "wss",
            x => return Err(Error::Other(format!("Bad URL scheme: {}", x))),
        };
        url.set_scheme(new_scheme).map_err(|_| Error::Other("Bad URL scheme!".to_string()))?;

        let client = tungstenite::connect(url.as_str())?.0;

        Ok(EventReader(WebSocket(client)))
    }

    /// Returns statuses for a list
    fn streaming_list(&self, list_id: &str) -> Result<Self::Stream> {
        let mut url: url::Url = self.route("/api/v1/streaming").parse()?;
        url.query_pairs_mut()
            .append_pair("access_token", &self.token)
            .append_pair("stream", "list")
            .append_pair("list", list_id);
        let mut url: url::Url = reqwest::get(url.as_str())?.url().as_str().parse()?;
        let new_scheme = match url.scheme() {
            "http" => "ws",
            "https" => "wss",
            x => return Err(Error::Other(format!("Bad URL scheme: {}", x))),
        };
        url.set_scheme(new_scheme).map_err(|_| Error::Other("Bad URL scheme!".to_string()))?;

        let client = tungstenite::connect(url.as_str())?.0;

        Ok(EventReader(WebSocket(client)))
    }

    /// Returns all direct messages
    fn streaming_direct(&self) -> Result<Self::Stream> {
        let mut url: url::Url = self.route("/api/v1/streaming").parse()?;
        url.query_pairs_mut()
            .append_pair("access_token", &self.token)
            .append_pair("stream", "direct");
        let mut url: url::Url = reqwest::get(url.as_str())?.url().as_str().parse()?;
        let new_scheme = match url.scheme() {
            "http" => "ws",
            "https" => "wss",
            x => return Err(Error::Other(format!("Bad URL scheme: {}", x))),
        };
        url.set_scheme(new_scheme).map_err(|_| Error::Other("Bad URL scheme!".to_string()))?;

        let client = tungstenite::connect(url.as_str())?.0;

        Ok(EventReader(WebSocket(client)))
    }
    */

    /*
    #[derive(Debug)]
    /// WebSocket newtype so that EventStream can be implemented without coherency issues
    pub struct WebSocket(tungstenite::protocol::WebSocket<AutoStream>);

    /// A type that streaming events can be read from
    pub trait EventStream {
        /// Read a message from this stream
        fn read_message(&mut self) -> Result<String>;
    }

    impl<R: BufRead> EventStream for R {
        fn read_message(&mut self) -> Result<String> {
            let mut buf = String::new();
            self.read_line(&mut buf)?;
            Ok(buf)
        }
    }

    impl EventStream for WebSocket {
        fn read_message(&mut self) -> Result<String> {
            Ok(self.0.read_message()?.into_text()?)
        }
    }

    #[derive(Debug)]
    /// Iterator that produces events from a mastodon streaming API event stream
    pub struct EventReader<R: EventStream>(R);
    impl<R: EventStream> Iterator for EventReader<R> {
        type Item = Event;

        fn next(&mut self) -> Option<Self::Item> {
            let mut lines = Vec::new();
            loop {
                if let Ok(line) = self.0.read_message() {
                    let line = line.trim().to_string();
                    if line.starts_with(":") || line.is_empty() {
                        continue;
                    }
                    lines.push(line);
                    if let Ok(event) = self.make_event(&lines) {
                        lines.clear();
                        return Some(event);
                    } else {
                        continue;
                    }
                }
            }
        }
    }

    impl<R: EventStream> EventReader<R> {
        fn make_event(&self, lines: &[String]) -> Result<Event> {
            let event;
            let data;
            if let Some(event_line) = lines
                .iter()
                .find(|line| line.starts_with("event:"))
            {
                event = event_line[6..].trim().to_string();
                data = lines.iter().find(|line| line.starts_with("data:")).map(|x| x[5..].trim().to_string());
            } else {
                #[derive(Deserialize)]
                struct Message {
                    pub event: String,
                    pub payload: Option<String>,
                }
                let message = serde_json::from_str::<Message>(&lines[0])?;
                event = message.event;
                data = message.payload;
            }
            let event: &str = &event;
            Ok(match event {
                "notification" => {
                    let data = data.ok_or_else(|| {
                        Error::Other("Missing `data` line for notification".to_string())
                    })?;
                    let notification = serde_json::from_str::<Notification>(&data)?;
                    Event::Notification(notification)
                },
                "update" => {
                    let data =
                        data.ok_or_else(|| Error::Other("Missing `data` line for update".to_string()))?;
                    let status = serde_json::from_str::<Status>(&data)?;
                    Event::Update(status)
                },
                "delete" => {
                    let data =
                        data.ok_or_else(|| Error::Other("Missing `data` line for delete".to_string()))?;
                    Event::Delete(data)
                },
                "filters_changed" => Event::FiltersChanged,
                _ => return Err(Error::Other(format!("Unknown event `{}`", event))),
            })
        }
    }
    */















    // Convert the HTTP response body from JSON. Pass up deserialization errors
    // transparently.

    // If deserializing into the desired type fails try again to
    // see if this is an error response.
    use std::borrow::Cow;
    use try_from::TryInto;
    use crate::errors::{Error, Result};
    use crate::scopes::Scopes;
    /// Represents an application that can be registered with a mastodon instance
    pub struct App {
        client_name: String,
        redirect_uris: String,
        scopes: Scopes,
        #[serde(skip_serializing_if = "Option::is_none")]
        website: Option<String>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for App {
        #[inline]
        fn clone(&self) -> App {
            match *self {
                App {
                client_name: ref __self_0_0,
                redirect_uris: ref __self_0_1,
                scopes: ref __self_0_2,
                website: ref __self_0_3 } =>
                App{client_name: ::core::clone::Clone::clone(&(*__self_0_0)),
                    redirect_uris:
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    scopes: ::core::clone::Clone::clone(&(*__self_0_2)),
                    website: ::core::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for App {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                App {
                client_name: ref __self_0_0,
                redirect_uris: ref __self_0_1,
                scopes: ref __self_0_2,
                website: ref __self_0_3 } => {
                    let mut debug_trait_builder = f.debug_struct("App");
                    let _ =
                        debug_trait_builder.field("client_name",
                                                  &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("redirect_uris",
                                                  &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("scopes", &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("website", &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for App {
        #[inline]
        fn default() -> App {
            App{client_name: ::core::default::Default::default(),
                redirect_uris: ::core::default::Default::default(),
                scopes: ::core::default::Default::default(),
                website: ::core::default::Default::default(),}
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_App: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl _serde::Serialize for App {
                fn serialize<__S>(&self, __serializer: __S)
                 -> _serde::export::Result<__S::Ok, __S::Error> where
                 __S: _serde::Serializer {
                    let mut __serde_state =
                        match _serde::Serializer::serialize_struct(__serializer,
                                                                   "App",
                                                                   false as
                                                                       usize +
                                                                       1 + 1 +
                                                                       1 +
                                                                       if Option::is_none(&self.website)
                                                                          {
                                                                           0
                                                                       } else {
                                                                           1
                                                                       }) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "client_name",
                                                                        &self.client_name)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "redirect_uris",
                                                                        &self.redirect_uris)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "scopes",
                                                                        &self.scopes)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    if !Option::is_none(&self.website) {
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "website",
                                                                            &self.website)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                       "website")
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    impl ::core::marker::StructuralPartialEq for App { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for App {
        #[inline]
        fn eq(&self, other: &App) -> bool {
            match *other {
                App {
                client_name: ref __self_1_0,
                redirect_uris: ref __self_1_1,
                scopes: ref __self_1_2,
                website: ref __self_1_3 } =>
                match *self {
                    App {
                    client_name: ref __self_0_0,
                    redirect_uris: ref __self_0_1,
                    scopes: ref __self_0_2,
                    website: ref __self_0_3 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &App) -> bool {
            match *other {
                App {
                client_name: ref __self_1_0,
                redirect_uris: ref __self_1_1,
                scopes: ref __self_1_2,
                website: ref __self_1_3 } =>
                match *self {
                    App {
                    client_name: ref __self_0_0,
                    redirect_uris: ref __self_0_1,
                    scopes: ref __self_0_2,
                    website: ref __self_0_3 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3),
                },
            }
        }
    }
    impl App {
        /// Get an AppBuilder object
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate elefren;
        /// use elefren::apps::App;
        ///
        /// let mut builder = App::builder();
        /// ```
        pub fn builder<'a>() -> AppBuilder<'a> { AppBuilder::new() }
        /// Retrieve the list of scopes that apply to this App
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate elefren;
        /// # use elefren::Error;
        /// use elefren::{apps::App, scopes::Scopes};
        ///
        /// # fn main() -> Result<(), Error> {
        /// let mut builder = App::builder();
        /// builder.client_name("elefren-test");
        /// let app = builder.build()?;
        /// let scopes = app.scopes();
        /// assert_eq!(scopes, &Scopes::read_all());
        /// #   Ok(())
        /// # }
        /// ```
        pub fn scopes(&self) -> &Scopes { &self.scopes }
    }
    /// Builder struct for defining your application.
    /// ```
    /// use elefren::apps::App;
    /// use std::error::Error;
    ///
    /// # fn main() -> Result<(), Box<Error>> {
    /// let mut builder = App::builder();
    /// builder.client_name("elefren_test");
    /// let app = builder.build()?;
    /// #   Ok(())
    /// # }
    /// ```
    pub struct AppBuilder<'a> {
        client_name: Option<Cow<'a, str>>,
        redirect_uris: Option<Cow<'a, str>>,
        scopes: Option<Scopes>,
        website: Option<Cow<'a, str>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <'a> ::core::clone::Clone for AppBuilder<'a> {
        #[inline]
        fn clone(&self) -> AppBuilder<'a> {
            match *self {
                AppBuilder {
                client_name: ref __self_0_0,
                redirect_uris: ref __self_0_1,
                scopes: ref __self_0_2,
                website: ref __self_0_3 } =>
                AppBuilder{client_name:
                               ::core::clone::Clone::clone(&(*__self_0_0)),
                           redirect_uris:
                               ::core::clone::Clone::clone(&(*__self_0_1)),
                           scopes:
                               ::core::clone::Clone::clone(&(*__self_0_2)),
                           website:
                               ::core::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <'a> ::core::fmt::Debug for AppBuilder<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                AppBuilder {
                client_name: ref __self_0_0,
                redirect_uris: ref __self_0_1,
                scopes: ref __self_0_2,
                website: ref __self_0_3 } => {
                    let mut debug_trait_builder =
                        f.debug_struct("AppBuilder");
                    let _ =
                        debug_trait_builder.field("client_name",
                                                  &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("redirect_uris",
                                                  &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("scopes", &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("website", &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <'a> ::core::default::Default for AppBuilder<'a> {
        #[inline]
        fn default() -> AppBuilder<'a> {
            AppBuilder{client_name: ::core::default::Default::default(),
                       redirect_uris: ::core::default::Default::default(),
                       scopes: ::core::default::Default::default(),
                       website: ::core::default::Default::default(),}
        }
    }
    impl <'a> ::core::marker::StructuralPartialEq for AppBuilder<'a> { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <'a> ::core::cmp::PartialEq for AppBuilder<'a> {
        #[inline]
        fn eq(&self, other: &AppBuilder<'a>) -> bool {
            match *other {
                AppBuilder {
                client_name: ref __self_1_0,
                redirect_uris: ref __self_1_1,
                scopes: ref __self_1_2,
                website: ref __self_1_3 } =>
                match *self {
                    AppBuilder {
                    client_name: ref __self_0_0,
                    redirect_uris: ref __self_0_1,
                    scopes: ref __self_0_2,
                    website: ref __self_0_3 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &AppBuilder<'a>) -> bool {
            match *other {
                AppBuilder {
                client_name: ref __self_1_0,
                redirect_uris: ref __self_1_1,
                scopes: ref __self_1_2,
                website: ref __self_1_3 } =>
                match *self {
                    AppBuilder {
                    client_name: ref __self_0_0,
                    redirect_uris: ref __self_0_1,
                    scopes: ref __self_0_2,
                    website: ref __self_0_3 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_AppBuilder: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl <'a> _serde::Serialize for AppBuilder<'a> {
                fn serialize<__S>(&self, __serializer: __S)
                 -> _serde::export::Result<__S::Ok, __S::Error> where
                 __S: _serde::Serializer {
                    let mut __serde_state =
                        match _serde::Serializer::serialize_struct(__serializer,
                                                                   "AppBuilder",
                                                                   false as
                                                                       usize +
                                                                       1 + 1 +
                                                                       1 + 1)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "client_name",
                                                                        &self.client_name)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "redirect_uris",
                                                                        &self.redirect_uris)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "scopes",
                                                                        &self.scopes)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "website",
                                                                        &self.website)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    impl <'a> AppBuilder<'a> {
        /// Creates a new AppBuilder object
        pub fn new() -> Self { Default::default() }
        /// Name of the application. Will be displayed when the user is deciding to
        /// grant permission.
        ///
        /// In order to turn this builder into an App, this needs to be provided
        pub fn client_name<I: Into<Cow<'a, str>>>(&mut self, name: I)
         -> &mut Self {
            self.client_name = Some(name.into());
            self
        }
        /// Where the user should be redirected after authorization
        ///
        /// If none is specified, the default is `urn:ietf:wg:oauth:2.0:oob`
        pub fn redirect_uris<I: Into<Cow<'a, str>>>(&mut self, uris: I)
         -> &mut Self {
            self.redirect_uris = Some(uris.into());
            self
        }
        /// Permission scope of the application.
        ///
        /// IF none is specified, the default is Scopes::read_all()
        pub fn scopes(&mut self, scopes: Scopes) -> &mut Self {
            self.scopes = Some(scopes);
            self
        }
        /// URL to the homepage of your application.
        pub fn website<I: Into<Cow<'a, str>>>(&mut self, website: I)
         -> &mut Self {
            self.website = Some(website.into());
            self
        }
        /// Attempts to convert this build into an `App`
        ///
        /// Will fail if no `client_name` was provided
        pub fn build(self) -> Result<App> {
            Ok(App{client_name:
                       self.client_name.ok_or_else(||
                                                       Error::MissingField("client_name"))?.into(),
                   redirect_uris:
                       self.redirect_uris.unwrap_or_else(||
                                                             "urn:ietf:wg:oauth:2.0:oob".into()).into(),
                   scopes: self.scopes.unwrap_or_else(|| Scopes::read_all()),
                   website: self.website.map(|s| s.into()),})
        }
    }
    impl TryInto<App> for App {
        type Err = Error;
        fn try_into(self) -> Result<App> { Ok(self) }
    }
    impl <'a> TryInto<App> for AppBuilder<'a> {
        type Err = Error;
        fn try_into(self) -> Result<App> { Ok(self.build()?) }
    }
}
/// Contains the struct that holds the client auth data
pub mod data {
    use std::borrow::Cow;
    /// Raw data about mastodon app. Save `Data` using `serde` to prevent needing
    /// to authenticate on every run.
    pub struct Data {
        /// Base url of instance eg. `https://mastodon.social`.
        pub base: Cow<'static, str>,
        /// The client's id given by the instance.
        pub client_id: Cow<'static, str>,
        /// The client's secret given by the instance.
        pub client_secret: Cow<'static, str>,
        /// Url to redirect back to your application from the instance signup.
        pub redirect: Cow<'static, str>,
        /// The client's access token.
        pub token: Cow<'static, str>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Data {
        #[inline]
        fn clone(&self) -> Data {
            match *self {
                Data {
                base: ref __self_0_0,
                client_id: ref __self_0_1,
                client_secret: ref __self_0_2,
                redirect: ref __self_0_3,
                token: ref __self_0_4 } =>
                Data{base: ::core::clone::Clone::clone(&(*__self_0_0)),
                     client_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                     client_secret:
                         ::core::clone::Clone::clone(&(*__self_0_2)),
                     redirect: ::core::clone::Clone::clone(&(*__self_0_3)),
                     token: ::core::clone::Clone::clone(&(*__self_0_4)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Data {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Data {
                base: ref __self_0_0,
                client_id: ref __self_0_1,
                client_secret: ref __self_0_2,
                redirect: ref __self_0_3,
                token: ref __self_0_4 } => {
                    let mut debug_trait_builder = f.debug_struct("Data");
                    let _ =
                        debug_trait_builder.field("base", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("client_id",
                                                  &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("client_secret",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("redirect",
                                                  &&(*__self_0_3));
                    let _ =
                        debug_trait_builder.field("token", &&(*__self_0_4));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Data { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Data {
        #[inline]
        fn eq(&self, other: &Data) -> bool {
            match *other {
                Data {
                base: ref __self_1_0,
                client_id: ref __self_1_1,
                client_secret: ref __self_1_2,
                redirect: ref __self_1_3,
                token: ref __self_1_4 } =>
                match *self {
                    Data {
                    base: ref __self_0_0,
                    client_id: ref __self_0_1,
                    client_secret: ref __self_0_2,
                    redirect: ref __self_0_3,
                    token: ref __self_0_4 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3) &&
                        (*__self_0_4) == (*__self_1_4),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Data) -> bool {
            match *other {
                Data {
                base: ref __self_1_0,
                client_id: ref __self_1_1,
                client_secret: ref __self_1_2,
                redirect: ref __self_1_3,
                token: ref __self_1_4 } =>
                match *self {
                    Data {
                    base: ref __self_0_0,
                    client_id: ref __self_0_1,
                    client_secret: ref __self_0_2,
                    redirect: ref __self_0_3,
                    token: ref __self_0_4 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3) ||
                        (*__self_0_4) != (*__self_1_4),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Data: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl <'de> _serde::Deserialize<'de> for Data {
                fn deserialize<__D>(__deserializer: __D)
                 -> _serde::export::Result<Self, __D::Error> where
                 __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                3u64 => _serde::export::Ok(__Field::__field3),
                                4u64 => _serde::export::Ok(__Field::__field4),
                                _ =>
                                _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                     &"field index 0 <= i < 5")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                "base" =>
                                _serde::export::Ok(__Field::__field0),
                                "client_id" =>
                                _serde::export::Ok(__Field::__field1),
                                "client_secret" =>
                                _serde::export::Ok(__Field::__field2),
                                "redirect" =>
                                _serde::export::Ok(__Field::__field3),
                                "token" =>
                                _serde::export::Ok(__Field::__field4),
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                b"base" =>
                                _serde::export::Ok(__Field::__field0),
                                b"client_id" =>
                                _serde::export::Ok(__Field::__field1),
                                b"client_secret" =>
                                _serde::export::Ok(__Field::__field2),
                                b"redirect" =>
                                _serde::export::Ok(__Field::__field3),
                                b"token" =>
                                _serde::export::Ok(__Field::__field4),
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    impl <'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                         __FieldVisitor)
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Data>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Data;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "struct Data")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match match _serde::de::SeqAccess::next_element::<Cow<'static,
                                                                                      str>>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                     &"struct Data with 5 elements"));
                                    }
                                };
                            let __field1 =
                                match match _serde::de::SeqAccess::next_element::<Cow<'static,
                                                                                      str>>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                     &"struct Data with 5 elements"));
                                    }
                                };
                            let __field2 =
                                match match _serde::de::SeqAccess::next_element::<Cow<'static,
                                                                                      str>>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                     &"struct Data with 5 elements"));
                                    }
                                };
                            let __field3 =
                                match match _serde::de::SeqAccess::next_element::<Cow<'static,
                                                                                      str>>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                     &"struct Data with 5 elements"));
                                    }
                                };
                            let __field4 =
                                match match _serde::de::SeqAccess::next_element::<Cow<'static,
                                                                                      str>>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                     &"struct Data with 5 elements"));
                                    }
                                };
                            _serde::export::Ok(Data{base: __field0,
                                                    client_id: __field1,
                                                    client_secret: __field2,
                                                    redirect: __field3,
                                                    token: __field4,})
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::MapAccess<'de> {
                            let mut __field0:
                                    _serde::export::Option<Cow<'static,
                                                               str>> =
                                _serde::export::None;
                            let mut __field1:
                                    _serde::export::Option<Cow<'static,
                                                               str>> =
                                _serde::export::None;
                            let mut __field2:
                                    _serde::export::Option<Cow<'static,
                                                               str>> =
                                _serde::export::None;
                            let mut __field3:
                                    _serde::export::Option<Cow<'static,
                                                               str>> =
                                _serde::export::None;
                            let mut __field4:
                                    _serde::export::Option<Cow<'static,
                                                               str>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                      match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("base"));
                                        }
                                        __field0 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<Cow<'static,
                                                                                                               str>>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("client_id"));
                                        }
                                        __field1 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<Cow<'static,
                                                                                                               str>>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("client_secret"));
                                        }
                                        __field2 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<Cow<'static,
                                                                                                               str>>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    __Field::__field3 => {
                                        if _serde::export::Option::is_some(&__field3)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("redirect"));
                                        }
                                        __field3 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<Cow<'static,
                                                                                                               str>>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    __Field::__field4 => {
                                        if _serde::export::Option::is_some(&__field4)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("token"));
                                        }
                                        __field4 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<Cow<'static,
                                                                                                               str>>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    _ => {
                                        let _ =
                                            match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::export::Some(__field0) =>
                                    __field0,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("base")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            let __field1 =
                                match __field1 {
                                    _serde::export::Some(__field1) =>
                                    __field1,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("client_id")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            let __field2 =
                                match __field2 {
                                    _serde::export::Some(__field2) =>
                                    __field2,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("client_secret")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            let __field3 =
                                match __field3 {
                                    _serde::export::Some(__field3) =>
                                    __field3,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("redirect")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            let __field4 =
                                match __field4 {
                                    _serde::export::Some(__field4) =>
                                    __field4,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("token")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            _serde::export::Ok(Data{base: __field0,
                                                    client_id: __field1,
                                                    client_secret: __field2,
                                                    redirect: __field3,
                                                    token: __field4,})
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["base", "client_id", "client_secret", "redirect",
                          "token"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                                                             "Data", FIELDS,
                                                             __Visitor{marker:
                                                                           _serde::export::PhantomData::<Data>,
                                                                       lifetime:
                                                                           _serde::export::PhantomData,})
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Data: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl _serde::Serialize for Data {
                fn serialize<__S>(&self, __serializer: __S)
                 -> _serde::export::Result<__S::Ok, __S::Error> where
                 __S: _serde::Serializer {
                    let mut __serde_state =
                        match _serde::Serializer::serialize_struct(__serializer,
                                                                   "Data",
                                                                   false as
                                                                       usize +
                                                                       1 + 1 +
                                                                       1 + 1 +
                                                                       1) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "base",
                                                                        &self.base)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "client_id",
                                                                        &self.client_id)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "client_secret",
                                                                        &self.client_secret)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "redirect",
                                                                        &self.redirect)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                        "token",
                                                                        &self.token)
                        {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
}
/// Entities returned from the API
pub mod entities {
    /// Data structures for ser/de of account-related resources
    pub mod account {
        //! A module containing everything relating to a account returned from the api.
        use chrono::prelude::*;
        use serde::de::{self, Deserialize, Deserializer, Unexpected};
        use crate::status_builder;
        use std::path::PathBuf;
        /// A struct representing an Account.
        pub struct Account {
            /// Equals `username` for local users, includes `@domain` for remote ones.
            pub acct: String,
            /// URL to the avatar image
            pub avatar: String,
            /// URL to the avatar static image (gif)
            pub avatar_static: String,
            /// The time the account was created.
            pub created_at: DateTime<Utc>,
            /// The account's display name.
            pub display_name: String,
            /// The number of followers for the account.
            pub followers_count: u64,
            /// The number of accounts the given account is following.
            pub following_count: u64,
            /// URL to the header image.
            pub header: String,
            /// URL to the header static image (gif).
            pub header_static: String,
            /// The ID of the account.
            pub id: String,
            /// Boolean for when the account cannot be followed without waiting for
            /// approval first.
            pub locked: bool,
            /// Biography of user.
            pub note: String,
            /// The number of statuses the account has made.
            pub statuses_count: u64,
            /// URL of the user's profile page (can be remote).
            pub url: String,
            /// The username of the account.
            pub username: String,
            /// An extra attribute given from `verify_credentials` giving defaults about
            /// a user
            pub source: Option<Source>,
            /// If the owner decided to switch accounts, new account is in
            /// this attribute
            pub moved: Option<Box<Account>>,
            /// List of profile metadata fields
            pub fields: Option<Vec<MetadataField>>,
            /// Boolean indicating whether this account is a bot or not
            pub bot: Option<bool>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Account {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Account {
                    acct: ref __self_0_0,
                    avatar: ref __self_0_1,
                    avatar_static: ref __self_0_2,
                    created_at: ref __self_0_3,
                    display_name: ref __self_0_4,
                    followers_count: ref __self_0_5,
                    following_count: ref __self_0_6,
                    header: ref __self_0_7,
                    header_static: ref __self_0_8,
                    id: ref __self_0_9,
                    locked: ref __self_0_10,
                    note: ref __self_0_11,
                    statuses_count: ref __self_0_12,
                    url: ref __self_0_13,
                    username: ref __self_0_14,
                    source: ref __self_0_15,
                    moved: ref __self_0_16,
                    fields: ref __self_0_17,
                    bot: ref __self_0_18 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Account");
                        let _ =
                            debug_trait_builder.field("acct",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("avatar",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("avatar_static",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("created_at",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("display_name",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("followers_count",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("following_count",
                                                      &&(*__self_0_6));
                        let _ =
                            debug_trait_builder.field("header",
                                                      &&(*__self_0_7));
                        let _ =
                            debug_trait_builder.field("header_static",
                                                      &&(*__self_0_8));
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_9));
                        let _ =
                            debug_trait_builder.field("locked",
                                                      &&(*__self_0_10));
                        let _ =
                            debug_trait_builder.field("note",
                                                      &&(*__self_0_11));
                        let _ =
                            debug_trait_builder.field("statuses_count",
                                                      &&(*__self_0_12));
                        let _ =
                            debug_trait_builder.field("url",
                                                      &&(*__self_0_13));
                        let _ =
                            debug_trait_builder.field("username",
                                                      &&(*__self_0_14));
                        let _ =
                            debug_trait_builder.field("source",
                                                      &&(*__self_0_15));
                        let _ =
                            debug_trait_builder.field("moved",
                                                      &&(*__self_0_16));
                        let _ =
                            debug_trait_builder.field("fields",
                                                      &&(*__self_0_17));
                        let _ =
                            debug_trait_builder.field("bot",
                                                      &&(*__self_0_18));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Account {
            #[inline]
            fn clone(&self) -> Account {
                match *self {
                    Account {
                    acct: ref __self_0_0,
                    avatar: ref __self_0_1,
                    avatar_static: ref __self_0_2,
                    created_at: ref __self_0_3,
                    display_name: ref __self_0_4,
                    followers_count: ref __self_0_5,
                    following_count: ref __self_0_6,
                    header: ref __self_0_7,
                    header_static: ref __self_0_8,
                    id: ref __self_0_9,
                    locked: ref __self_0_10,
                    note: ref __self_0_11,
                    statuses_count: ref __self_0_12,
                    url: ref __self_0_13,
                    username: ref __self_0_14,
                    source: ref __self_0_15,
                    moved: ref __self_0_16,
                    fields: ref __self_0_17,
                    bot: ref __self_0_18 } =>
                    Account{acct: ::core::clone::Clone::clone(&(*__self_0_0)),
                            avatar:
                                ::core::clone::Clone::clone(&(*__self_0_1)),
                            avatar_static:
                                ::core::clone::Clone::clone(&(*__self_0_2)),
                            created_at:
                                ::core::clone::Clone::clone(&(*__self_0_3)),
                            display_name:
                                ::core::clone::Clone::clone(&(*__self_0_4)),
                            followers_count:
                                ::core::clone::Clone::clone(&(*__self_0_5)),
                            following_count:
                                ::core::clone::Clone::clone(&(*__self_0_6)),
                            header:
                                ::core::clone::Clone::clone(&(*__self_0_7)),
                            header_static:
                                ::core::clone::Clone::clone(&(*__self_0_8)),
                            id: ::core::clone::Clone::clone(&(*__self_0_9)),
                            locked:
                                ::core::clone::Clone::clone(&(*__self_0_10)),
                            note:
                                ::core::clone::Clone::clone(&(*__self_0_11)),
                            statuses_count:
                                ::core::clone::Clone::clone(&(*__self_0_12)),
                            url: ::core::clone::Clone::clone(&(*__self_0_13)),
                            username:
                                ::core::clone::Clone::clone(&(*__self_0_14)),
                            source:
                                ::core::clone::Clone::clone(&(*__self_0_15)),
                            moved:
                                ::core::clone::Clone::clone(&(*__self_0_16)),
                            fields:
                                ::core::clone::Clone::clone(&(*__self_0_17)),
                            bot:
                                ::core::clone::Clone::clone(&(*__self_0_18)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Account: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Account {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                            __field17,
                            __field18,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    6u64 =>
                                    _serde::export::Ok(__Field::__field6),
                                    7u64 =>
                                    _serde::export::Ok(__Field::__field7),
                                    8u64 =>
                                    _serde::export::Ok(__Field::__field8),
                                    9u64 =>
                                    _serde::export::Ok(__Field::__field9),
                                    10u64 =>
                                    _serde::export::Ok(__Field::__field10),
                                    11u64 =>
                                    _serde::export::Ok(__Field::__field11),
                                    12u64 =>
                                    _serde::export::Ok(__Field::__field12),
                                    13u64 =>
                                    _serde::export::Ok(__Field::__field13),
                                    14u64 =>
                                    _serde::export::Ok(__Field::__field14),
                                    15u64 =>
                                    _serde::export::Ok(__Field::__field15),
                                    16u64 =>
                                    _serde::export::Ok(__Field::__field16),
                                    17u64 =>
                                    _serde::export::Ok(__Field::__field17),
                                    18u64 =>
                                    _serde::export::Ok(__Field::__field18),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 19")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "acct" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "avatar" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "avatar_static" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "created_at" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "display_name" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "followers_count" =>
                                    _serde::export::Ok(__Field::__field5),
                                    "following_count" =>
                                    _serde::export::Ok(__Field::__field6),
                                    "header" =>
                                    _serde::export::Ok(__Field::__field7),
                                    "header_static" =>
                                    _serde::export::Ok(__Field::__field8),
                                    "id" =>
                                    _serde::export::Ok(__Field::__field9),
                                    "locked" =>
                                    _serde::export::Ok(__Field::__field10),
                                    "note" =>
                                    _serde::export::Ok(__Field::__field11),
                                    "statuses_count" =>
                                    _serde::export::Ok(__Field::__field12),
                                    "url" =>
                                    _serde::export::Ok(__Field::__field13),
                                    "username" =>
                                    _serde::export::Ok(__Field::__field14),
                                    "source" =>
                                    _serde::export::Ok(__Field::__field15),
                                    "moved" =>
                                    _serde::export::Ok(__Field::__field16),
                                    "fields" =>
                                    _serde::export::Ok(__Field::__field17),
                                    "bot" =>
                                    _serde::export::Ok(__Field::__field18),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"acct" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"avatar" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"avatar_static" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"created_at" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"display_name" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"followers_count" =>
                                    _serde::export::Ok(__Field::__field5),
                                    b"following_count" =>
                                    _serde::export::Ok(__Field::__field6),
                                    b"header" =>
                                    _serde::export::Ok(__Field::__field7),
                                    b"header_static" =>
                                    _serde::export::Ok(__Field::__field8),
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field9),
                                    b"locked" =>
                                    _serde::export::Ok(__Field::__field10),
                                    b"note" =>
                                    _serde::export::Ok(__Field::__field11),
                                    b"statuses_count" =>
                                    _serde::export::Ok(__Field::__field12),
                                    b"url" =>
                                    _serde::export::Ok(__Field::__field13),
                                    b"username" =>
                                    _serde::export::Ok(__Field::__field14),
                                    b"source" =>
                                    _serde::export::Ok(__Field::__field15),
                                    b"moved" =>
                                    _serde::export::Ok(__Field::__field16),
                                    b"fields" =>
                                    _serde::export::Ok(__Field::__field17),
                                    b"bot" =>
                                    _serde::export::Ok(__Field::__field18),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Account>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Account;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Account")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<DateTime<Utc>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field5 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field6 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field7 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(7usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field8 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(8usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field9 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(9usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field10 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(10usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field11 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(11usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field12 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(12usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field13 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(13usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field14 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(14usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field15 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Source>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(15usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field16 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Box<Account>>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(16usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field17 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Vec<MetadataField>>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(17usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                let __field18 =
                                    match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(18usize,
                                                                                                         &"struct Account with 19 elements"));
                                        }
                                    };
                                _serde::export::Ok(Account{acct: __field0,
                                                           avatar: __field1,
                                                           avatar_static:
                                                               __field2,
                                                           created_at:
                                                               __field3,
                                                           display_name:
                                                               __field4,
                                                           followers_count:
                                                               __field5,
                                                           following_count:
                                                               __field6,
                                                           header: __field7,
                                                           header_static:
                                                               __field8,
                                                           id: __field9,
                                                           locked: __field10,
                                                           note: __field11,
                                                           statuses_count:
                                                               __field12,
                                                           url: __field13,
                                                           username:
                                                               __field14,
                                                           source: __field15,
                                                           moved: __field16,
                                                           fields: __field17,
                                                           bot: __field18,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<DateTime<Utc>> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field5:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                let mut __field6:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                let mut __field7:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field8:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field9:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field10:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field11:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field12:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                let mut __field13:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field14:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field15:
                                        _serde::export::Option<Option<Source>> =
                                    _serde::export::None;
                                let mut __field16:
                                        _serde::export::Option<Option<Box<Account>>> =
                                    _serde::export::None;
                                let mut __field17:
                                        _serde::export::Option<Option<Vec<MetadataField>>> =
                                    _serde::export::None;
                                let mut __field18:
                                        _serde::export::Option<Option<bool>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("acct"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("avatar"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("avatar_static"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("created_at"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<DateTime<Utc>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("display_name"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field5 => {
                                            if _serde::export::Option::is_some(&__field5)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("followers_count"));
                                            }
                                            __field5 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field6 => {
                                            if _serde::export::Option::is_some(&__field6)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("following_count"));
                                            }
                                            __field6 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field7 => {
                                            if _serde::export::Option::is_some(&__field7)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("header"));
                                            }
                                            __field7 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field8 => {
                                            if _serde::export::Option::is_some(&__field8)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("header_static"));
                                            }
                                            __field8 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field9 => {
                                            if _serde::export::Option::is_some(&__field9)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field9 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field10 => {
                                            if _serde::export::Option::is_some(&__field10)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("locked"));
                                            }
                                            __field10 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field11 => {
                                            if _serde::export::Option::is_some(&__field11)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("note"));
                                            }
                                            __field11 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field12 => {
                                            if _serde::export::Option::is_some(&__field12)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("statuses_count"));
                                            }
                                            __field12 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field13 => {
                                            if _serde::export::Option::is_some(&__field13)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("url"));
                                            }
                                            __field13 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field14 => {
                                            if _serde::export::Option::is_some(&__field14)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("username"));
                                            }
                                            __field14 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field15 => {
                                            if _serde::export::Option::is_some(&__field15)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("source"));
                                            }
                                            __field15 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Source>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field16 => {
                                            if _serde::export::Option::is_some(&__field16)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("moved"));
                                            }
                                            __field16 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Box<Account>>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field17 => {
                                            if _serde::export::Option::is_some(&__field17)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("fields"));
                                            }
                                            __field17 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Vec<MetadataField>>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field18 => {
                                            if _serde::export::Option::is_some(&__field18)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("bot"));
                                            }
                                            __field18 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("acct")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("avatar")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("avatar_static")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("created_at")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("display_name")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::export::Some(__field5) =>
                                        __field5,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("followers_count")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field6 =
                                    match __field6 {
                                        _serde::export::Some(__field6) =>
                                        __field6,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("following_count")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field7 =
                                    match __field7 {
                                        _serde::export::Some(__field7) =>
                                        __field7,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("header")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field8 =
                                    match __field8 {
                                        _serde::export::Some(__field8) =>
                                        __field8,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("header_static")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field9 =
                                    match __field9 {
                                        _serde::export::Some(__field9) =>
                                        __field9,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field10 =
                                    match __field10 {
                                        _serde::export::Some(__field10) =>
                                        __field10,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("locked")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field11 =
                                    match __field11 {
                                        _serde::export::Some(__field11) =>
                                        __field11,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("note")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field12 =
                                    match __field12 {
                                        _serde::export::Some(__field12) =>
                                        __field12,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("statuses_count")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field13 =
                                    match __field13 {
                                        _serde::export::Some(__field13) =>
                                        __field13,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field14 =
                                    match __field14 {
                                        _serde::export::Some(__field14) =>
                                        __field14,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("username")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field15 =
                                    match __field15 {
                                        _serde::export::Some(__field15) =>
                                        __field15,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("source")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field16 =
                                    match __field16 {
                                        _serde::export::Some(__field16) =>
                                        __field16,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("moved")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field17 =
                                    match __field17 {
                                        _serde::export::Some(__field17) =>
                                        __field17,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("fields")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field18 =
                                    match __field18 {
                                        _serde::export::Some(__field18) =>
                                        __field18,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("bot")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Account{acct: __field0,
                                                           avatar: __field1,
                                                           avatar_static:
                                                               __field2,
                                                           created_at:
                                                               __field3,
                                                           display_name:
                                                               __field4,
                                                           followers_count:
                                                               __field5,
                                                           following_count:
                                                               __field6,
                                                           header: __field7,
                                                           header_static:
                                                               __field8,
                                                           id: __field9,
                                                           locked: __field10,
                                                           note: __field11,
                                                           statuses_count:
                                                               __field12,
                                                           url: __field13,
                                                           username:
                                                               __field14,
                                                           source: __field15,
                                                           moved: __field16,
                                                           fields: __field17,
                                                           bot: __field18,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["acct", "avatar", "avatar_static", "created_at",
                              "display_name", "followers_count",
                              "following_count", "header", "header_static",
                              "id", "locked", "note", "statuses_count", "url",
                              "username", "source", "moved", "fields", "bot"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Account",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Account>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Account { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Account {
            #[inline]
            fn eq(&self, other: &Account) -> bool {
                match *other {
                    Account {
                    acct: ref __self_1_0,
                    avatar: ref __self_1_1,
                    avatar_static: ref __self_1_2,
                    created_at: ref __self_1_3,
                    display_name: ref __self_1_4,
                    followers_count: ref __self_1_5,
                    following_count: ref __self_1_6,
                    header: ref __self_1_7,
                    header_static: ref __self_1_8,
                    id: ref __self_1_9,
                    locked: ref __self_1_10,
                    note: ref __self_1_11,
                    statuses_count: ref __self_1_12,
                    url: ref __self_1_13,
                    username: ref __self_1_14,
                    source: ref __self_1_15,
                    moved: ref __self_1_16,
                    fields: ref __self_1_17,
                    bot: ref __self_1_18 } =>
                    match *self {
                        Account {
                        acct: ref __self_0_0,
                        avatar: ref __self_0_1,
                        avatar_static: ref __self_0_2,
                        created_at: ref __self_0_3,
                        display_name: ref __self_0_4,
                        followers_count: ref __self_0_5,
                        following_count: ref __self_0_6,
                        header: ref __self_0_7,
                        header_static: ref __self_0_8,
                        id: ref __self_0_9,
                        locked: ref __self_0_10,
                        note: ref __self_0_11,
                        statuses_count: ref __self_0_12,
                        url: ref __self_0_13,
                        username: ref __self_0_14,
                        source: ref __self_0_15,
                        moved: ref __self_0_16,
                        fields: ref __self_0_17,
                        bot: ref __self_0_18 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5) &&
                            (*__self_0_6) == (*__self_1_6) &&
                            (*__self_0_7) == (*__self_1_7) &&
                            (*__self_0_8) == (*__self_1_8) &&
                            (*__self_0_9) == (*__self_1_9) &&
                            (*__self_0_10) == (*__self_1_10) &&
                            (*__self_0_11) == (*__self_1_11) &&
                            (*__self_0_12) == (*__self_1_12) &&
                            (*__self_0_13) == (*__self_1_13) &&
                            (*__self_0_14) == (*__self_1_14) &&
                            (*__self_0_15) == (*__self_1_15) &&
                            (*__self_0_16) == (*__self_1_16) &&
                            (*__self_0_17) == (*__self_1_17) &&
                            (*__self_0_18) == (*__self_1_18),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Account) -> bool {
                match *other {
                    Account {
                    acct: ref __self_1_0,
                    avatar: ref __self_1_1,
                    avatar_static: ref __self_1_2,
                    created_at: ref __self_1_3,
                    display_name: ref __self_1_4,
                    followers_count: ref __self_1_5,
                    following_count: ref __self_1_6,
                    header: ref __self_1_7,
                    header_static: ref __self_1_8,
                    id: ref __self_1_9,
                    locked: ref __self_1_10,
                    note: ref __self_1_11,
                    statuses_count: ref __self_1_12,
                    url: ref __self_1_13,
                    username: ref __self_1_14,
                    source: ref __self_1_15,
                    moved: ref __self_1_16,
                    fields: ref __self_1_17,
                    bot: ref __self_1_18 } =>
                    match *self {
                        Account {
                        acct: ref __self_0_0,
                        avatar: ref __self_0_1,
                        avatar_static: ref __self_0_2,
                        created_at: ref __self_0_3,
                        display_name: ref __self_0_4,
                        followers_count: ref __self_0_5,
                        following_count: ref __self_0_6,
                        header: ref __self_0_7,
                        header_static: ref __self_0_8,
                        id: ref __self_0_9,
                        locked: ref __self_0_10,
                        note: ref __self_0_11,
                        statuses_count: ref __self_0_12,
                        url: ref __self_0_13,
                        username: ref __self_0_14,
                        source: ref __self_0_15,
                        moved: ref __self_0_16,
                        fields: ref __self_0_17,
                        bot: ref __self_0_18 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5) ||
                            (*__self_0_6) != (*__self_1_6) ||
                            (*__self_0_7) != (*__self_1_7) ||
                            (*__self_0_8) != (*__self_1_8) ||
                            (*__self_0_9) != (*__self_1_9) ||
                            (*__self_0_10) != (*__self_1_10) ||
                            (*__self_0_11) != (*__self_1_11) ||
                            (*__self_0_12) != (*__self_1_12) ||
                            (*__self_0_13) != (*__self_1_13) ||
                            (*__self_0_14) != (*__self_1_14) ||
                            (*__self_0_15) != (*__self_1_15) ||
                            (*__self_0_16) != (*__self_1_16) ||
                            (*__self_0_17) != (*__self_1_17) ||
                            (*__self_0_18) != (*__self_1_18),
                    },
                }
            }
        }
        /// A single name: value pair from a user's profile
        pub struct MetadataField {
            /// name part of metadata
            pub name: String,
            /// value part of metadata
            pub value: String,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for MetadataField {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    MetadataField {
                    name: ref __self_0_0, value: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("MetadataField");
                        let _ =
                            debug_trait_builder.field("name",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("value",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MetadataField {
            #[inline]
            fn clone(&self) -> MetadataField {
                match *self {
                    MetadataField {
                    name: ref __self_0_0, value: ref __self_0_1 } =>
                    MetadataField{name:
                                      ::core::clone::Clone::clone(&(*__self_0_0)),
                                  value:
                                      ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_MetadataField: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl _serde::Serialize for MetadataField {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "MetadataField",
                                                                       false
                                                                           as
                                                                           usize
                                                                           + 1
                                                                           +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "name",
                                                                            &self.name)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "value",
                                                                            &self.value)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_MetadataField: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for MetadataField {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field { __field0, __field1, __ignore, }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 2")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "name" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "value" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"name" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"value" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<MetadataField>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = MetadataField;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct MetadataField")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct MetadataField with 2 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct MetadataField with 2 elements"));
                                        }
                                    };
                                _serde::export::Ok(MetadataField{name:
                                                                     __field0,
                                                                 value:
                                                                     __field1,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("name"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("value"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("name")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("value")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(MetadataField{name:
                                                                     __field0,
                                                                 value:
                                                                     __field1,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["name", "value"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "MetadataField",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<MetadataField>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for MetadataField { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for MetadataField {
            #[inline]
            fn eq(&self, other: &MetadataField) -> bool {
                match *other {
                    MetadataField {
                    name: ref __self_1_0, value: ref __self_1_1 } =>
                    match *self {
                        MetadataField {
                        name: ref __self_0_0, value: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &MetadataField) -> bool {
                match *other {
                    MetadataField {
                    name: ref __self_1_0, value: ref __self_1_1 } =>
                    match *self {
                        MetadataField {
                        name: ref __self_0_0, value: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for MetadataField {
            #[inline]
            fn default() -> MetadataField {
                MetadataField{name: ::core::default::Default::default(),
                              value: ::core::default::Default::default(),}
            }
        }
        impl MetadataField {
            pub(crate) fn new(name: &str, value: &str) -> MetadataField {
                MetadataField{name: name.into(), value: value.into(),}
            }
        }
        /// An extra object given from `verify_credentials` giving defaults about a user
        pub struct Source {
            privacy: Option<status_builder::Visibility>,
            #[serde(deserialize_with = "string_or_bool")]
            sensitive: bool,
            note: Option<String>,
            fields: Option<Vec<MetadataField>>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Source {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Source {
                    privacy: ref __self_0_0,
                    sensitive: ref __self_0_1,
                    note: ref __self_0_2,
                    fields: ref __self_0_3 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Source");
                        let _ =
                            debug_trait_builder.field("privacy",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("sensitive",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("note",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("fields",
                                                      &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Source {
            #[inline]
            fn clone(&self) -> Source {
                match *self {
                    Source {
                    privacy: ref __self_0_0,
                    sensitive: ref __self_0_1,
                    note: ref __self_0_2,
                    fields: ref __self_0_3 } =>
                    Source{privacy:
                               ::core::clone::Clone::clone(&(*__self_0_0)),
                           sensitive:
                               ::core::clone::Clone::clone(&(*__self_0_1)),
                           note: ::core::clone::Clone::clone(&(*__self_0_2)),
                           fields:
                               ::core::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Source: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Source {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 4")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "privacy" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "sensitive" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "note" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "fields" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"privacy" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"sensitive" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"note" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"fields" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Source>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Source;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Source")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<Option<status_builder::Visibility>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Source with 4 elements"));
                                        }
                                    };
                                let __field1 =
                                    match {
                                              struct __DeserializeWith<'de> {
                                                  value: bool,
                                                  phantom: _serde::export::PhantomData<Source>,
                                                  lifetime: _serde::export::PhantomData<&'de ()>,
                                              }
                                              impl <'de>
                                               _serde::Deserialize<'de> for
                                               __DeserializeWith<'de> {
                                                  fn deserialize<__D>(__deserializer:
                                                                          __D)
                                                   ->
                                                       _serde::export::Result<Self,
                                                                              __D::Error>
                                                   where
                                                   __D: _serde::Deserializer<'de> {
                                                      _serde::export::Ok(__DeserializeWith{value:
                                                                                               match string_or_bool(__deserializer)
                                                                                                   {
                                                                                                   _serde::export::Ok(__val)
                                                                                                   =>
                                                                                                   __val,
                                                                                                   _serde::export::Err(__err)
                                                                                                   =>
                                                                                                   {
                                                                                                       return _serde::export::Err(__err);
                                                                                                   }
                                                                                               },
                                                                                           phantom:
                                                                                               _serde::export::PhantomData,
                                                                                           lifetime:
                                                                                               _serde::export::PhantomData,})
                                                  }
                                              }
                                              _serde::export::Option::map(match _serde::de::SeqAccess::next_element::<__DeserializeWith<'de>>(&mut __seq)
                                                                              {
                                                                              _serde::export::Ok(__val)
                                                                              =>
                                                                              __val,
                                                                              _serde::export::Err(__err)
                                                                              =>
                                                                              {
                                                                                  return _serde::export::Err(__err);
                                                                              }
                                                                          },
                                                                          |__wrap|
                                                                              __wrap.value)
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Source with 4 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Source with 4 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Vec<MetadataField>>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Source with 4 elements"));
                                        }
                                    };
                                _serde::export::Ok(Source{privacy: __field0,
                                                          sensitive: __field1,
                                                          note: __field2,
                                                          fields: __field3,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<Option<status_builder::Visibility>> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Option<Vec<MetadataField>>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("privacy"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<status_builder::Visibility>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("sensitive"));
                                            }
                                            __field1 =
                                                _serde::export::Some({
                                                                         struct __DeserializeWith<'de> {
                                                                             value: bool,
                                                                             phantom: _serde::export::PhantomData<Source>,
                                                                             lifetime: _serde::export::PhantomData<&'de ()>,
                                                                         }
                                                                         impl <'de>
                                                                          _serde::Deserialize<'de>
                                                                          for
                                                                          __DeserializeWith<'de>
                                                                          {
                                                                             fn deserialize<__D>(__deserializer:
                                                                                                     __D)
                                                                              ->
                                                                                  _serde::export::Result<Self,
                                                                                                         __D::Error>
                                                                              where
                                                                              __D: _serde::Deserializer<'de> {
                                                                                 _serde::export::Ok(__DeserializeWith{value:
                                                                                                                          match string_or_bool(__deserializer)
                                                                                                                              {
                                                                                                                              _serde::export::Ok(__val)
                                                                                                                              =>
                                                                                                                              __val,
                                                                                                                              _serde::export::Err(__err)
                                                                                                                              =>
                                                                                                                              {
                                                                                                                                  return _serde::export::Err(__err);
                                                                                                                              }
                                                                                                                          },
                                                                                                                      phantom:
                                                                                                                          _serde::export::PhantomData,
                                                                                                                      lifetime:
                                                                                                                          _serde::export::PhantomData,})
                                                                             }
                                                                         }
                                                                         match _serde::de::MapAccess::next_value::<__DeserializeWith<'de>>(&mut __map)
                                                                             {
                                                                             _serde::export::Ok(__wrapper)
                                                                             =>
                                                                             __wrapper.value,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("note"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("fields"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Vec<MetadataField>>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("privacy")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        return _serde::export::Err(<__A::Error
                                                                       as
                                                                       _serde::de::Error>::missing_field("sensitive")),
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("note")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("fields")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Source{privacy: __field0,
                                                          sensitive: __field1,
                                                          note: __field2,
                                                          fields: __field3,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["privacy", "sensitive", "note", "fields"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Source",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Source>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Source { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Source {
            #[inline]
            fn eq(&self, other: &Source) -> bool {
                match *other {
                    Source {
                    privacy: ref __self_1_0,
                    sensitive: ref __self_1_1,
                    note: ref __self_1_2,
                    fields: ref __self_1_3 } =>
                    match *self {
                        Source {
                        privacy: ref __self_0_0,
                        sensitive: ref __self_0_1,
                        note: ref __self_0_2,
                        fields: ref __self_0_3 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Source) -> bool {
                match *other {
                    Source {
                    privacy: ref __self_1_0,
                    sensitive: ref __self_1_1,
                    note: ref __self_1_2,
                    fields: ref __self_1_3 } =>
                    match *self {
                        Source {
                        privacy: ref __self_0_0,
                        sensitive: ref __self_0_1,
                        note: ref __self_0_2,
                        fields: ref __self_0_3 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3),
                    },
                }
            }
        }
        fn string_or_bool<'de, D: Deserializer<'de>>(val: D)
         -> ::std::result::Result<bool, D::Error> {
            #[serde(untagged)]
            pub enum BoolOrString { Bool(bool), Str(String), }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::clone::Clone for BoolOrString {
                #[inline]
                fn clone(&self) -> BoolOrString {
                    match (&*self,) {
                        (&BoolOrString::Bool(ref __self_0),) =>
                        BoolOrString::Bool(::core::clone::Clone::clone(&(*__self_0))),
                        (&BoolOrString::Str(ref __self_0),) =>
                        BoolOrString::Str(::core::clone::Clone::clone(&(*__self_0))),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for BoolOrString {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                 -> ::core::fmt::Result {
                    match (&*self,) {
                        (&BoolOrString::Bool(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Bool");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&BoolOrString::Str(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Str");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes,
                    unused_qualifications)]
            const _IMPL_DESERIALIZE_FOR_BoolOrString: () =
                {
                    #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try {
                        ($ __expr : expr) =>
                        {
                            match $ __expr
                            {
                                _serde :: export :: Ok(__val) => __val, _serde
                                :: export :: Err(__err) =>
                                { return _serde :: export :: Err(__err) ; }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl <'de> _serde::Deserialize<'de> for BoolOrString {
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            let __content =
                                match <_serde::private::de::Content as
                                          _serde::Deserialize>::deserialize(__deserializer)
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            if let _serde::export::Ok(__ok) =
                                   _serde::export::Result::map(<bool as
                                                                   _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                               BoolOrString::Bool)
                               {
                                return _serde::export::Ok(__ok);
                            }
                            if let _serde::export::Ok(__ok) =
                                   _serde::export::Result::map(<String as
                                                                   _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                               BoolOrString::Str)
                               {
                                return _serde::export::Ok(__ok);
                            }
                            _serde::export::Err(_serde::de::Error::custom("data did not match any variant of untagged enum BoolOrString"))
                        }
                    }
                };
            impl ::core::marker::StructuralPartialEq for BoolOrString { }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::cmp::PartialEq for BoolOrString {
                #[inline]
                fn eq(&self, other: &BoolOrString) -> bool {
                    {
                        let __self_vi =
                            unsafe {
                                ::core::intrinsics::discriminant_value(&*self)
                            };
                        let __arg_1_vi =
                            unsafe {
                                ::core::intrinsics::discriminant_value(&*other)
                            };
                        if true && __self_vi == __arg_1_vi {
                            match (&*self, &*other) {
                                (&BoolOrString::Bool(ref __self_0),
                                 &BoolOrString::Bool(ref __arg_1_0)) =>
                                (*__self_0) == (*__arg_1_0),
                                (&BoolOrString::Str(ref __self_0),
                                 &BoolOrString::Str(ref __arg_1_0)) =>
                                (*__self_0) == (*__arg_1_0),
                                _ => unsafe {
                                    ::core::intrinsics::unreachable()
                                }
                            }
                        } else { false }
                    }
                }
                #[inline]
                fn ne(&self, other: &BoolOrString) -> bool {
                    {
                        let __self_vi =
                            unsafe {
                                ::core::intrinsics::discriminant_value(&*self)
                            };
                        let __arg_1_vi =
                            unsafe {
                                ::core::intrinsics::discriminant_value(&*other)
                            };
                        if true && __self_vi == __arg_1_vi {
                            match (&*self, &*other) {
                                (&BoolOrString::Bool(ref __self_0),
                                 &BoolOrString::Bool(ref __arg_1_0)) =>
                                (*__self_0) != (*__arg_1_0),
                                (&BoolOrString::Str(ref __self_0),
                                 &BoolOrString::Str(ref __arg_1_0)) =>
                                (*__self_0) != (*__arg_1_0),
                                _ => unsafe {
                                    ::core::intrinsics::unreachable()
                                }
                            }
                        } else { true }
                    }
                }
            }
            Ok(match BoolOrString::deserialize(val)? {
                   BoolOrString::Bool(b) => b,
                   BoolOrString::Str(ref s) => {
                       if s == "true" {
                           true
                       } else if s == "false" {
                           false
                       } else {
                           return Err(de::Error::invalid_value(Unexpected::Str(s),
                                                               &"true or false"));
                       }
                   }
               })
        }
        pub(crate) struct UpdateSource {
            #[serde(skip_serializing_if = "Option::is_none")]
            pub(crate) privacy: Option<status_builder::Visibility>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub(crate) sensitive: Option<bool>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UpdateSource {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    UpdateSource {
                    privacy: ref __self_0_0, sensitive: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("UpdateSource");
                        let _ =
                            debug_trait_builder.field("privacy",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("sensitive",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for UpdateSource {
            #[inline]
            fn default() -> UpdateSource {
                UpdateSource{privacy: ::core::default::Default::default(),
                             sensitive: ::core::default::Default::default(),}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UpdateSource {
            #[inline]
            fn clone(&self) -> UpdateSource {
                match *self {
                    UpdateSource {
                    privacy: ref __self_0_0, sensitive: ref __self_0_1 } =>
                    UpdateSource{privacy:
                                     ::core::clone::Clone::clone(&(*__self_0_0)),
                                 sensitive:
                                     ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_UpdateSource: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl _serde::Serialize for UpdateSource {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "UpdateSource",
                                                                       false
                                                                           as
                                                                           usize
                                                                           +
                                                                           if Option::is_none(&self.privacy)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if Option::is_none(&self.sensitive)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           })
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        if !Option::is_none(&self.privacy) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "privacy",
                                                                                &self.privacy)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "privacy")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.sensitive) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "sensitive",
                                                                                &self.sensitive)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "sensitive")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for UpdateSource { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for UpdateSource {
            #[inline]
            fn eq(&self, other: &UpdateSource) -> bool {
                match *other {
                    UpdateSource {
                    privacy: ref __self_1_0, sensitive: ref __self_1_1 } =>
                    match *self {
                        UpdateSource {
                        privacy: ref __self_0_0, sensitive: ref __self_0_1 }
                        =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &UpdateSource) -> bool {
                match *other {
                    UpdateSource {
                    privacy: ref __self_1_0, sensitive: ref __self_1_1 } =>
                    match *self {
                        UpdateSource {
                        privacy: ref __self_0_0, sensitive: ref __self_0_1 }
                        =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        pub(crate) struct Credentials {
            #[serde(skip_serializing_if = "Option::is_none")]
            pub(crate) display_name: Option<String>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub(crate) note: Option<String>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub(crate) avatar: Option<PathBuf>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub(crate) header: Option<PathBuf>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub(crate) source: Option<UpdateSource>,
            #[serde(serialize_with = "fields_attributes_ser::ser")]
            pub(crate) fields_attributes: Vec<MetadataField>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Credentials {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Credentials {
                    display_name: ref __self_0_0,
                    note: ref __self_0_1,
                    avatar: ref __self_0_2,
                    header: ref __self_0_3,
                    source: ref __self_0_4,
                    fields_attributes: ref __self_0_5 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Credentials");
                        let _ =
                            debug_trait_builder.field("display_name",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("note",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("avatar",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("header",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("source",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("fields_attributes",
                                                      &&(*__self_0_5));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for Credentials {
            #[inline]
            fn default() -> Credentials {
                Credentials{display_name: ::core::default::Default::default(),
                            note: ::core::default::Default::default(),
                            avatar: ::core::default::Default::default(),
                            header: ::core::default::Default::default(),
                            source: ::core::default::Default::default(),
                            fields_attributes:
                                ::core::default::Default::default(),}
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_Credentials: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl _serde::Serialize for Credentials {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "Credentials",
                                                                       false
                                                                           as
                                                                           usize
                                                                           +
                                                                           if Option::is_none(&self.display_name)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if Option::is_none(&self.note)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if Option::is_none(&self.avatar)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if Option::is_none(&self.header)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if Option::is_none(&self.source)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        if !Option::is_none(&self.display_name) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "display_name",
                                                                                &self.display_name)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "display_name")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.note) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "note",
                                                                                &self.note)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "note")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.avatar) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "avatar",
                                                                                &self.avatar)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "avatar")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.header) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "header",
                                                                                &self.header)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "header")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.source) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "source",
                                                                                &self.source)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "source")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "fields_attributes",
                                                                            {
                                                                                struct __SerializeWith<'__a> {
                                                                                    values: (&'__a Vec<MetadataField>,),
                                                                                    phantom: _serde::export::PhantomData<Credentials>,
                                                                                }
                                                                                impl <'__a>
                                                                                 _serde::Serialize
                                                                                 for
                                                                                 __SerializeWith<'__a>
                                                                                 {
                                                                                    fn serialize<__S>(&self,
                                                                                                      __s:
                                                                                                          __S)
                                                                                     ->
                                                                                         _serde::export::Result<__S::Ok,
                                                                                                                __S::Error>
                                                                                     where
                                                                                     __S: _serde::Serializer {
                                                                                        fields_attributes_ser::ser(self.values.0,
                                                                                                                   __s)
                                                                                    }
                                                                                }
                                                                                &__SerializeWith{values:
                                                                                                     (&self.fields_attributes,),
                                                                                                 phantom:
                                                                                                     _serde::export::PhantomData::<Credentials>,}
                                                                            })
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Credentials { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Credentials {
            #[inline]
            fn eq(&self, other: &Credentials) -> bool {
                match *other {
                    Credentials {
                    display_name: ref __self_1_0,
                    note: ref __self_1_1,
                    avatar: ref __self_1_2,
                    header: ref __self_1_3,
                    source: ref __self_1_4,
                    fields_attributes: ref __self_1_5 } =>
                    match *self {
                        Credentials {
                        display_name: ref __self_0_0,
                        note: ref __self_0_1,
                        avatar: ref __self_0_2,
                        header: ref __self_0_3,
                        source: ref __self_0_4,
                        fields_attributes: ref __self_0_5 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Credentials) -> bool {
                match *other {
                    Credentials {
                    display_name: ref __self_1_0,
                    note: ref __self_1_1,
                    avatar: ref __self_1_2,
                    header: ref __self_1_3,
                    source: ref __self_1_4,
                    fields_attributes: ref __self_1_5 } =>
                    match *self {
                        Credentials {
                        display_name: ref __self_0_0,
                        note: ref __self_0_1,
                        avatar: ref __self_0_2,
                        header: ref __self_0_3,
                        source: ref __self_0_4,
                        fields_attributes: ref __self_0_5 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5),
                    },
                }
            }
        }
        mod fields_attributes_ser {
            use super::*;
            use serde::ser::{SerializeMap, Serializer};
            pub(crate) fn ser<S>(attrs: &Vec<MetadataField>, serializer: S)
             -> Result<S::Ok, S::Error> where S: Serializer {
                let mut map = serializer.serialize_map(Some(attrs.len()))?;
                for (i, field) in attrs.iter().enumerate() {
                    map.serialize_entry(&i, &field)?;
                }
                map.end()
            }
        }
    }
    /// Data structures for ser/de of attachment-related resources
    pub mod attachment {
        //! Module containing everything related to media attachements.
        /// A struct representing a media attachment.
        pub struct Attachment {
            /// ID of the attachment.
            pub id: String,
            /// The media type of an attachment.
            #[serde(rename = "type")]
            pub media_type: MediaType,
            /// URL of the locally hosted version of the image.
            pub url: String,
            /// For remote images, the remote URL of the original image.
            pub remote_url: Option<String>,
            /// URL of the preview image.
            pub preview_url: String,
            /// Shorter URL for the image, for insertion into text
            /// (only present on local images)
            pub text_url: Option<String>,
            /// Meta information about the attachment.
            pub meta: Option<Meta>,
            /// Noop will be removed.
            pub description: Option<String>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Attachment {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Attachment {
                    id: ref __self_0_0,
                    media_type: ref __self_0_1,
                    url: ref __self_0_2,
                    remote_url: ref __self_0_3,
                    preview_url: ref __self_0_4,
                    text_url: ref __self_0_5,
                    meta: ref __self_0_6,
                    description: ref __self_0_7 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Attachment");
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("media_type",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("url", &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("remote_url",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("preview_url",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("text_url",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("meta",
                                                      &&(*__self_0_6));
                        let _ =
                            debug_trait_builder.field("description",
                                                      &&(*__self_0_7));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Attachment {
            #[inline]
            fn clone(&self) -> Attachment {
                match *self {
                    Attachment {
                    id: ref __self_0_0,
                    media_type: ref __self_0_1,
                    url: ref __self_0_2,
                    remote_url: ref __self_0_3,
                    preview_url: ref __self_0_4,
                    text_url: ref __self_0_5,
                    meta: ref __self_0_6,
                    description: ref __self_0_7 } =>
                    Attachment{id:
                                   ::core::clone::Clone::clone(&(*__self_0_0)),
                               media_type:
                                   ::core::clone::Clone::clone(&(*__self_0_1)),
                               url:
                                   ::core::clone::Clone::clone(&(*__self_0_2)),
                               remote_url:
                                   ::core::clone::Clone::clone(&(*__self_0_3)),
                               preview_url:
                                   ::core::clone::Clone::clone(&(*__self_0_4)),
                               text_url:
                                   ::core::clone::Clone::clone(&(*__self_0_5)),
                               meta:
                                   ::core::clone::Clone::clone(&(*__self_0_6)),
                               description:
                                   ::core::clone::Clone::clone(&(*__self_0_7)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Attachment: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Attachment {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    6u64 =>
                                    _serde::export::Ok(__Field::__field6),
                                    7u64 =>
                                    _serde::export::Ok(__Field::__field7),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 8")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "type" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "url" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "remote_url" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "preview_url" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "text_url" =>
                                    _serde::export::Ok(__Field::__field5),
                                    "meta" =>
                                    _serde::export::Ok(__Field::__field6),
                                    "description" =>
                                    _serde::export::Ok(__Field::__field7),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"type" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"url" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"remote_url" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"preview_url" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"text_url" =>
                                    _serde::export::Ok(__Field::__field5),
                                    b"meta" =>
                                    _serde::export::Ok(__Field::__field6),
                                    b"description" =>
                                    _serde::export::Ok(__Field::__field7),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Attachment>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Attachment;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Attachment")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Attachment with 8 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<MediaType>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Attachment with 8 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Attachment with 8 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Attachment with 8 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct Attachment with 8 elements"));
                                        }
                                    };
                                let __field5 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                         &"struct Attachment with 8 elements"));
                                        }
                                    };
                                let __field6 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Meta>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                         &"struct Attachment with 8 elements"));
                                        }
                                    };
                                let __field7 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(7usize,
                                                                                                         &"struct Attachment with 8 elements"));
                                        }
                                    };
                                _serde::export::Ok(Attachment{id: __field0,
                                                              media_type:
                                                                  __field1,
                                                              url: __field2,
                                                              remote_url:
                                                                  __field3,
                                                              preview_url:
                                                                  __field4,
                                                              text_url:
                                                                  __field5,
                                                              meta: __field6,
                                                              description:
                                                                  __field7,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<MediaType> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field5:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field6:
                                        _serde::export::Option<Option<Meta>> =
                                    _serde::export::None;
                                let mut __field7:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("type"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<MediaType>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("url"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("remote_url"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("preview_url"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field5 => {
                                            if _serde::export::Option::is_some(&__field5)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("text_url"));
                                            }
                                            __field5 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field6 => {
                                            if _serde::export::Option::is_some(&__field6)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("meta"));
                                            }
                                            __field6 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Meta>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field7 => {
                                            if _serde::export::Option::is_some(&__field7)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("description"));
                                            }
                                            __field7 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("type")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("remote_url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("preview_url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::export::Some(__field5) =>
                                        __field5,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("text_url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field6 =
                                    match __field6 {
                                        _serde::export::Some(__field6) =>
                                        __field6,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("meta")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field7 =
                                    match __field7 {
                                        _serde::export::Some(__field7) =>
                                        __field7,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("description")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Attachment{id: __field0,
                                                              media_type:
                                                                  __field1,
                                                              url: __field2,
                                                              remote_url:
                                                                  __field3,
                                                              preview_url:
                                                                  __field4,
                                                              text_url:
                                                                  __field5,
                                                              meta: __field6,
                                                              description:
                                                                  __field7,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["id", "type", "url", "remote_url",
                              "preview_url", "text_url", "meta",
                              "description"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Attachment",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Attachment>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Attachment { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Attachment {
            #[inline]
            fn eq(&self, other: &Attachment) -> bool {
                match *other {
                    Attachment {
                    id: ref __self_1_0,
                    media_type: ref __self_1_1,
                    url: ref __self_1_2,
                    remote_url: ref __self_1_3,
                    preview_url: ref __self_1_4,
                    text_url: ref __self_1_5,
                    meta: ref __self_1_6,
                    description: ref __self_1_7 } =>
                    match *self {
                        Attachment {
                        id: ref __self_0_0,
                        media_type: ref __self_0_1,
                        url: ref __self_0_2,
                        remote_url: ref __self_0_3,
                        preview_url: ref __self_0_4,
                        text_url: ref __self_0_5,
                        meta: ref __self_0_6,
                        description: ref __self_0_7 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5) &&
                            (*__self_0_6) == (*__self_1_6) &&
                            (*__self_0_7) == (*__self_1_7),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Attachment) -> bool {
                match *other {
                    Attachment {
                    id: ref __self_1_0,
                    media_type: ref __self_1_1,
                    url: ref __self_1_2,
                    remote_url: ref __self_1_3,
                    preview_url: ref __self_1_4,
                    text_url: ref __self_1_5,
                    meta: ref __self_1_6,
                    description: ref __self_1_7 } =>
                    match *self {
                        Attachment {
                        id: ref __self_0_0,
                        media_type: ref __self_0_1,
                        url: ref __self_0_2,
                        remote_url: ref __self_0_3,
                        preview_url: ref __self_0_4,
                        text_url: ref __self_0_5,
                        meta: ref __self_0_6,
                        description: ref __self_0_7 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5) ||
                            (*__self_0_6) != (*__self_1_6) ||
                            (*__self_0_7) != (*__self_1_7),
                    },
                }
            }
        }
        /// Information about the attachment itself.
        pub struct Meta {
            /// Original version.
            pub original: Option<ImageDetails>,
            /// Smaller version.
            pub small: Option<ImageDetails>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Meta {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Meta { original: ref __self_0_0, small: ref __self_0_1 }
                    => {
                        let mut debug_trait_builder = f.debug_struct("Meta");
                        let _ =
                            debug_trait_builder.field("original",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("small",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Meta: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Meta {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field { __field0, __field1, __ignore, }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 2")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "original" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "small" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"original" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"small" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Meta>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Meta;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Meta")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<Option<ImageDetails>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Meta with 2 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<Option<ImageDetails>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Meta with 2 elements"));
                                        }
                                    };
                                _serde::export::Ok(Meta{original: __field0,
                                                        small: __field1,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<Option<ImageDetails>> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<Option<ImageDetails>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("original"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<ImageDetails>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("small"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<ImageDetails>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("original")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("small")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Meta{original: __field0,
                                                        small: __field1,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["original", "small"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Meta",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Meta>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Meta {
            #[inline]
            fn clone(&self) -> Meta {
                match *self {
                    Meta { original: ref __self_0_0, small: ref __self_0_1 }
                    =>
                    Meta{original:
                             ::core::clone::Clone::clone(&(*__self_0_0)),
                         small: ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Meta { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Meta {
            #[inline]
            fn eq(&self, other: &Meta) -> bool {
                match *other {
                    Meta { original: ref __self_1_0, small: ref __self_1_1 }
                    =>
                    match *self {
                        Meta { original: ref __self_0_0, small: ref __self_0_1
                        } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Meta) -> bool {
                match *other {
                    Meta { original: ref __self_1_0, small: ref __self_1_1 }
                    =>
                    match *self {
                        Meta { original: ref __self_0_0, small: ref __self_0_1
                        } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        /// Dimensions of an attachement.
        pub struct ImageDetails {
            /// width of attachment.
            width: u64,
            /// height of attachment.
            height: u64,
            /// A string of `widthxheight`.
            size: Option<String>,
            /// The aspect ratio of the attachment.
            aspect: Option<f64>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ImageDetails {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    ImageDetails {
                    width: ref __self_0_0,
                    height: ref __self_0_1,
                    size: ref __self_0_2,
                    aspect: ref __self_0_3 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("ImageDetails");
                        let _ =
                            debug_trait_builder.field("width",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("height",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("size",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("aspect",
                                                      &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_ImageDetails: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for ImageDetails {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 4")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "width" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "height" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "size" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "aspect" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"width" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"height" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"size" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"aspect" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<ImageDetails>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = ImageDetails;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct ImageDetails")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct ImageDetails with 4 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct ImageDetails with 4 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct ImageDetails with 4 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Option<f64>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct ImageDetails with 4 elements"));
                                        }
                                    };
                                _serde::export::Ok(ImageDetails{width:
                                                                    __field0,
                                                                height:
                                                                    __field1,
                                                                size:
                                                                    __field2,
                                                                aspect:
                                                                    __field3,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Option<f64>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("width"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("height"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("size"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("aspect"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<f64>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("width")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("height")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("size")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("aspect")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(ImageDetails{width:
                                                                    __field0,
                                                                height:
                                                                    __field1,
                                                                size:
                                                                    __field2,
                                                                aspect:
                                                                    __field3,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["width", "height", "size", "aspect"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "ImageDetails",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<ImageDetails>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ImageDetails {
            #[inline]
            fn clone(&self) -> ImageDetails {
                match *self {
                    ImageDetails {
                    width: ref __self_0_0,
                    height: ref __self_0_1,
                    size: ref __self_0_2,
                    aspect: ref __self_0_3 } =>
                    ImageDetails{width:
                                     ::core::clone::Clone::clone(&(*__self_0_0)),
                                 height:
                                     ::core::clone::Clone::clone(&(*__self_0_1)),
                                 size:
                                     ::core::clone::Clone::clone(&(*__self_0_2)),
                                 aspect:
                                     ::core::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ImageDetails { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ImageDetails {
            #[inline]
            fn eq(&self, other: &ImageDetails) -> bool {
                match *other {
                    ImageDetails {
                    width: ref __self_1_0,
                    height: ref __self_1_1,
                    size: ref __self_1_2,
                    aspect: ref __self_1_3 } =>
                    match *self {
                        ImageDetails {
                        width: ref __self_0_0,
                        height: ref __self_0_1,
                        size: ref __self_0_2,
                        aspect: ref __self_0_3 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &ImageDetails) -> bool {
                match *other {
                    ImageDetails {
                    width: ref __self_1_0,
                    height: ref __self_1_1,
                    size: ref __self_1_2,
                    aspect: ref __self_1_3 } =>
                    match *self {
                        ImageDetails {
                        width: ref __self_0_0,
                        height: ref __self_0_1,
                        size: ref __self_0_2,
                        aspect: ref __self_0_3 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3),
                    },
                }
            }
        }
        /// The type of media attachment.
        pub enum MediaType {

            /// An image.
            #[serde(rename = "image")]
            Image,

            /// A video file.
            #[serde(rename = "video")]
            Video,

            /// A gifv format file.
            #[serde(rename = "gifv")]
            Gifv,

            /// Unknown format.
            #[serde(rename = "unknown")]
            Unknown,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for MediaType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match (&*self,) {
                    (&MediaType::Image,) => {
                        let mut debug_trait_builder = f.debug_tuple("Image");
                        debug_trait_builder.finish()
                    }
                    (&MediaType::Video,) => {
                        let mut debug_trait_builder = f.debug_tuple("Video");
                        debug_trait_builder.finish()
                    }
                    (&MediaType::Gifv,) => {
                        let mut debug_trait_builder = f.debug_tuple("Gifv");
                        debug_trait_builder.finish()
                    }
                    (&MediaType::Unknown,) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("Unknown");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_MediaType: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for MediaType {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"variant index 0 <= i < 4")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "image" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "video" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "gifv" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "unknown" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"image" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"video" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"gifv" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"unknown" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        let __value =
                                            &_serde::export::from_utf8_lossy(__value);
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<MediaType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = MediaType;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "enum MediaType")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::EnumAccess<'de> {
                                match match _serde::de::EnumAccess::variant(__data)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    (__Field::__field0, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(MediaType::Image)
                                    }
                                    (__Field::__field1, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(MediaType::Video)
                                    }
                                    (__Field::__field2, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(MediaType::Gifv)
                                    }
                                    (__Field::__field3, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(MediaType::Unknown)
                                    }
                                }
                            }
                        }
                        const VARIANTS: &'static [&'static str] =
                            &["image", "video", "gifv", "unknown"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                                                               "MediaType",
                                                               VARIANTS,
                                                               __Visitor{marker:
                                                                             _serde::export::PhantomData::<MediaType>,
                                                                         lifetime:
                                                                             _serde::export::PhantomData,})
                    }
                }
            };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MediaType {
            #[inline]
            fn clone(&self) -> MediaType { { *self } }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for MediaType { }
        impl ::core::marker::StructuralPartialEq for MediaType { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for MediaType {
            #[inline]
            fn eq(&self, other: &MediaType) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::core::intrinsics::discriminant_value(&*self)
                        };
                    let __arg_1_vi =
                        unsafe {
                            ::core::intrinsics::discriminant_value(&*other)
                        };
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) { _ => true, }
                    } else { false }
                }
            }
        }
    }
    /// Data structures for ser/de of card-related resources
    pub mod card {
        //! Module representing cards of statuses.
        /// A card of a status.
        pub struct Card {
            /// The url associated with the card.
            pub url: String,
            /// The title of the card.
            pub title: String,
            /// The card description.
            pub description: String,
            /// The image associated with the card, if any.
            pub image: Option<String>,
            /// OEmbed data
            author_name: Option<String>,
            /// OEmbed data
            author_url: Option<String>,
            /// OEmbed data
            provider_name: Option<String>,
            /// OEmbed data
            provider_url: Option<String>,
            /// OEmbed data
            html: Option<String>,
            /// OEmbed data
            width: Option<u64>,
            /// OEmbed data
            height: Option<u64>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Card {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Card {
                    url: ref __self_0_0,
                    title: ref __self_0_1,
                    description: ref __self_0_2,
                    image: ref __self_0_3,
                    author_name: ref __self_0_4,
                    author_url: ref __self_0_5,
                    provider_name: ref __self_0_6,
                    provider_url: ref __self_0_7,
                    html: ref __self_0_8,
                    width: ref __self_0_9,
                    height: ref __self_0_10 } => {
                        let mut debug_trait_builder = f.debug_struct("Card");
                        let _ =
                            debug_trait_builder.field("url", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("title",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("description",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("image",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("author_name",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("author_url",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("provider_name",
                                                      &&(*__self_0_6));
                        let _ =
                            debug_trait_builder.field("provider_url",
                                                      &&(*__self_0_7));
                        let _ =
                            debug_trait_builder.field("html",
                                                      &&(*__self_0_8));
                        let _ =
                            debug_trait_builder.field("width",
                                                      &&(*__self_0_9));
                        let _ =
                            debug_trait_builder.field("height",
                                                      &&(*__self_0_10));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Card {
            #[inline]
            fn clone(&self) -> Card {
                match *self {
                    Card {
                    url: ref __self_0_0,
                    title: ref __self_0_1,
                    description: ref __self_0_2,
                    image: ref __self_0_3,
                    author_name: ref __self_0_4,
                    author_url: ref __self_0_5,
                    provider_name: ref __self_0_6,
                    provider_url: ref __self_0_7,
                    html: ref __self_0_8,
                    width: ref __self_0_9,
                    height: ref __self_0_10 } =>
                    Card{url: ::core::clone::Clone::clone(&(*__self_0_0)),
                         title: ::core::clone::Clone::clone(&(*__self_0_1)),
                         description:
                             ::core::clone::Clone::clone(&(*__self_0_2)),
                         image: ::core::clone::Clone::clone(&(*__self_0_3)),
                         author_name:
                             ::core::clone::Clone::clone(&(*__self_0_4)),
                         author_url:
                             ::core::clone::Clone::clone(&(*__self_0_5)),
                         provider_name:
                             ::core::clone::Clone::clone(&(*__self_0_6)),
                         provider_url:
                             ::core::clone::Clone::clone(&(*__self_0_7)),
                         html: ::core::clone::Clone::clone(&(*__self_0_8)),
                         width: ::core::clone::Clone::clone(&(*__self_0_9)),
                         height:
                             ::core::clone::Clone::clone(&(*__self_0_10)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Card: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Card {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    6u64 =>
                                    _serde::export::Ok(__Field::__field6),
                                    7u64 =>
                                    _serde::export::Ok(__Field::__field7),
                                    8u64 =>
                                    _serde::export::Ok(__Field::__field8),
                                    9u64 =>
                                    _serde::export::Ok(__Field::__field9),
                                    10u64 =>
                                    _serde::export::Ok(__Field::__field10),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 11")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "url" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "title" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "description" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "image" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "author_name" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "author_url" =>
                                    _serde::export::Ok(__Field::__field5),
                                    "provider_name" =>
                                    _serde::export::Ok(__Field::__field6),
                                    "provider_url" =>
                                    _serde::export::Ok(__Field::__field7),
                                    "html" =>
                                    _serde::export::Ok(__Field::__field8),
                                    "width" =>
                                    _serde::export::Ok(__Field::__field9),
                                    "height" =>
                                    _serde::export::Ok(__Field::__field10),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"url" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"title" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"description" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"image" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"author_name" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"author_url" =>
                                    _serde::export::Ok(__Field::__field5),
                                    b"provider_name" =>
                                    _serde::export::Ok(__Field::__field6),
                                    b"provider_url" =>
                                    _serde::export::Ok(__Field::__field7),
                                    b"html" =>
                                    _serde::export::Ok(__Field::__field8),
                                    b"width" =>
                                    _serde::export::Ok(__Field::__field9),
                                    b"height" =>
                                    _serde::export::Ok(__Field::__field10),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Card>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Card;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Card")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field5 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field6 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field7 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(7usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field8 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(8usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field9 =
                                    match match _serde::de::SeqAccess::next_element::<Option<u64>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(9usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                let __field10 =
                                    match match _serde::de::SeqAccess::next_element::<Option<u64>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(10usize,
                                                                                                         &"struct Card with 11 elements"));
                                        }
                                    };
                                _serde::export::Ok(Card{url: __field0,
                                                        title: __field1,
                                                        description: __field2,
                                                        image: __field3,
                                                        author_name: __field4,
                                                        author_url: __field5,
                                                        provider_name:
                                                            __field6,
                                                        provider_url:
                                                            __field7,
                                                        html: __field8,
                                                        width: __field9,
                                                        height: __field10,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field5:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field6:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field7:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field8:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field9:
                                        _serde::export::Option<Option<u64>> =
                                    _serde::export::None;
                                let mut __field10:
                                        _serde::export::Option<Option<u64>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("url"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("title"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("description"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("image"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("author_name"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field5 => {
                                            if _serde::export::Option::is_some(&__field5)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("author_url"));
                                            }
                                            __field5 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field6 => {
                                            if _serde::export::Option::is_some(&__field6)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("provider_name"));
                                            }
                                            __field6 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field7 => {
                                            if _serde::export::Option::is_some(&__field7)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("provider_url"));
                                            }
                                            __field7 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field8 => {
                                            if _serde::export::Option::is_some(&__field8)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("html"));
                                            }
                                            __field8 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field9 => {
                                            if _serde::export::Option::is_some(&__field9)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("width"));
                                            }
                                            __field9 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<u64>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field10 => {
                                            if _serde::export::Option::is_some(&__field10)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("height"));
                                            }
                                            __field10 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<u64>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("title")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("description")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("image")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("author_name")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::export::Some(__field5) =>
                                        __field5,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("author_url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field6 =
                                    match __field6 {
                                        _serde::export::Some(__field6) =>
                                        __field6,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("provider_name")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field7 =
                                    match __field7 {
                                        _serde::export::Some(__field7) =>
                                        __field7,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("provider_url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field8 =
                                    match __field8 {
                                        _serde::export::Some(__field8) =>
                                        __field8,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("html")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field9 =
                                    match __field9 {
                                        _serde::export::Some(__field9) =>
                                        __field9,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("width")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field10 =
                                    match __field10 {
                                        _serde::export::Some(__field10) =>
                                        __field10,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("height")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Card{url: __field0,
                                                        title: __field1,
                                                        description: __field2,
                                                        image: __field3,
                                                        author_name: __field4,
                                                        author_url: __field5,
                                                        provider_name:
                                                            __field6,
                                                        provider_url:
                                                            __field7,
                                                        html: __field8,
                                                        width: __field9,
                                                        height: __field10,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["url", "title", "description", "image",
                              "author_name", "author_url", "provider_name",
                              "provider_url", "html", "width", "height"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Card",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Card>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Card { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Card {
            #[inline]
            fn eq(&self, other: &Card) -> bool {
                match *other {
                    Card {
                    url: ref __self_1_0,
                    title: ref __self_1_1,
                    description: ref __self_1_2,
                    image: ref __self_1_3,
                    author_name: ref __self_1_4,
                    author_url: ref __self_1_5,
                    provider_name: ref __self_1_6,
                    provider_url: ref __self_1_7,
                    html: ref __self_1_8,
                    width: ref __self_1_9,
                    height: ref __self_1_10 } =>
                    match *self {
                        Card {
                        url: ref __self_0_0,
                        title: ref __self_0_1,
                        description: ref __self_0_2,
                        image: ref __self_0_3,
                        author_name: ref __self_0_4,
                        author_url: ref __self_0_5,
                        provider_name: ref __self_0_6,
                        provider_url: ref __self_0_7,
                        html: ref __self_0_8,
                        width: ref __self_0_9,
                        height: ref __self_0_10 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5) &&
                            (*__self_0_6) == (*__self_1_6) &&
                            (*__self_0_7) == (*__self_1_7) &&
                            (*__self_0_8) == (*__self_1_8) &&
                            (*__self_0_9) == (*__self_1_9) &&
                            (*__self_0_10) == (*__self_1_10),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Card) -> bool {
                match *other {
                    Card {
                    url: ref __self_1_0,
                    title: ref __self_1_1,
                    description: ref __self_1_2,
                    image: ref __self_1_3,
                    author_name: ref __self_1_4,
                    author_url: ref __self_1_5,
                    provider_name: ref __self_1_6,
                    provider_url: ref __self_1_7,
                    html: ref __self_1_8,
                    width: ref __self_1_9,
                    height: ref __self_1_10 } =>
                    match *self {
                        Card {
                        url: ref __self_0_0,
                        title: ref __self_0_1,
                        description: ref __self_0_2,
                        image: ref __self_0_3,
                        author_name: ref __self_0_4,
                        author_url: ref __self_0_5,
                        provider_name: ref __self_0_6,
                        provider_url: ref __self_0_7,
                        html: ref __self_0_8,
                        width: ref __self_0_9,
                        height: ref __self_0_10 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5) ||
                            (*__self_0_6) != (*__self_1_6) ||
                            (*__self_0_7) != (*__self_1_7) ||
                            (*__self_0_8) != (*__self_1_8) ||
                            (*__self_0_9) != (*__self_1_9) ||
                            (*__self_0_10) != (*__self_1_10),
                    },
                }
            }
        }
    }
    /// Data structures for ser/de of contetx-related resources
    pub mod context {
        //! A module about contexts of statuses.
        use super::status::Status;
        /// A context of a status returning a list of statuses it replied to and
        /// statuses replied to it.
        pub struct Context {
            /// Statuses that were replied to.
            pub ancestors: Vec<Status>,
            /// Statuses that replied to this status.
            pub descendants: Vec<Status>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Context {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Context {
                    ancestors: ref __self_0_0, descendants: ref __self_0_1 }
                    => {
                        let mut debug_trait_builder =
                            f.debug_struct("Context");
                        let _ =
                            debug_trait_builder.field("ancestors",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("descendants",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Context {
            #[inline]
            fn clone(&self) -> Context {
                match *self {
                    Context {
                    ancestors: ref __self_0_0, descendants: ref __self_0_1 }
                    =>
                    Context{ancestors:
                                ::core::clone::Clone::clone(&(*__self_0_0)),
                            descendants:
                                ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Context: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Context {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field { __field0, __field1, __ignore, }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 2")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "ancestors" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "descendants" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"ancestors" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"descendants" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Context>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Context;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Context")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Status>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Context with 2 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Status>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Context with 2 elements"));
                                        }
                                    };
                                _serde::export::Ok(Context{ancestors:
                                                               __field0,
                                                           descendants:
                                                               __field1,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<Vec<Status>> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<Vec<Status>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("ancestors"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Status>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("descendants"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Status>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("ancestors")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("descendants")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Context{ancestors:
                                                               __field0,
                                                           descendants:
                                                               __field1,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["ancestors", "descendants"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Context",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Context>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Context { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Context {
            #[inline]
            fn eq(&self, other: &Context) -> bool {
                match *other {
                    Context {
                    ancestors: ref __self_1_0, descendants: ref __self_1_1 }
                    =>
                    match *self {
                        Context {
                        ancestors: ref __self_0_0, descendants: ref __self_0_1
                        } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Context) -> bool {
                match *other {
                    Context {
                    ancestors: ref __self_1_0, descendants: ref __self_1_1 }
                    =>
                    match *self {
                        Context {
                        ancestors: ref __self_0_0, descendants: ref __self_0_1
                        } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
    }
    /// Data structures for ser/de of streaming events
    pub mod event {
        use crate::entities::{notification::Notification, status::Status};
        /// Events that come from the /streaming/user API call
        pub enum Event {

            /// Update event
            Update(Status),

            /// Notification event
            Notification(Notification),

            /// Delete event
            Delete(String),

            /// FiltersChanged event
            FiltersChanged,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Event {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match (&*self,) {
                    (&Event::Update(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("Update");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&Event::Notification(ref __self_0),) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("Notification");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&Event::Delete(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("Delete");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&Event::FiltersChanged,) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("FiltersChanged");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Event {
            #[inline]
            fn clone(&self) -> Event {
                match (&*self,) {
                    (&Event::Update(ref __self_0),) =>
                    Event::Update(::core::clone::Clone::clone(&(*__self_0))),
                    (&Event::Notification(ref __self_0),) =>
                    Event::Notification(::core::clone::Clone::clone(&(*__self_0))),
                    (&Event::Delete(ref __self_0),) =>
                    Event::Delete(::core::clone::Clone::clone(&(*__self_0))),
                    (&Event::FiltersChanged,) => Event::FiltersChanged,
                }
            }
        }
    }
    /// Data structures for ser/de of filter-related resources
    pub mod filter {
        /// Represents a single Filter
        pub struct Filter {
            id: String,
            phrase: String,
            context: Vec<FilterContext>,
            expires_at: Option<String>,
            irreversible: bool,
            whole_word: bool,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Filter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Filter {
                    id: ref __self_0_0,
                    phrase: ref __self_0_1,
                    context: ref __self_0_2,
                    expires_at: ref __self_0_3,
                    irreversible: ref __self_0_4,
                    whole_word: ref __self_0_5 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Filter");
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("phrase",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("context",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("expires_at",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("irreversible",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("whole_word",
                                                      &&(*__self_0_5));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Filter {
            #[inline]
            fn clone(&self) -> Filter {
                match *self {
                    Filter {
                    id: ref __self_0_0,
                    phrase: ref __self_0_1,
                    context: ref __self_0_2,
                    expires_at: ref __self_0_3,
                    irreversible: ref __self_0_4,
                    whole_word: ref __self_0_5 } =>
                    Filter{id: ::core::clone::Clone::clone(&(*__self_0_0)),
                           phrase:
                               ::core::clone::Clone::clone(&(*__self_0_1)),
                           context:
                               ::core::clone::Clone::clone(&(*__self_0_2)),
                           expires_at:
                               ::core::clone::Clone::clone(&(*__self_0_3)),
                           irreversible:
                               ::core::clone::Clone::clone(&(*__self_0_4)),
                           whole_word:
                               ::core::clone::Clone::clone(&(*__self_0_5)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Filter { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Filter {
            #[inline]
            fn eq(&self, other: &Filter) -> bool {
                match *other {
                    Filter {
                    id: ref __self_1_0,
                    phrase: ref __self_1_1,
                    context: ref __self_1_2,
                    expires_at: ref __self_1_3,
                    irreversible: ref __self_1_4,
                    whole_word: ref __self_1_5 } =>
                    match *self {
                        Filter {
                        id: ref __self_0_0,
                        phrase: ref __self_0_1,
                        context: ref __self_0_2,
                        expires_at: ref __self_0_3,
                        irreversible: ref __self_0_4,
                        whole_word: ref __self_0_5 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Filter) -> bool {
                match *other {
                    Filter {
                    id: ref __self_1_0,
                    phrase: ref __self_1_1,
                    context: ref __self_1_2,
                    expires_at: ref __self_1_3,
                    irreversible: ref __self_1_4,
                    whole_word: ref __self_1_5 } =>
                    match *self {
                        Filter {
                        id: ref __self_0_0,
                        phrase: ref __self_0_1,
                        context: ref __self_0_2,
                        expires_at: ref __self_0_3,
                        irreversible: ref __self_0_4,
                        whole_word: ref __self_0_5 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_Filter: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl _serde::Serialize for Filter {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "Filter",
                                                                       false
                                                                           as
                                                                           usize
                                                                           + 1
                                                                           + 1
                                                                           + 1
                                                                           + 1
                                                                           + 1
                                                                           +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "id",
                                                                            &self.id)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "phrase",
                                                                            &self.phrase)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "context",
                                                                            &self.context)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "expires_at",
                                                                            &self.expires_at)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "irreversible",
                                                                            &self.irreversible)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "whole_word",
                                                                            &self.whole_word)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Filter: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Filter {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 6")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "phrase" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "context" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "expires_at" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "irreversible" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "whole_word" =>
                                    _serde::export::Ok(__Field::__field5),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"phrase" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"context" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"expires_at" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"irreversible" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"whole_word" =>
                                    _serde::export::Ok(__Field::__field5),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Filter>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Filter;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Filter")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Filter with 6 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Filter with 6 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<FilterContext>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Filter with 6 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Filter with 6 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct Filter with 6 elements"));
                                        }
                                    };
                                let __field5 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                         &"struct Filter with 6 elements"));
                                        }
                                    };
                                _serde::export::Ok(Filter{id: __field0,
                                                          phrase: __field1,
                                                          context: __field2,
                                                          expires_at:
                                                              __field3,
                                                          irreversible:
                                                              __field4,
                                                          whole_word:
                                                              __field5,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<Vec<FilterContext>> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field5:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("phrase"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("context"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<FilterContext>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("expires_at"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("irreversible"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field5 => {
                                            if _serde::export::Option::is_some(&__field5)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("whole_word"));
                                            }
                                            __field5 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("phrase")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("context")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("expires_at")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("irreversible")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::export::Some(__field5) =>
                                        __field5,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("whole_word")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Filter{id: __field0,
                                                          phrase: __field1,
                                                          context: __field2,
                                                          expires_at:
                                                              __field3,
                                                          irreversible:
                                                              __field4,
                                                          whole_word:
                                                              __field5,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["id", "phrase", "context", "expires_at",
                              "irreversible", "whole_word"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Filter",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Filter>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        /// Represents the various types of Filter contexts
        pub enum FilterContext {

            /// Represents the "home" context
            #[serde(rename = "home")]
            Home,

            /// Represents the "notifications" context
            #[serde(rename = "notifications")]
            Notifications,

            /// Represents the "public" context
            #[serde(rename = "public")]
            Public,

            /// Represents the "thread" context
            #[serde(rename = "thread")]
            Thread,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for FilterContext {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match (&*self,) {
                    (&FilterContext::Home,) => {
                        let mut debug_trait_builder = f.debug_tuple("Home");
                        debug_trait_builder.finish()
                    }
                    (&FilterContext::Notifications,) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("Notifications");
                        debug_trait_builder.finish()
                    }
                    (&FilterContext::Public,) => {
                        let mut debug_trait_builder = f.debug_tuple("Public");
                        debug_trait_builder.finish()
                    }
                    (&FilterContext::Thread,) => {
                        let mut debug_trait_builder = f.debug_tuple("Thread");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for FilterContext {
            #[inline]
            fn clone(&self) -> FilterContext { { *self } }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for FilterContext { }
        impl ::core::marker::StructuralPartialEq for FilterContext { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for FilterContext {
            #[inline]
            fn eq(&self, other: &FilterContext) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::core::intrinsics::discriminant_value(&*self)
                        };
                    let __arg_1_vi =
                        unsafe {
                            ::core::intrinsics::discriminant_value(&*other)
                        };
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) { _ => true, }
                    } else { false }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_FilterContext: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl _serde::Serialize for FilterContext {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        match *self {
                            FilterContext::Home =>
                            _serde::Serializer::serialize_unit_variant(__serializer,
                                                                       "FilterContext",
                                                                       0u32,
                                                                       "home"),
                            FilterContext::Notifications =>
                            _serde::Serializer::serialize_unit_variant(__serializer,
                                                                       "FilterContext",
                                                                       1u32,
                                                                       "notifications"),
                            FilterContext::Public =>
                            _serde::Serializer::serialize_unit_variant(__serializer,
                                                                       "FilterContext",
                                                                       2u32,
                                                                       "public"),
                            FilterContext::Thread =>
                            _serde::Serializer::serialize_unit_variant(__serializer,
                                                                       "FilterContext",
                                                                       3u32,
                                                                       "thread"),
                        }
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_FilterContext: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for FilterContext {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"variant index 0 <= i < 4")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "home" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "notifications" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "public" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "thread" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"home" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"notifications" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"public" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"thread" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        let __value =
                                            &_serde::export::from_utf8_lossy(__value);
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<FilterContext>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = FilterContext;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "enum FilterContext")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::EnumAccess<'de> {
                                match match _serde::de::EnumAccess::variant(__data)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    (__Field::__field0, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(FilterContext::Home)
                                    }
                                    (__Field::__field1, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(FilterContext::Notifications)
                                    }
                                    (__Field::__field2, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(FilterContext::Public)
                                    }
                                    (__Field::__field3, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(FilterContext::Thread)
                                    }
                                }
                            }
                        }
                        const VARIANTS: &'static [&'static str] =
                            &["home", "notifications", "public", "thread"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                                                               "FilterContext",
                                                               VARIANTS,
                                                               __Visitor{marker:
                                                                             _serde::export::PhantomData::<FilterContext>,
                                                                         lifetime:
                                                                             _serde::export::PhantomData,})
                    }
                }
            };
    }
    /// Data structures for ser/de of instance-related resources
    pub mod instance {
        //! Module containing everything related to an instance.
        use super::account::Account;
        /// A struct containing info of an instance.
        pub struct Instance {
            /// URI of the current instance
            pub uri: String,
            /// The instance's title.
            pub title: String,
            /// A description for the instance.
            pub description: String,
            /// An email address which can be used to contact the
            /// instance administrator.
            pub email: String,
            /// The Mastodon version used by instance.
            pub version: String,
            /// Urls to the streaming api.
            pub urls: Option<StreamingApi>,
            /// Stats about the instance.
            pub stats: Option<Stats>,
            /// Thumbnail of the server image.
            pub thumbnail: Option<String>,
            /// List of languages used on the server.
            pub languages: Option<Vec<String>>,
            /// Contact account for the server.
            pub contact_account: Option<Account>,
            /// The maximum number of characters allowed in a status
            pub max_toot_chars: Option<u32>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Instance {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Instance {
                    uri: ref __self_0_0,
                    title: ref __self_0_1,
                    description: ref __self_0_2,
                    email: ref __self_0_3,
                    version: ref __self_0_4,
                    urls: ref __self_0_5,
                    stats: ref __self_0_6,
                    thumbnail: ref __self_0_7,
                    languages: ref __self_0_8,
                    contact_account: ref __self_0_9,
                    max_toot_chars: ref __self_0_10 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Instance");
                        let _ =
                            debug_trait_builder.field("uri", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("title",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("description",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("email",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("version",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("urls",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("stats",
                                                      &&(*__self_0_6));
                        let _ =
                            debug_trait_builder.field("thumbnail",
                                                      &&(*__self_0_7));
                        let _ =
                            debug_trait_builder.field("languages",
                                                      &&(*__self_0_8));
                        let _ =
                            debug_trait_builder.field("contact_account",
                                                      &&(*__self_0_9));
                        let _ =
                            debug_trait_builder.field("max_toot_chars",
                                                      &&(*__self_0_10));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Instance {
            #[inline]
            fn clone(&self) -> Instance {
                match *self {
                    Instance {
                    uri: ref __self_0_0,
                    title: ref __self_0_1,
                    description: ref __self_0_2,
                    email: ref __self_0_3,
                    version: ref __self_0_4,
                    urls: ref __self_0_5,
                    stats: ref __self_0_6,
                    thumbnail: ref __self_0_7,
                    languages: ref __self_0_8,
                    contact_account: ref __self_0_9,
                    max_toot_chars: ref __self_0_10 } =>
                    Instance{uri: ::core::clone::Clone::clone(&(*__self_0_0)),
                             title:
                                 ::core::clone::Clone::clone(&(*__self_0_1)),
                             description:
                                 ::core::clone::Clone::clone(&(*__self_0_2)),
                             email:
                                 ::core::clone::Clone::clone(&(*__self_0_3)),
                             version:
                                 ::core::clone::Clone::clone(&(*__self_0_4)),
                             urls:
                                 ::core::clone::Clone::clone(&(*__self_0_5)),
                             stats:
                                 ::core::clone::Clone::clone(&(*__self_0_6)),
                             thumbnail:
                                 ::core::clone::Clone::clone(&(*__self_0_7)),
                             languages:
                                 ::core::clone::Clone::clone(&(*__self_0_8)),
                             contact_account:
                                 ::core::clone::Clone::clone(&(*__self_0_9)),
                             max_toot_chars:
                                 ::core::clone::Clone::clone(&(*__self_0_10)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Instance: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Instance {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    6u64 =>
                                    _serde::export::Ok(__Field::__field6),
                                    7u64 =>
                                    _serde::export::Ok(__Field::__field7),
                                    8u64 =>
                                    _serde::export::Ok(__Field::__field8),
                                    9u64 =>
                                    _serde::export::Ok(__Field::__field9),
                                    10u64 =>
                                    _serde::export::Ok(__Field::__field10),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 11")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "uri" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "title" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "description" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "email" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "version" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "urls" =>
                                    _serde::export::Ok(__Field::__field5),
                                    "stats" =>
                                    _serde::export::Ok(__Field::__field6),
                                    "thumbnail" =>
                                    _serde::export::Ok(__Field::__field7),
                                    "languages" =>
                                    _serde::export::Ok(__Field::__field8),
                                    "contact_account" =>
                                    _serde::export::Ok(__Field::__field9),
                                    "max_toot_chars" =>
                                    _serde::export::Ok(__Field::__field10),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"uri" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"title" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"description" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"email" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"version" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"urls" =>
                                    _serde::export::Ok(__Field::__field5),
                                    b"stats" =>
                                    _serde::export::Ok(__Field::__field6),
                                    b"thumbnail" =>
                                    _serde::export::Ok(__Field::__field7),
                                    b"languages" =>
                                    _serde::export::Ok(__Field::__field8),
                                    b"contact_account" =>
                                    _serde::export::Ok(__Field::__field9),
                                    b"max_toot_chars" =>
                                    _serde::export::Ok(__Field::__field10),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Instance>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Instance;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Instance")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field5 =
                                    match match _serde::de::SeqAccess::next_element::<Option<StreamingApi>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field6 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Stats>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field7 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(7usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field8 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Vec<String>>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(8usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field9 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Account>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(9usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                let __field10 =
                                    match match _serde::de::SeqAccess::next_element::<Option<u32>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(10usize,
                                                                                                         &"struct Instance with 11 elements"));
                                        }
                                    };
                                _serde::export::Ok(Instance{uri: __field0,
                                                            title: __field1,
                                                            description:
                                                                __field2,
                                                            email: __field3,
                                                            version: __field4,
                                                            urls: __field5,
                                                            stats: __field6,
                                                            thumbnail:
                                                                __field7,
                                                            languages:
                                                                __field8,
                                                            contact_account:
                                                                __field9,
                                                            max_toot_chars:
                                                                __field10,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field5:
                                        _serde::export::Option<Option<StreamingApi>> =
                                    _serde::export::None;
                                let mut __field6:
                                        _serde::export::Option<Option<Stats>> =
                                    _serde::export::None;
                                let mut __field7:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field8:
                                        _serde::export::Option<Option<Vec<String>>> =
                                    _serde::export::None;
                                let mut __field9:
                                        _serde::export::Option<Option<Account>> =
                                    _serde::export::None;
                                let mut __field10:
                                        _serde::export::Option<Option<u32>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("uri"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("title"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("description"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("email"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("version"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field5 => {
                                            if _serde::export::Option::is_some(&__field5)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("urls"));
                                            }
                                            __field5 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StreamingApi>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field6 => {
                                            if _serde::export::Option::is_some(&__field6)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("stats"));
                                            }
                                            __field6 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Stats>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field7 => {
                                            if _serde::export::Option::is_some(&__field7)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("thumbnail"));
                                            }
                                            __field7 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field8 => {
                                            if _serde::export::Option::is_some(&__field8)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("languages"));
                                            }
                                            __field8 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Vec<String>>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field9 => {
                                            if _serde::export::Option::is_some(&__field9)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("contact_account"));
                                            }
                                            __field9 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Account>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field10 => {
                                            if _serde::export::Option::is_some(&__field10)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("max_toot_chars"));
                                            }
                                            __field10 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<u32>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("uri")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("title")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("description")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("email")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("version")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::export::Some(__field5) =>
                                        __field5,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("urls")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field6 =
                                    match __field6 {
                                        _serde::export::Some(__field6) =>
                                        __field6,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("stats")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field7 =
                                    match __field7 {
                                        _serde::export::Some(__field7) =>
                                        __field7,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("thumbnail")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field8 =
                                    match __field8 {
                                        _serde::export::Some(__field8) =>
                                        __field8,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("languages")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field9 =
                                    match __field9 {
                                        _serde::export::Some(__field9) =>
                                        __field9,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("contact_account")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field10 =
                                    match __field10 {
                                        _serde::export::Some(__field10) =>
                                        __field10,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("max_toot_chars")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Instance{uri: __field0,
                                                            title: __field1,
                                                            description:
                                                                __field2,
                                                            email: __field3,
                                                            version: __field4,
                                                            urls: __field5,
                                                            stats: __field6,
                                                            thumbnail:
                                                                __field7,
                                                            languages:
                                                                __field8,
                                                            contact_account:
                                                                __field9,
                                                            max_toot_chars:
                                                                __field10,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["uri", "title", "description", "email",
                              "version", "urls", "stats", "thumbnail",
                              "languages", "contact_account",
                              "max_toot_chars"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Instance",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Instance>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Instance { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Instance {
            #[inline]
            fn eq(&self, other: &Instance) -> bool {
                match *other {
                    Instance {
                    uri: ref __self_1_0,
                    title: ref __self_1_1,
                    description: ref __self_1_2,
                    email: ref __self_1_3,
                    version: ref __self_1_4,
                    urls: ref __self_1_5,
                    stats: ref __self_1_6,
                    thumbnail: ref __self_1_7,
                    languages: ref __self_1_8,
                    contact_account: ref __self_1_9,
                    max_toot_chars: ref __self_1_10 } =>
                    match *self {
                        Instance {
                        uri: ref __self_0_0,
                        title: ref __self_0_1,
                        description: ref __self_0_2,
                        email: ref __self_0_3,
                        version: ref __self_0_4,
                        urls: ref __self_0_5,
                        stats: ref __self_0_6,
                        thumbnail: ref __self_0_7,
                        languages: ref __self_0_8,
                        contact_account: ref __self_0_9,
                        max_toot_chars: ref __self_0_10 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5) &&
                            (*__self_0_6) == (*__self_1_6) &&
                            (*__self_0_7) == (*__self_1_7) &&
                            (*__self_0_8) == (*__self_1_8) &&
                            (*__self_0_9) == (*__self_1_9) &&
                            (*__self_0_10) == (*__self_1_10),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Instance) -> bool {
                match *other {
                    Instance {
                    uri: ref __self_1_0,
                    title: ref __self_1_1,
                    description: ref __self_1_2,
                    email: ref __self_1_3,
                    version: ref __self_1_4,
                    urls: ref __self_1_5,
                    stats: ref __self_1_6,
                    thumbnail: ref __self_1_7,
                    languages: ref __self_1_8,
                    contact_account: ref __self_1_9,
                    max_toot_chars: ref __self_1_10 } =>
                    match *self {
                        Instance {
                        uri: ref __self_0_0,
                        title: ref __self_0_1,
                        description: ref __self_0_2,
                        email: ref __self_0_3,
                        version: ref __self_0_4,
                        urls: ref __self_0_5,
                        stats: ref __self_0_6,
                        thumbnail: ref __self_0_7,
                        languages: ref __self_0_8,
                        contact_account: ref __self_0_9,
                        max_toot_chars: ref __self_0_10 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5) ||
                            (*__self_0_6) != (*__self_1_6) ||
                            (*__self_0_7) != (*__self_1_7) ||
                            (*__self_0_8) != (*__self_1_8) ||
                            (*__self_0_9) != (*__self_1_9) ||
                            (*__self_0_10) != (*__self_1_10),
                    },
                }
            }
        }
        /// Object containing url for streaming api.
        pub struct StreamingApi {
            /// Url for streaming API, typically a `wss://` url.
            pub streaming_api: String,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StreamingApi {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    StreamingApi { streaming_api: ref __self_0_0 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("StreamingApi");
                        let _ =
                            debug_trait_builder.field("streaming_api",
                                                      &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StreamingApi {
            #[inline]
            fn clone(&self) -> StreamingApi {
                match *self {
                    StreamingApi { streaming_api: ref __self_0_0 } =>
                    StreamingApi{streaming_api:
                                     ::core::clone::Clone::clone(&(*__self_0_0)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_StreamingApi: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for StreamingApi {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field { __field0, __ignore, }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 1")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "streaming_api" =>
                                    _serde::export::Ok(__Field::__field0),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"streaming_api" =>
                                    _serde::export::Ok(__Field::__field0),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<StreamingApi>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = StreamingApi;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct StreamingApi")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct StreamingApi with 1 element"));
                                        }
                                    };
                                _serde::export::Ok(StreamingApi{streaming_api:
                                                                    __field0,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("streaming_api"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("streaming_api")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(StreamingApi{streaming_api:
                                                                    __field0,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["streaming_api"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "StreamingApi",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<StreamingApi>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for StreamingApi { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StreamingApi {
            #[inline]
            fn eq(&self, other: &StreamingApi) -> bool {
                match *other {
                    StreamingApi { streaming_api: ref __self_1_0 } =>
                    match *self {
                        StreamingApi { streaming_api: ref __self_0_0 } =>
                        (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &StreamingApi) -> bool {
                match *other {
                    StreamingApi { streaming_api: ref __self_1_0 } =>
                    match *self {
                        StreamingApi { streaming_api: ref __self_0_0 } =>
                        (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        /// Statistics about the Mastodon instance.
        pub struct Stats {
            user_count: u64,
            status_count: u64,
            domain_count: u64,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Stats {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Stats {
                    user_count: ref __self_0_0,
                    status_count: ref __self_0_1,
                    domain_count: ref __self_0_2 } => {
                        let mut debug_trait_builder = f.debug_struct("Stats");
                        let _ =
                            debug_trait_builder.field("user_count",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("status_count",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("domain_count",
                                                      &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Stats {
            #[inline]
            fn clone(&self) -> Stats {
                {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Stats { }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Stats: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Stats {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 3")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "user_count" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "status_count" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "domain_count" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"user_count" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"status_count" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"domain_count" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Stats>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Stats;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Stats")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Stats with 3 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Stats with 3 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Stats with 3 elements"));
                                        }
                                    };
                                _serde::export::Ok(Stats{user_count: __field0,
                                                         status_count:
                                                             __field1,
                                                         domain_count:
                                                             __field2,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("user_count"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("status_count"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("domain_count"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("user_count")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("status_count")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("domain_count")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Stats{user_count: __field0,
                                                         status_count:
                                                             __field1,
                                                         domain_count:
                                                             __field2,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["user_count", "status_count", "domain_count"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Stats",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Stats>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Stats { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Stats {
            #[inline]
            fn eq(&self, other: &Stats) -> bool {
                match *other {
                    Stats {
                    user_count: ref __self_1_0,
                    status_count: ref __self_1_1,
                    domain_count: ref __self_1_2 } =>
                    match *self {
                        Stats {
                        user_count: ref __self_0_0,
                        status_count: ref __self_0_1,
                        domain_count: ref __self_0_2 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Stats) -> bool {
                match *other {
                    Stats {
                    user_count: ref __self_1_0,
                    status_count: ref __self_1_1,
                    domain_count: ref __self_1_2 } =>
                    match *self {
                        Stats {
                        user_count: ref __self_0_0,
                        status_count: ref __self_0_1,
                        domain_count: ref __self_0_2 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2),
                    },
                }
            }
        }
    }
    /// Data structures for ser/de of list-related resources
    pub mod list {
        /// Used for ser/de of list resources
        pub struct List {
            id: String,
            title: String,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for List {
            #[inline]
            fn clone(&self) -> List {
                match *self {
                    List { id: ref __self_0_0, title: ref __self_0_1 } =>
                    List{id: ::core::clone::Clone::clone(&(*__self_0_0)),
                         title: ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for List {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    List { id: ref __self_0_0, title: ref __self_0_1 } => {
                        let mut debug_trait_builder = f.debug_struct("List");
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("title",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_List: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for List {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field { __field0, __field1, __ignore, }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 2")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "title" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"title" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<List>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = List;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct List")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct List with 2 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct List with 2 elements"));
                                        }
                                    };
                                _serde::export::Ok(List{id: __field0,
                                                        title: __field1,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("title"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("title")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(List{id: __field0,
                                                        title: __field1,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["id", "title"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "List",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<List>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for List { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for List {
            #[inline]
            fn eq(&self, other: &List) -> bool {
                match *other {
                    List { id: ref __self_1_0, title: ref __self_1_1 } =>
                    match *self {
                        List { id: ref __self_0_0, title: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &List) -> bool {
                match *other {
                    List { id: ref __self_1_0, title: ref __self_1_1 } =>
                    match *self {
                        List { id: ref __self_0_0, title: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
    }
    /// Data structures for ser/de of mention-related resources
    pub mod mention {
        /// Represents a `mention` used in a status
        pub struct Mention {
            /// URL of user's profile (can be remote)
            pub url: String,
            /// The username of the account
            pub username: String,
            /// Equals username for local users, includes `@domain` for remote ones
            pub acct: String,
            /// Account ID
            pub id: String,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Mention {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Mention {
                    url: ref __self_0_0,
                    username: ref __self_0_1,
                    acct: ref __self_0_2,
                    id: ref __self_0_3 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Mention");
                        let _ =
                            debug_trait_builder.field("url", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("username",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("acct",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Mention {
            #[inline]
            fn clone(&self) -> Mention {
                match *self {
                    Mention {
                    url: ref __self_0_0,
                    username: ref __self_0_1,
                    acct: ref __self_0_2,
                    id: ref __self_0_3 } =>
                    Mention{url: ::core::clone::Clone::clone(&(*__self_0_0)),
                            username:
                                ::core::clone::Clone::clone(&(*__self_0_1)),
                            acct: ::core::clone::Clone::clone(&(*__self_0_2)),
                            id: ::core::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Mention { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Mention {
            #[inline]
            fn eq(&self, other: &Mention) -> bool {
                match *other {
                    Mention {
                    url: ref __self_1_0,
                    username: ref __self_1_1,
                    acct: ref __self_1_2,
                    id: ref __self_1_3 } =>
                    match *self {
                        Mention {
                        url: ref __self_0_0,
                        username: ref __self_0_1,
                        acct: ref __self_0_2,
                        id: ref __self_0_3 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Mention) -> bool {
                match *other {
                    Mention {
                    url: ref __self_1_0,
                    username: ref __self_1_1,
                    acct: ref __self_1_2,
                    id: ref __self_1_3 } =>
                    match *self {
                        Mention {
                        url: ref __self_0_0,
                        username: ref __self_0_1,
                        acct: ref __self_0_2,
                        id: ref __self_0_3 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3),
                    },
                }
            }
        }
    }
    /// Data structures for ser/de of notification-related resources
    pub mod notification {
        //! Module containing all info about notifications.
        use super::{account::Account, status::Status};
        use chrono::prelude::*;
        /// A struct containing info about a notification.
        pub struct Notification {
            /// The notification ID.
            pub id: String,
            /// The type of notification.
            #[serde(rename = "type")]
            pub notification_type: NotificationType,
            /// The time the notification was created.
            pub created_at: DateTime<Utc>,
            /// The Account sending the notification to the user.
            pub account: Account,
            /// The Status associated with the notification, if applicable.
            pub status: Option<Status>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Notification {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Notification {
                    id: ref __self_0_0,
                    notification_type: ref __self_0_1,
                    created_at: ref __self_0_2,
                    account: ref __self_0_3,
                    status: ref __self_0_4 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Notification");
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("notification_type",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("created_at",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("account",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("status",
                                                      &&(*__self_0_4));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Notification {
            #[inline]
            fn clone(&self) -> Notification {
                match *self {
                    Notification {
                    id: ref __self_0_0,
                    notification_type: ref __self_0_1,
                    created_at: ref __self_0_2,
                    account: ref __self_0_3,
                    status: ref __self_0_4 } =>
                    Notification{id:
                                     ::core::clone::Clone::clone(&(*__self_0_0)),
                                 notification_type:
                                     ::core::clone::Clone::clone(&(*__self_0_1)),
                                 created_at:
                                     ::core::clone::Clone::clone(&(*__self_0_2)),
                                 account:
                                     ::core::clone::Clone::clone(&(*__self_0_3)),
                                 status:
                                     ::core::clone::Clone::clone(&(*__self_0_4)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Notification: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Notification {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 5")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "type" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "created_at" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "account" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "status" =>
                                    _serde::export::Ok(__Field::__field4),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"type" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"created_at" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"account" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"status" =>
                                    _serde::export::Ok(__Field::__field4),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Notification>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Notification;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Notification")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Notification with 5 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<NotificationType>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Notification with 5 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<DateTime<Utc>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Notification with 5 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Account>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Notification with 5 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Status>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct Notification with 5 elements"));
                                        }
                                    };
                                _serde::export::Ok(Notification{id: __field0,
                                                                notification_type:
                                                                    __field1,
                                                                created_at:
                                                                    __field2,
                                                                account:
                                                                    __field3,
                                                                status:
                                                                    __field4,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<NotificationType> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<DateTime<Utc>> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Account> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<Option<Status>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("type"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<NotificationType>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("created_at"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<DateTime<Utc>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("account"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Account>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("status"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Status>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("type")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("created_at")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("account")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("status")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Notification{id: __field0,
                                                                notification_type:
                                                                    __field1,
                                                                created_at:
                                                                    __field2,
                                                                account:
                                                                    __field3,
                                                                status:
                                                                    __field4,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["id", "type", "created_at", "account",
                              "status"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Notification",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Notification>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Notification { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Notification {
            #[inline]
            fn eq(&self, other: &Notification) -> bool {
                match *other {
                    Notification {
                    id: ref __self_1_0,
                    notification_type: ref __self_1_1,
                    created_at: ref __self_1_2,
                    account: ref __self_1_3,
                    status: ref __self_1_4 } =>
                    match *self {
                        Notification {
                        id: ref __self_0_0,
                        notification_type: ref __self_0_1,
                        created_at: ref __self_0_2,
                        account: ref __self_0_3,
                        status: ref __self_0_4 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Notification) -> bool {
                match *other {
                    Notification {
                    id: ref __self_1_0,
                    notification_type: ref __self_1_1,
                    created_at: ref __self_1_2,
                    account: ref __self_1_3,
                    status: ref __self_1_4 } =>
                    match *self {
                        Notification {
                        id: ref __self_0_0,
                        notification_type: ref __self_0_1,
                        created_at: ref __self_0_2,
                        account: ref __self_0_3,
                        status: ref __self_0_4 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4),
                    },
                }
            }
        }
        /// The type of notification.
        #[serde(rename_all = "lowercase")]
        pub enum NotificationType {

            /// Someone mentioned the application client in another status.
            Mention,

            /// Someone reblogged one of the application client's statuses.
            Reblog,

            /// Someone favourited one of the application client's statuses.
            Favourite,

            /// Someone followed the application client.
            Follow,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for NotificationType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match (&*self,) {
                    (&NotificationType::Mention,) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("Mention");
                        debug_trait_builder.finish()
                    }
                    (&NotificationType::Reblog,) => {
                        let mut debug_trait_builder = f.debug_tuple("Reblog");
                        debug_trait_builder.finish()
                    }
                    (&NotificationType::Favourite,) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("Favourite");
                        debug_trait_builder.finish()
                    }
                    (&NotificationType::Follow,) => {
                        let mut debug_trait_builder = f.debug_tuple("Follow");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for NotificationType {
            #[inline]
            fn clone(&self) -> NotificationType { { *self } }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for NotificationType { }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_NotificationType: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for NotificationType {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"variant index 0 <= i < 4")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "mention" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "reblog" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "favourite" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "follow" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"mention" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"reblog" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"favourite" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"follow" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        let __value =
                                            &_serde::export::from_utf8_lossy(__value);
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<NotificationType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = NotificationType;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "enum NotificationType")
                            }
                            fn visit_enum<__A>(self, __data: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::EnumAccess<'de> {
                                match match _serde::de::EnumAccess::variant(__data)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    (__Field::__field0, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(NotificationType::Mention)
                                    }
                                    (__Field::__field1, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(NotificationType::Reblog)
                                    }
                                    (__Field::__field2, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(NotificationType::Favourite)
                                    }
                                    (__Field::__field3, __variant) => {
                                        match _serde::de::VariantAccess::unit_variant(__variant)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                        _serde::export::Ok(NotificationType::Follow)
                                    }
                                }
                            }
                        }
                        const VARIANTS: &'static [&'static str] =
                            &["mention", "reblog", "favourite", "follow"];
                        _serde::Deserializer::deserialize_enum(__deserializer,
                                                               "NotificationType",
                                                               VARIANTS,
                                                               __Visitor{marker:
                                                                             _serde::export::PhantomData::<NotificationType>,
                                                                         lifetime:
                                                                             _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for NotificationType { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for NotificationType {
            #[inline]
            fn eq(&self, other: &NotificationType) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::core::intrinsics::discriminant_value(&*self)
                        };
                    let __arg_1_vi =
                        unsafe {
                            ::core::intrinsics::discriminant_value(&*other)
                        };
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) { _ => true, }
                    } else { false }
                }
            }
        }
    }
    /// Data structures for ser/de of push-subscription-related resources
    pub mod push {
        /// Represents the `alerts` key of the `Subscription` object
        pub struct Alerts {
            /// flag for follow alerts
            pub follow: Option<bool>,
            /// flag for favourite alerts
            pub favourite: Option<bool>,
            /// flag for reblog alerts
            pub reblog: Option<bool>,
            /// flag for mention alerts
            pub mention: Option<bool>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Alerts {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Alerts {
                    follow: ref __self_0_0,
                    favourite: ref __self_0_1,
                    reblog: ref __self_0_2,
                    mention: ref __self_0_3 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Alerts");
                        let _ =
                            debug_trait_builder.field("follow",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("favourite",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("reblog",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("mention",
                                                      &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Alerts {
            #[inline]
            fn clone(&self) -> Alerts {
                {
                    let _: ::core::clone::AssertParamIsClone<Option<bool>>;
                    let _: ::core::clone::AssertParamIsClone<Option<bool>>;
                    let _: ::core::clone::AssertParamIsClone<Option<bool>>;
                    let _: ::core::clone::AssertParamIsClone<Option<bool>>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Alerts { }
        impl ::core::marker::StructuralPartialEq for Alerts { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Alerts {
            #[inline]
            fn eq(&self, other: &Alerts) -> bool {
                match *other {
                    Alerts {
                    follow: ref __self_1_0,
                    favourite: ref __self_1_1,
                    reblog: ref __self_1_2,
                    mention: ref __self_1_3 } =>
                    match *self {
                        Alerts {
                        follow: ref __self_0_0,
                        favourite: ref __self_0_1,
                        reblog: ref __self_0_2,
                        mention: ref __self_0_3 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Alerts) -> bool {
                match *other {
                    Alerts {
                    follow: ref __self_1_0,
                    favourite: ref __self_1_1,
                    reblog: ref __self_1_2,
                    mention: ref __self_1_3 } =>
                    match *self {
                        Alerts {
                        follow: ref __self_0_0,
                        favourite: ref __self_0_1,
                        reblog: ref __self_0_2,
                        mention: ref __self_0_3 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_Alerts: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl _serde::Serialize for Alerts {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "Alerts",
                                                                       false
                                                                           as
                                                                           usize
                                                                           + 1
                                                                           + 1
                                                                           + 1
                                                                           +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "follow",
                                                                            &self.follow)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "favourite",
                                                                            &self.favourite)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "reblog",
                                                                            &self.reblog)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "mention",
                                                                            &self.mention)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Alerts: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Alerts {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 4")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "follow" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "favourite" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "reblog" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "mention" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"follow" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"favourite" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"reblog" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"mention" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Alerts>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Alerts;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Alerts")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Alerts with 4 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Alerts with 4 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Alerts with 4 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Alerts with 4 elements"));
                                        }
                                    };
                                _serde::export::Ok(Alerts{follow: __field0,
                                                          favourite: __field1,
                                                          reblog: __field2,
                                                          mention: __field3,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<Option<bool>> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<Option<bool>> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<Option<bool>> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Option<bool>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("follow"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("favourite"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("reblog"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("mention"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("follow")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("favourite")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("reblog")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("mention")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Alerts{follow: __field0,
                                                          favourite: __field1,
                                                          reblog: __field2,
                                                          mention: __field3,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["follow", "favourite", "reblog", "mention"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Alerts",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Alerts>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for Alerts {
            #[inline]
            fn default() -> Alerts {
                Alerts{follow: ::core::default::Default::default(),
                       favourite: ::core::default::Default::default(),
                       reblog: ::core::default::Default::default(),
                       mention: ::core::default::Default::default(),}
            }
        }
        /// Represents a new Push subscription
        pub struct Subscription {
            /// The `id` of the subscription
            pub id: String,
            /// The endpoint of the subscription
            pub endpoint: String,
            /// The server key of the subscription
            pub server_key: String,
            /// The status of the alerts for this subscription
            pub alerts: Option<Alerts>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Subscription {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Subscription {
                    id: ref __self_0_0,
                    endpoint: ref __self_0_1,
                    server_key: ref __self_0_2,
                    alerts: ref __self_0_3 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Subscription");
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("endpoint",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("server_key",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("alerts",
                                                      &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Subscription {
            #[inline]
            fn clone(&self) -> Subscription {
                match *self {
                    Subscription {
                    id: ref __self_0_0,
                    endpoint: ref __self_0_1,
                    server_key: ref __self_0_2,
                    alerts: ref __self_0_3 } =>
                    Subscription{id:
                                     ::core::clone::Clone::clone(&(*__self_0_0)),
                                 endpoint:
                                     ::core::clone::Clone::clone(&(*__self_0_1)),
                                 server_key:
                                     ::core::clone::Clone::clone(&(*__self_0_2)),
                                 alerts:
                                     ::core::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Subscription { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Subscription {
            #[inline]
            fn eq(&self, other: &Subscription) -> bool {
                match *other {
                    Subscription {
                    id: ref __self_1_0,
                    endpoint: ref __self_1_1,
                    server_key: ref __self_1_2,
                    alerts: ref __self_1_3 } =>
                    match *self {
                        Subscription {
                        id: ref __self_0_0,
                        endpoint: ref __self_0_1,
                        server_key: ref __self_0_2,
                        alerts: ref __self_0_3 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Subscription) -> bool {
                match *other {
                    Subscription {
                    id: ref __self_1_0,
                    endpoint: ref __self_1_1,
                    server_key: ref __self_1_2,
                    alerts: ref __self_1_3 } =>
                    match *self {
                        Subscription {
                        id: ref __self_0_0,
                        endpoint: ref __self_0_1,
                        server_key: ref __self_0_2,
                        alerts: ref __self_0_3 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Subscription: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Subscription {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 4")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "endpoint" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "server_key" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "alerts" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"endpoint" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"server_key" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"alerts" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Subscription>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Subscription;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Subscription")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Subscription with 4 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Subscription with 4 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Subscription with 4 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Alerts>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Subscription with 4 elements"));
                                        }
                                    };
                                _serde::export::Ok(Subscription{id: __field0,
                                                                endpoint:
                                                                    __field1,
                                                                server_key:
                                                                    __field2,
                                                                alerts:
                                                                    __field3,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Option<Alerts>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("endpoint"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("server_key"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("alerts"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Alerts>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("endpoint")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("server_key")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("alerts")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Subscription{id: __field0,
                                                                endpoint:
                                                                    __field1,
                                                                server_key:
                                                                    __field2,
                                                                alerts:
                                                                    __field3,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["id", "endpoint", "server_key", "alerts"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Subscription",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Subscription>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        pub(crate) mod add_subscription {
            use super::Alerts;
            pub(crate) struct Form {
                pub(crate) subscription: Subscription,
                pub(crate) data: Option<Data>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for Form {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                 -> ::core::fmt::Result {
                    match *self {
                        Form {
                        subscription: ref __self_0_0, data: ref __self_0_1 }
                        => {
                            let mut debug_trait_builder =
                                f.debug_struct("Form");
                            let _ =
                                debug_trait_builder.field("subscription",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("data",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::clone::Clone for Form {
                #[inline]
                fn clone(&self) -> Form {
                    match *self {
                        Form {
                        subscription: ref __self_0_0, data: ref __self_0_1 }
                        =>
                        Form{subscription:
                                 ::core::clone::Clone::clone(&(*__self_0_0)),
                             data:
                                 ::core::clone::Clone::clone(&(*__self_0_1)),},
                    }
                }
            }
            impl ::core::marker::StructuralPartialEq for Form { }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::cmp::PartialEq for Form {
                #[inline]
                fn eq(&self, other: &Form) -> bool {
                    match *other {
                        Form {
                        subscription: ref __self_1_0, data: ref __self_1_1 }
                        =>
                        match *self {
                            Form {
                            subscription: ref __self_0_0, data: ref __self_0_1
                            } =>
                            (*__self_0_0) == (*__self_1_0) &&
                                (*__self_0_1) == (*__self_1_1),
                        },
                    }
                }
                #[inline]
                fn ne(&self, other: &Form) -> bool {
                    match *other {
                        Form {
                        subscription: ref __self_1_0, data: ref __self_1_1 }
                        =>
                        match *self {
                            Form {
                            subscription: ref __self_0_0, data: ref __self_0_1
                            } =>
                            (*__self_0_0) != (*__self_1_0) ||
                                (*__self_0_1) != (*__self_1_1),
                        },
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes,
                    unused_qualifications)]
            const _IMPL_SERIALIZE_FOR_Form: () =
                {
                    #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try {
                        ($ __expr : expr) =>
                        {
                            match $ __expr
                            {
                                _serde :: export :: Ok(__val) => __val, _serde
                                :: export :: Err(__err) =>
                                { return _serde :: export :: Err(__err) ; }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl _serde::Serialize for Form {
                        fn serialize<__S>(&self, __serializer: __S)
                         -> _serde::export::Result<__S::Ok, __S::Error> where
                         __S: _serde::Serializer {
                            let mut __serde_state =
                                match _serde::Serializer::serialize_struct(__serializer,
                                                                           "Form",
                                                                           false
                                                                               as
                                                                               usize
                                                                               +
                                                                               1
                                                                               +
                                                                               1)
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "subscription",
                                                                                &self.subscription)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "data",
                                                                                &self.data)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::default::Default for Form {
                #[inline]
                fn default() -> Form {
                    Form{subscription: ::core::default::Default::default(),
                         data: ::core::default::Default::default(),}
                }
            }
            pub(crate) struct Subscription {
                pub(crate) endpoint: String,
                pub(crate) keys: Keys,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for Subscription {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                 -> ::core::fmt::Result {
                    match *self {
                        Subscription {
                        endpoint: ref __self_0_0, keys: ref __self_0_1 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("Subscription");
                            let _ =
                                debug_trait_builder.field("endpoint",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("keys",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::clone::Clone for Subscription {
                #[inline]
                fn clone(&self) -> Subscription {
                    match *self {
                        Subscription {
                        endpoint: ref __self_0_0, keys: ref __self_0_1 } =>
                        Subscription{endpoint:
                                         ::core::clone::Clone::clone(&(*__self_0_0)),
                                     keys:
                                         ::core::clone::Clone::clone(&(*__self_0_1)),},
                    }
                }
            }
            impl ::core::marker::StructuralPartialEq for Subscription { }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::cmp::PartialEq for Subscription {
                #[inline]
                fn eq(&self, other: &Subscription) -> bool {
                    match *other {
                        Subscription {
                        endpoint: ref __self_1_0, keys: ref __self_1_1 } =>
                        match *self {
                            Subscription {
                            endpoint: ref __self_0_0, keys: ref __self_0_1 }
                            =>
                            (*__self_0_0) == (*__self_1_0) &&
                                (*__self_0_1) == (*__self_1_1),
                        },
                    }
                }
                #[inline]
                fn ne(&self, other: &Subscription) -> bool {
                    match *other {
                        Subscription {
                        endpoint: ref __self_1_0, keys: ref __self_1_1 } =>
                        match *self {
                            Subscription {
                            endpoint: ref __self_0_0, keys: ref __self_0_1 }
                            =>
                            (*__self_0_0) != (*__self_1_0) ||
                                (*__self_0_1) != (*__self_1_1),
                        },
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes,
                    unused_qualifications)]
            const _IMPL_SERIALIZE_FOR_Subscription: () =
                {
                    #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try {
                        ($ __expr : expr) =>
                        {
                            match $ __expr
                            {
                                _serde :: export :: Ok(__val) => __val, _serde
                                :: export :: Err(__err) =>
                                { return _serde :: export :: Err(__err) ; }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl _serde::Serialize for Subscription {
                        fn serialize<__S>(&self, __serializer: __S)
                         -> _serde::export::Result<__S::Ok, __S::Error> where
                         __S: _serde::Serializer {
                            let mut __serde_state =
                                match _serde::Serializer::serialize_struct(__serializer,
                                                                           "Subscription",
                                                                           false
                                                                               as
                                                                               usize
                                                                               +
                                                                               1
                                                                               +
                                                                               1)
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "endpoint",
                                                                                &self.endpoint)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "keys",
                                                                                &self.keys)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::default::Default for Subscription {
                #[inline]
                fn default() -> Subscription {
                    Subscription{endpoint:
                                     ::core::default::Default::default(),
                                 keys: ::core::default::Default::default(),}
                }
            }
            pub(crate) struct Keys {
                pub(crate) p256dh: String,
                pub(crate) auth: String,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for Keys {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                 -> ::core::fmt::Result {
                    match *self {
                        Keys { p256dh: ref __self_0_0, auth: ref __self_0_1 }
                        => {
                            let mut debug_trait_builder =
                                f.debug_struct("Keys");
                            let _ =
                                debug_trait_builder.field("p256dh",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("auth",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::clone::Clone for Keys {
                #[inline]
                fn clone(&self) -> Keys {
                    match *self {
                        Keys { p256dh: ref __self_0_0, auth: ref __self_0_1 }
                        =>
                        Keys{p256dh:
                                 ::core::clone::Clone::clone(&(*__self_0_0)),
                             auth:
                                 ::core::clone::Clone::clone(&(*__self_0_1)),},
                    }
                }
            }
            impl ::core::marker::StructuralPartialEq for Keys { }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::cmp::PartialEq for Keys {
                #[inline]
                fn eq(&self, other: &Keys) -> bool {
                    match *other {
                        Keys { p256dh: ref __self_1_0, auth: ref __self_1_1 }
                        =>
                        match *self {
                            Keys {
                            p256dh: ref __self_0_0, auth: ref __self_0_1 } =>
                            (*__self_0_0) == (*__self_1_0) &&
                                (*__self_0_1) == (*__self_1_1),
                        },
                    }
                }
                #[inline]
                fn ne(&self, other: &Keys) -> bool {
                    match *other {
                        Keys { p256dh: ref __self_1_0, auth: ref __self_1_1 }
                        =>
                        match *self {
                            Keys {
                            p256dh: ref __self_0_0, auth: ref __self_0_1 } =>
                            (*__self_0_0) != (*__self_1_0) ||
                                (*__self_0_1) != (*__self_1_1),
                        },
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes,
                    unused_qualifications)]
            const _IMPL_SERIALIZE_FOR_Keys: () =
                {
                    #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try {
                        ($ __expr : expr) =>
                        {
                            match $ __expr
                            {
                                _serde :: export :: Ok(__val) => __val, _serde
                                :: export :: Err(__err) =>
                                { return _serde :: export :: Err(__err) ; }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl _serde::Serialize for Keys {
                        fn serialize<__S>(&self, __serializer: __S)
                         -> _serde::export::Result<__S::Ok, __S::Error> where
                         __S: _serde::Serializer {
                            let mut __serde_state =
                                match _serde::Serializer::serialize_struct(__serializer,
                                                                           "Keys",
                                                                           false
                                                                               as
                                                                               usize
                                                                               +
                                                                               1
                                                                               +
                                                                               1)
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "p256dh",
                                                                                &self.p256dh)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "auth",
                                                                                &self.auth)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::default::Default for Keys {
                #[inline]
                fn default() -> Keys {
                    Keys{p256dh: ::core::default::Default::default(),
                         auth: ::core::default::Default::default(),}
                }
            }
            pub(crate) struct Data {
                pub(crate) alerts: Option<Alerts>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for Data {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                 -> ::core::fmt::Result {
                    match *self {
                        Data { alerts: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("Data");
                            let _ =
                                debug_trait_builder.field("alerts",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::clone::Clone for Data {
                #[inline]
                fn clone(&self) -> Data {
                    match *self {
                        Data { alerts: ref __self_0_0 } =>
                        Data{alerts:
                                 ::core::clone::Clone::clone(&(*__self_0_0)),},
                    }
                }
            }
            impl ::core::marker::StructuralPartialEq for Data { }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::cmp::PartialEq for Data {
                #[inline]
                fn eq(&self, other: &Data) -> bool {
                    match *other {
                        Data { alerts: ref __self_1_0 } =>
                        match *self {
                            Data { alerts: ref __self_0_0 } =>
                            (*__self_0_0) == (*__self_1_0),
                        },
                    }
                }
                #[inline]
                fn ne(&self, other: &Data) -> bool {
                    match *other {
                        Data { alerts: ref __self_1_0 } =>
                        match *self {
                            Data { alerts: ref __self_0_0 } =>
                            (*__self_0_0) != (*__self_1_0),
                        },
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes,
                    unused_qualifications)]
            const _IMPL_SERIALIZE_FOR_Data: () =
                {
                    #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try {
                        ($ __expr : expr) =>
                        {
                            match $ __expr
                            {
                                _serde :: export :: Ok(__val) => __val, _serde
                                :: export :: Err(__err) =>
                                { return _serde :: export :: Err(__err) ; }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl _serde::Serialize for Data {
                        fn serialize<__S>(&self, __serializer: __S)
                         -> _serde::export::Result<__S::Ok, __S::Error> where
                         __S: _serde::Serializer {
                            let mut __serde_state =
                                match _serde::Serializer::serialize_struct(__serializer,
                                                                           "Data",
                                                                           false
                                                                               as
                                                                               usize
                                                                               +
                                                                               1)
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "alerts",
                                                                                &self.alerts)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::default::Default for Data {
                #[inline]
                fn default() -> Data {
                    Data{alerts: ::core::default::Default::default(),}
                }
            }
        }
        pub(crate) mod update_data {
            use super::Alerts;
            pub(crate) struct Data {
                pub(crate) alerts: Option<Alerts>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for Data {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                 -> ::core::fmt::Result {
                    match *self {
                        Data { alerts: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("Data");
                            let _ =
                                debug_trait_builder.field("alerts",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::clone::Clone for Data {
                #[inline]
                fn clone(&self) -> Data {
                    match *self {
                        Data { alerts: ref __self_0_0 } =>
                        Data{alerts:
                                 ::core::clone::Clone::clone(&(*__self_0_0)),},
                    }
                }
            }
            impl ::core::marker::StructuralPartialEq for Data { }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::cmp::PartialEq for Data {
                #[inline]
                fn eq(&self, other: &Data) -> bool {
                    match *other {
                        Data { alerts: ref __self_1_0 } =>
                        match *self {
                            Data { alerts: ref __self_0_0 } =>
                            (*__self_0_0) == (*__self_1_0),
                        },
                    }
                }
                #[inline]
                fn ne(&self, other: &Data) -> bool {
                    match *other {
                        Data { alerts: ref __self_1_0 } =>
                        match *self {
                            Data { alerts: ref __self_0_0 } =>
                            (*__self_0_0) != (*__self_1_0),
                        },
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes,
                    unused_qualifications)]
            const _IMPL_SERIALIZE_FOR_Data: () =
                {
                    #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try {
                        ($ __expr : expr) =>
                        {
                            match $ __expr
                            {
                                _serde :: export :: Ok(__val) => __val, _serde
                                :: export :: Err(__err) =>
                                { return _serde :: export :: Err(__err) ; }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl _serde::Serialize for Data {
                        fn serialize<__S>(&self, __serializer: __S)
                         -> _serde::export::Result<__S::Ok, __S::Error> where
                         __S: _serde::Serializer {
                            let mut __serde_state =
                                match _serde::Serializer::serialize_struct(__serializer,
                                                                           "Data",
                                                                           false
                                                                               as
                                                                               usize
                                                                               +
                                                                               1)
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "alerts",
                                                                                &self.alerts)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::default::Default for Data {
                #[inline]
                fn default() -> Data {
                    Data{alerts: ::core::default::Default::default(),}
                }
            }
            pub(crate) struct Form {
                pub(crate) id: String,
                pub(crate) data: Data,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for Form {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                 -> ::core::fmt::Result {
                    match *self {
                        Form { id: ref __self_0_0, data: ref __self_0_1 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("Form");
                            let _ =
                                debug_trait_builder.field("id",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("data",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::clone::Clone for Form {
                #[inline]
                fn clone(&self) -> Form {
                    match *self {
                        Form { id: ref __self_0_0, data: ref __self_0_1 } =>
                        Form{id: ::core::clone::Clone::clone(&(*__self_0_0)),
                             data:
                                 ::core::clone::Clone::clone(&(*__self_0_1)),},
                    }
                }
            }
            impl ::core::marker::StructuralPartialEq for Form { }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::cmp::PartialEq for Form {
                #[inline]
                fn eq(&self, other: &Form) -> bool {
                    match *other {
                        Form { id: ref __self_1_0, data: ref __self_1_1 } =>
                        match *self {
                            Form { id: ref __self_0_0, data: ref __self_0_1 }
                            =>
                            (*__self_0_0) == (*__self_1_0) &&
                                (*__self_0_1) == (*__self_1_1),
                        },
                    }
                }
                #[inline]
                fn ne(&self, other: &Form) -> bool {
                    match *other {
                        Form { id: ref __self_1_0, data: ref __self_1_1 } =>
                        match *self {
                            Form { id: ref __self_0_0, data: ref __self_0_1 }
                            =>
                            (*__self_0_0) != (*__self_1_0) ||
                                (*__self_0_1) != (*__self_1_1),
                        },
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes,
                    unused_qualifications)]
            const _IMPL_SERIALIZE_FOR_Form: () =
                {
                    #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try {
                        ($ __expr : expr) =>
                        {
                            match $ __expr
                            {
                                _serde :: export :: Ok(__val) => __val, _serde
                                :: export :: Err(__err) =>
                                { return _serde :: export :: Err(__err) ; }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl _serde::Serialize for Form {
                        fn serialize<__S>(&self, __serializer: __S)
                         -> _serde::export::Result<__S::Ok, __S::Error> where
                         __S: _serde::Serializer {
                            let mut __serde_state =
                                match _serde::Serializer::serialize_struct(__serializer,
                                                                           "Form",
                                                                           false
                                                                               as
                                                                               usize
                                                                               +
                                                                               1
                                                                               +
                                                                               1)
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "id",
                                                                                &self.id)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "data",
                                                                                &self.data)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStruct::end(__serde_state)
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::default::Default for Form {
                #[inline]
                fn default() -> Form {
                    Form{id: ::core::default::Default::default(),
                         data: ::core::default::Default::default(),}
                }
            }
        }
    }
    /// Data structures for ser/de of relationship-related resources
    pub mod relationship {
        //! module containing everything relating to a relationship with
        //! another account.
        /// A struct containing information about a relationship with another account.
        pub struct Relationship {
            /// Target account id
            pub id: String,
            /// Whether the application client follows the account.
            pub following: bool,
            /// Whether the account follows the application client.
            pub followed_by: bool,
            /// Whether the application client blocks the account.
            pub blocking: bool,
            /// Whether the application client blocks the account.
            pub muting: bool,
            /// Whether the application client has requested to follow the account.
            pub requested: bool,
            /// Whether the user is also muting notifications
            pub muting_notifications: bool,
            /// Whether the user is currently blocking the accounts's domain
            pub domain_blocking: bool,
            /// Whether the user's reblogs will show up in the home timeline
            pub showing_reblogs: bool,
            /// Whether the user is currently endorsing the account
            ///
            /// This field is not techincally nullable with mastodon >= 2.5.0, but
            /// making it `Option<bool>` here means we shouldn't get deser errors when
            /// making calls to pleroma or mastodon<2.5.0 instances
            pub endorsed: Option<bool>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Relationship {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Relationship {
                    id: ref __self_0_0,
                    following: ref __self_0_1,
                    followed_by: ref __self_0_2,
                    blocking: ref __self_0_3,
                    muting: ref __self_0_4,
                    requested: ref __self_0_5,
                    muting_notifications: ref __self_0_6,
                    domain_blocking: ref __self_0_7,
                    showing_reblogs: ref __self_0_8,
                    endorsed: ref __self_0_9 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Relationship");
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("following",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("followed_by",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("blocking",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("muting",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("requested",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("muting_notifications",
                                                      &&(*__self_0_6));
                        let _ =
                            debug_trait_builder.field("domain_blocking",
                                                      &&(*__self_0_7));
                        let _ =
                            debug_trait_builder.field("showing_reblogs",
                                                      &&(*__self_0_8));
                        let _ =
                            debug_trait_builder.field("endorsed",
                                                      &&(*__self_0_9));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Relationship {
            #[inline]
            fn clone(&self) -> Relationship {
                match *self {
                    Relationship {
                    id: ref __self_0_0,
                    following: ref __self_0_1,
                    followed_by: ref __self_0_2,
                    blocking: ref __self_0_3,
                    muting: ref __self_0_4,
                    requested: ref __self_0_5,
                    muting_notifications: ref __self_0_6,
                    domain_blocking: ref __self_0_7,
                    showing_reblogs: ref __self_0_8,
                    endorsed: ref __self_0_9 } =>
                    Relationship{id:
                                     ::core::clone::Clone::clone(&(*__self_0_0)),
                                 following:
                                     ::core::clone::Clone::clone(&(*__self_0_1)),
                                 followed_by:
                                     ::core::clone::Clone::clone(&(*__self_0_2)),
                                 blocking:
                                     ::core::clone::Clone::clone(&(*__self_0_3)),
                                 muting:
                                     ::core::clone::Clone::clone(&(*__self_0_4)),
                                 requested:
                                     ::core::clone::Clone::clone(&(*__self_0_5)),
                                 muting_notifications:
                                     ::core::clone::Clone::clone(&(*__self_0_6)),
                                 domain_blocking:
                                     ::core::clone::Clone::clone(&(*__self_0_7)),
                                 showing_reblogs:
                                     ::core::clone::Clone::clone(&(*__self_0_8)),
                                 endorsed:
                                     ::core::clone::Clone::clone(&(*__self_0_9)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Relationship: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Relationship {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    6u64 =>
                                    _serde::export::Ok(__Field::__field6),
                                    7u64 =>
                                    _serde::export::Ok(__Field::__field7),
                                    8u64 =>
                                    _serde::export::Ok(__Field::__field8),
                                    9u64 =>
                                    _serde::export::Ok(__Field::__field9),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 10")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "following" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "followed_by" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "blocking" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "muting" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "requested" =>
                                    _serde::export::Ok(__Field::__field5),
                                    "muting_notifications" =>
                                    _serde::export::Ok(__Field::__field6),
                                    "domain_blocking" =>
                                    _serde::export::Ok(__Field::__field7),
                                    "showing_reblogs" =>
                                    _serde::export::Ok(__Field::__field8),
                                    "endorsed" =>
                                    _serde::export::Ok(__Field::__field9),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"following" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"followed_by" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"blocking" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"muting" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"requested" =>
                                    _serde::export::Ok(__Field::__field5),
                                    b"muting_notifications" =>
                                    _serde::export::Ok(__Field::__field6),
                                    b"domain_blocking" =>
                                    _serde::export::Ok(__Field::__field7),
                                    b"showing_reblogs" =>
                                    _serde::export::Ok(__Field::__field8),
                                    b"endorsed" =>
                                    _serde::export::Ok(__Field::__field9),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Relationship>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Relationship;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Relationship")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                let __field5 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                let __field6 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                let __field7 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(7usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                let __field8 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(8usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                let __field9 =
                                    match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(9usize,
                                                                                                         &"struct Relationship with 10 elements"));
                                        }
                                    };
                                _serde::export::Ok(Relationship{id: __field0,
                                                                following:
                                                                    __field1,
                                                                followed_by:
                                                                    __field2,
                                                                blocking:
                                                                    __field3,
                                                                muting:
                                                                    __field4,
                                                                requested:
                                                                    __field5,
                                                                muting_notifications:
                                                                    __field6,
                                                                domain_blocking:
                                                                    __field7,
                                                                showing_reblogs:
                                                                    __field8,
                                                                endorsed:
                                                                    __field9,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field5:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field6:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field7:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field8:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field9:
                                        _serde::export::Option<Option<bool>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("following"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("followed_by"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("blocking"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("muting"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field5 => {
                                            if _serde::export::Option::is_some(&__field5)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("requested"));
                                            }
                                            __field5 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field6 => {
                                            if _serde::export::Option::is_some(&__field6)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("muting_notifications"));
                                            }
                                            __field6 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field7 => {
                                            if _serde::export::Option::is_some(&__field7)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("domain_blocking"));
                                            }
                                            __field7 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field8 => {
                                            if _serde::export::Option::is_some(&__field8)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("showing_reblogs"));
                                            }
                                            __field8 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field9 => {
                                            if _serde::export::Option::is_some(&__field9)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("endorsed"));
                                            }
                                            __field9 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("following")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("followed_by")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("blocking")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("muting")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::export::Some(__field5) =>
                                        __field5,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("requested")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field6 =
                                    match __field6 {
                                        _serde::export::Some(__field6) =>
                                        __field6,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("muting_notifications")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field7 =
                                    match __field7 {
                                        _serde::export::Some(__field7) =>
                                        __field7,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("domain_blocking")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field8 =
                                    match __field8 {
                                        _serde::export::Some(__field8) =>
                                        __field8,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("showing_reblogs")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field9 =
                                    match __field9 {
                                        _serde::export::Some(__field9) =>
                                        __field9,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("endorsed")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Relationship{id: __field0,
                                                                following:
                                                                    __field1,
                                                                followed_by:
                                                                    __field2,
                                                                blocking:
                                                                    __field3,
                                                                muting:
                                                                    __field4,
                                                                requested:
                                                                    __field5,
                                                                muting_notifications:
                                                                    __field6,
                                                                domain_blocking:
                                                                    __field7,
                                                                showing_reblogs:
                                                                    __field8,
                                                                endorsed:
                                                                    __field9,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["id", "following", "followed_by", "blocking",
                              "muting", "requested", "muting_notifications",
                              "domain_blocking", "showing_reblogs",
                              "endorsed"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Relationship",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Relationship>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Relationship { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Relationship {
            #[inline]
            fn eq(&self, other: &Relationship) -> bool {
                match *other {
                    Relationship {
                    id: ref __self_1_0,
                    following: ref __self_1_1,
                    followed_by: ref __self_1_2,
                    blocking: ref __self_1_3,
                    muting: ref __self_1_4,
                    requested: ref __self_1_5,
                    muting_notifications: ref __self_1_6,
                    domain_blocking: ref __self_1_7,
                    showing_reblogs: ref __self_1_8,
                    endorsed: ref __self_1_9 } =>
                    match *self {
                        Relationship {
                        id: ref __self_0_0,
                        following: ref __self_0_1,
                        followed_by: ref __self_0_2,
                        blocking: ref __self_0_3,
                        muting: ref __self_0_4,
                        requested: ref __self_0_5,
                        muting_notifications: ref __self_0_6,
                        domain_blocking: ref __self_0_7,
                        showing_reblogs: ref __self_0_8,
                        endorsed: ref __self_0_9 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5) &&
                            (*__self_0_6) == (*__self_1_6) &&
                            (*__self_0_7) == (*__self_1_7) &&
                            (*__self_0_8) == (*__self_1_8) &&
                            (*__self_0_9) == (*__self_1_9),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Relationship) -> bool {
                match *other {
                    Relationship {
                    id: ref __self_1_0,
                    following: ref __self_1_1,
                    followed_by: ref __self_1_2,
                    blocking: ref __self_1_3,
                    muting: ref __self_1_4,
                    requested: ref __self_1_5,
                    muting_notifications: ref __self_1_6,
                    domain_blocking: ref __self_1_7,
                    showing_reblogs: ref __self_1_8,
                    endorsed: ref __self_1_9 } =>
                    match *self {
                        Relationship {
                        id: ref __self_0_0,
                        following: ref __self_0_1,
                        followed_by: ref __self_0_2,
                        blocking: ref __self_0_3,
                        muting: ref __self_0_4,
                        requested: ref __self_0_5,
                        muting_notifications: ref __self_0_6,
                        domain_blocking: ref __self_0_7,
                        showing_reblogs: ref __self_0_8,
                        endorsed: ref __self_0_9 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5) ||
                            (*__self_0_6) != (*__self_1_6) ||
                            (*__self_0_7) != (*__self_1_7) ||
                            (*__self_0_8) != (*__self_1_8) ||
                            (*__self_0_9) != (*__self_1_9),
                    },
                }
            }
        }
    }
    /// Data structures for ser/de of report-related resources
    pub mod report {
        //! module containing information about a finished report of a user.
        /// A struct containing info about a report.
        pub struct Report {
            /// The ID of the report.
            pub id: String,
            /// The action taken in response to the report.
            pub action_taken: String,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Report {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Report { id: ref __self_0_0, action_taken: ref __self_0_1
                    } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Report");
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("action_taken",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Report {
            #[inline]
            fn clone(&self) -> Report {
                match *self {
                    Report { id: ref __self_0_0, action_taken: ref __self_0_1
                    } =>
                    Report{id: ::core::clone::Clone::clone(&(*__self_0_0)),
                           action_taken:
                               ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Report: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Report {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field { __field0, __field1, __ignore, }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 2")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "action_taken" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"action_taken" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Report>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Report;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Report")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Report with 2 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Report with 2 elements"));
                                        }
                                    };
                                _serde::export::Ok(Report{id: __field0,
                                                          action_taken:
                                                              __field1,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("action_taken"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("action_taken")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Report{id: __field0,
                                                          action_taken:
                                                              __field1,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["id", "action_taken"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Report",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Report>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Report { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Report {
            #[inline]
            fn eq(&self, other: &Report) -> bool {
                match *other {
                    Report { id: ref __self_1_0, action_taken: ref __self_1_1
                    } =>
                    match *self {
                        Report {
                        id: ref __self_0_0, action_taken: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Report) -> bool {
                match *other {
                    Report { id: ref __self_1_0, action_taken: ref __self_1_1
                    } =>
                    match *self {
                        Report {
                        id: ref __self_0_0, action_taken: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
    }
    /// Data structures for ser/de of search-related resources
    pub mod search_result {
        //! A module containing info relating to a search result.
        use super::{prelude::{Account, Status}, status::Tag};
        /// A struct containing results of a search.
        pub struct SearchResult {
            /// An array of matched Accounts.
            pub accounts: Vec<Account>,
            /// An array of matched Statuses.
            pub statuses: Vec<Status>,
            /// An array of matched hashtags, as strings.
            pub hashtags: Vec<String>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SearchResult {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    SearchResult {
                    accounts: ref __self_0_0,
                    statuses: ref __self_0_1,
                    hashtags: ref __self_0_2 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("SearchResult");
                        let _ =
                            debug_trait_builder.field("accounts",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("statuses",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("hashtags",
                                                      &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SearchResult {
            #[inline]
            fn clone(&self) -> SearchResult {
                match *self {
                    SearchResult {
                    accounts: ref __self_0_0,
                    statuses: ref __self_0_1,
                    hashtags: ref __self_0_2 } =>
                    SearchResult{accounts:
                                     ::core::clone::Clone::clone(&(*__self_0_0)),
                                 statuses:
                                     ::core::clone::Clone::clone(&(*__self_0_1)),
                                 hashtags:
                                     ::core::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_SearchResult: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for SearchResult {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 3")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "accounts" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "statuses" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "hashtags" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"accounts" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"statuses" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"hashtags" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<SearchResult>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = SearchResult;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct SearchResult")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Account>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct SearchResult with 3 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Status>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct SearchResult with 3 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct SearchResult with 3 elements"));
                                        }
                                    };
                                _serde::export::Ok(SearchResult{accounts:
                                                                    __field0,
                                                                statuses:
                                                                    __field1,
                                                                hashtags:
                                                                    __field2,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<Vec<Account>> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<Vec<Status>> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<Vec<String>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("accounts"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Account>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("statuses"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Status>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("hashtags"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("accounts")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("statuses")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("hashtags")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(SearchResult{accounts:
                                                                    __field0,
                                                                statuses:
                                                                    __field1,
                                                                hashtags:
                                                                    __field2,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["accounts", "statuses", "hashtags"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "SearchResult",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<SearchResult>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for SearchResult { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SearchResult {
            #[inline]
            fn eq(&self, other: &SearchResult) -> bool {
                match *other {
                    SearchResult {
                    accounts: ref __self_1_0,
                    statuses: ref __self_1_1,
                    hashtags: ref __self_1_2 } =>
                    match *self {
                        SearchResult {
                        accounts: ref __self_0_0,
                        statuses: ref __self_0_1,
                        hashtags: ref __self_0_2 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &SearchResult) -> bool {
                match *other {
                    SearchResult {
                    accounts: ref __self_1_0,
                    statuses: ref __self_1_1,
                    hashtags: ref __self_1_2 } =>
                    match *self {
                        SearchResult {
                        accounts: ref __self_0_0,
                        statuses: ref __self_0_1,
                        hashtags: ref __self_0_2 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2),
                    },
                }
            }
        }
        /// A struct containing results of a search, with `Tag` objects in the
        /// `hashtags` field
        pub struct SearchResultV2 {
            /// An array of matched Accounts.
            pub accounts: Vec<Account>,
            /// An array of matched Statuses.
            pub statuses: Vec<Status>,
            /// An array of matched hashtags, as `Tag` objects.
            pub hashtags: Vec<Tag>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SearchResultV2 {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    SearchResultV2 {
                    accounts: ref __self_0_0,
                    statuses: ref __self_0_1,
                    hashtags: ref __self_0_2 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("SearchResultV2");
                        let _ =
                            debug_trait_builder.field("accounts",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("statuses",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("hashtags",
                                                      &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SearchResultV2 {
            #[inline]
            fn clone(&self) -> SearchResultV2 {
                match *self {
                    SearchResultV2 {
                    accounts: ref __self_0_0,
                    statuses: ref __self_0_1,
                    hashtags: ref __self_0_2 } =>
                    SearchResultV2{accounts:
                                       ::core::clone::Clone::clone(&(*__self_0_0)),
                                   statuses:
                                       ::core::clone::Clone::clone(&(*__self_0_1)),
                                   hashtags:
                                       ::core::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_SearchResultV2: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for SearchResultV2 {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 3")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "accounts" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "statuses" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "hashtags" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"accounts" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"statuses" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"hashtags" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<SearchResultV2>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = SearchResultV2;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct SearchResultV2")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Account>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct SearchResultV2 with 3 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Status>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct SearchResultV2 with 3 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Tag>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct SearchResultV2 with 3 elements"));
                                        }
                                    };
                                _serde::export::Ok(SearchResultV2{accounts:
                                                                      __field0,
                                                                  statuses:
                                                                      __field1,
                                                                  hashtags:
                                                                      __field2,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<Vec<Account>> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<Vec<Status>> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<Vec<Tag>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("accounts"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Account>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("statuses"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Status>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("hashtags"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Tag>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("accounts")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("statuses")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("hashtags")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(SearchResultV2{accounts:
                                                                      __field0,
                                                                  statuses:
                                                                      __field1,
                                                                  hashtags:
                                                                      __field2,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["accounts", "statuses", "hashtags"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "SearchResultV2",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<SearchResultV2>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for SearchResultV2 { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SearchResultV2 {
            #[inline]
            fn eq(&self, other: &SearchResultV2) -> bool {
                match *other {
                    SearchResultV2 {
                    accounts: ref __self_1_0,
                    statuses: ref __self_1_1,
                    hashtags: ref __self_1_2 } =>
                    match *self {
                        SearchResultV2 {
                        accounts: ref __self_0_0,
                        statuses: ref __self_0_1,
                        hashtags: ref __self_0_2 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &SearchResultV2) -> bool {
                match *other {
                    SearchResultV2 {
                    accounts: ref __self_1_0,
                    statuses: ref __self_1_1,
                    hashtags: ref __self_1_2 } =>
                    match *self {
                        SearchResultV2 {
                        accounts: ref __self_0_0,
                        statuses: ref __self_0_1,
                        hashtags: ref __self_0_2 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2),
                    },
                }
            }
        }
    }
    /// Data structures for ser/de of status-related resources
    pub mod status {
        //! Module containing all info relating to a status.
        use super::prelude::*;
        use chrono::prelude::*;
        use crate::entities::card::Card;
        use crate::status_builder::Visibility;
        /// A status from the instance.
        pub struct Status {
            /// The ID of the status.
            pub id: String,
            /// A Fediverse-unique resource ID.
            pub uri: String,
            /// URL to the status page (can be remote)
            pub url: Option<String>,
            /// The Account which posted the status.
            pub account: Account,
            /// The ID of the status this status is replying to, if the status is
            /// a reply.
            pub in_reply_to_id: Option<String>,
            /// The ID of the account this status is replying to, if the status is
            /// a reply.
            pub in_reply_to_account_id: Option<String>,
            /// If this status is a reblogged Status of another User.
            pub reblog: Option<Box<Status>>,
            /// Body of the status; this will contain HTML
            /// (remote HTML already sanitized)
            pub content: String,
            /// The time the status was created.
            pub created_at: DateTime<Utc>,
            /// An array of Emoji
            pub emojis: Vec<Emoji>,
            /// The numbef or replies to this status.
            pub replies_count: Option<u64>,
            /// The number of reblogs for the status.
            pub reblogs_count: u64,
            /// The number of favourites for the status.
            pub favourites_count: u64,
            /// Whether the application client has reblogged the status.
            pub reblogged: Option<bool>,
            /// Whether the application client has favourited the status.
            pub favourited: Option<bool>,
            /// Whether media attachments should be hidden by default.
            pub sensitive: bool,
            /// If not empty, warning text that should be displayed before the actual
            /// content.
            pub spoiler_text: String,
            /// The visibilty of the status.
            pub visibility: Visibility,
            /// An array of attachments.
            pub media_attachments: Vec<Attachment>,
            /// An array of mentions.
            pub mentions: Vec<Mention>,
            /// An array of tags.
            pub tags: Vec<Tag>,
            /// The associated card
            pub card: Option<Card>,
            /// Name of application used to post status.
            pub application: Option<Application>,
            /// The detected language for the status, if detected.
            pub language: Option<String>,
            /// Whether this is the pinned status for the account that posted it.
            pub pinned: Option<bool>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Status {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Status {
                    id: ref __self_0_0,
                    uri: ref __self_0_1,
                    url: ref __self_0_2,
                    account: ref __self_0_3,
                    in_reply_to_id: ref __self_0_4,
                    in_reply_to_account_id: ref __self_0_5,
                    reblog: ref __self_0_6,
                    content: ref __self_0_7,
                    created_at: ref __self_0_8,
                    emojis: ref __self_0_9,
                    replies_count: ref __self_0_10,
                    reblogs_count: ref __self_0_11,
                    favourites_count: ref __self_0_12,
                    reblogged: ref __self_0_13,
                    favourited: ref __self_0_14,
                    sensitive: ref __self_0_15,
                    spoiler_text: ref __self_0_16,
                    visibility: ref __self_0_17,
                    media_attachments: ref __self_0_18,
                    mentions: ref __self_0_19,
                    tags: ref __self_0_20,
                    card: ref __self_0_21,
                    application: ref __self_0_22,
                    language: ref __self_0_23,
                    pinned: ref __self_0_24 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Status");
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("uri", &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("url", &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("account",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("in_reply_to_id",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("in_reply_to_account_id",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("reblog",
                                                      &&(*__self_0_6));
                        let _ =
                            debug_trait_builder.field("content",
                                                      &&(*__self_0_7));
                        let _ =
                            debug_trait_builder.field("created_at",
                                                      &&(*__self_0_8));
                        let _ =
                            debug_trait_builder.field("emojis",
                                                      &&(*__self_0_9));
                        let _ =
                            debug_trait_builder.field("replies_count",
                                                      &&(*__self_0_10));
                        let _ =
                            debug_trait_builder.field("reblogs_count",
                                                      &&(*__self_0_11));
                        let _ =
                            debug_trait_builder.field("favourites_count",
                                                      &&(*__self_0_12));
                        let _ =
                            debug_trait_builder.field("reblogged",
                                                      &&(*__self_0_13));
                        let _ =
                            debug_trait_builder.field("favourited",
                                                      &&(*__self_0_14));
                        let _ =
                            debug_trait_builder.field("sensitive",
                                                      &&(*__self_0_15));
                        let _ =
                            debug_trait_builder.field("spoiler_text",
                                                      &&(*__self_0_16));
                        let _ =
                            debug_trait_builder.field("visibility",
                                                      &&(*__self_0_17));
                        let _ =
                            debug_trait_builder.field("media_attachments",
                                                      &&(*__self_0_18));
                        let _ =
                            debug_trait_builder.field("mentions",
                                                      &&(*__self_0_19));
                        let _ =
                            debug_trait_builder.field("tags",
                                                      &&(*__self_0_20));
                        let _ =
                            debug_trait_builder.field("card",
                                                      &&(*__self_0_21));
                        let _ =
                            debug_trait_builder.field("application",
                                                      &&(*__self_0_22));
                        let _ =
                            debug_trait_builder.field("language",
                                                      &&(*__self_0_23));
                        let _ =
                            debug_trait_builder.field("pinned",
                                                      &&(*__self_0_24));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Status {
            #[inline]
            fn clone(&self) -> Status {
                match *self {
                    Status {
                    id: ref __self_0_0,
                    uri: ref __self_0_1,
                    url: ref __self_0_2,
                    account: ref __self_0_3,
                    in_reply_to_id: ref __self_0_4,
                    in_reply_to_account_id: ref __self_0_5,
                    reblog: ref __self_0_6,
                    content: ref __self_0_7,
                    created_at: ref __self_0_8,
                    emojis: ref __self_0_9,
                    replies_count: ref __self_0_10,
                    reblogs_count: ref __self_0_11,
                    favourites_count: ref __self_0_12,
                    reblogged: ref __self_0_13,
                    favourited: ref __self_0_14,
                    sensitive: ref __self_0_15,
                    spoiler_text: ref __self_0_16,
                    visibility: ref __self_0_17,
                    media_attachments: ref __self_0_18,
                    mentions: ref __self_0_19,
                    tags: ref __self_0_20,
                    card: ref __self_0_21,
                    application: ref __self_0_22,
                    language: ref __self_0_23,
                    pinned: ref __self_0_24 } =>
                    Status{id: ::core::clone::Clone::clone(&(*__self_0_0)),
                           uri: ::core::clone::Clone::clone(&(*__self_0_1)),
                           url: ::core::clone::Clone::clone(&(*__self_0_2)),
                           account:
                               ::core::clone::Clone::clone(&(*__self_0_3)),
                           in_reply_to_id:
                               ::core::clone::Clone::clone(&(*__self_0_4)),
                           in_reply_to_account_id:
                               ::core::clone::Clone::clone(&(*__self_0_5)),
                           reblog:
                               ::core::clone::Clone::clone(&(*__self_0_6)),
                           content:
                               ::core::clone::Clone::clone(&(*__self_0_7)),
                           created_at:
                               ::core::clone::Clone::clone(&(*__self_0_8)),
                           emojis:
                               ::core::clone::Clone::clone(&(*__self_0_9)),
                           replies_count:
                               ::core::clone::Clone::clone(&(*__self_0_10)),
                           reblogs_count:
                               ::core::clone::Clone::clone(&(*__self_0_11)),
                           favourites_count:
                               ::core::clone::Clone::clone(&(*__self_0_12)),
                           reblogged:
                               ::core::clone::Clone::clone(&(*__self_0_13)),
                           favourited:
                               ::core::clone::Clone::clone(&(*__self_0_14)),
                           sensitive:
                               ::core::clone::Clone::clone(&(*__self_0_15)),
                           spoiler_text:
                               ::core::clone::Clone::clone(&(*__self_0_16)),
                           visibility:
                               ::core::clone::Clone::clone(&(*__self_0_17)),
                           media_attachments:
                               ::core::clone::Clone::clone(&(*__self_0_18)),
                           mentions:
                               ::core::clone::Clone::clone(&(*__self_0_19)),
                           tags: ::core::clone::Clone::clone(&(*__self_0_20)),
                           card: ::core::clone::Clone::clone(&(*__self_0_21)),
                           application:
                               ::core::clone::Clone::clone(&(*__self_0_22)),
                           language:
                               ::core::clone::Clone::clone(&(*__self_0_23)),
                           pinned:
                               ::core::clone::Clone::clone(&(*__self_0_24)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Status: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Status {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                            __field12,
                            __field13,
                            __field14,
                            __field15,
                            __field16,
                            __field17,
                            __field18,
                            __field19,
                            __field20,
                            __field21,
                            __field22,
                            __field23,
                            __field24,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    6u64 =>
                                    _serde::export::Ok(__Field::__field6),
                                    7u64 =>
                                    _serde::export::Ok(__Field::__field7),
                                    8u64 =>
                                    _serde::export::Ok(__Field::__field8),
                                    9u64 =>
                                    _serde::export::Ok(__Field::__field9),
                                    10u64 =>
                                    _serde::export::Ok(__Field::__field10),
                                    11u64 =>
                                    _serde::export::Ok(__Field::__field11),
                                    12u64 =>
                                    _serde::export::Ok(__Field::__field12),
                                    13u64 =>
                                    _serde::export::Ok(__Field::__field13),
                                    14u64 =>
                                    _serde::export::Ok(__Field::__field14),
                                    15u64 =>
                                    _serde::export::Ok(__Field::__field15),
                                    16u64 =>
                                    _serde::export::Ok(__Field::__field16),
                                    17u64 =>
                                    _serde::export::Ok(__Field::__field17),
                                    18u64 =>
                                    _serde::export::Ok(__Field::__field18),
                                    19u64 =>
                                    _serde::export::Ok(__Field::__field19),
                                    20u64 =>
                                    _serde::export::Ok(__Field::__field20),
                                    21u64 =>
                                    _serde::export::Ok(__Field::__field21),
                                    22u64 =>
                                    _serde::export::Ok(__Field::__field22),
                                    23u64 =>
                                    _serde::export::Ok(__Field::__field23),
                                    24u64 =>
                                    _serde::export::Ok(__Field::__field24),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 25")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "uri" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "url" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "account" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "in_reply_to_id" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "in_reply_to_account_id" =>
                                    _serde::export::Ok(__Field::__field5),
                                    "reblog" =>
                                    _serde::export::Ok(__Field::__field6),
                                    "content" =>
                                    _serde::export::Ok(__Field::__field7),
                                    "created_at" =>
                                    _serde::export::Ok(__Field::__field8),
                                    "emojis" =>
                                    _serde::export::Ok(__Field::__field9),
                                    "replies_count" =>
                                    _serde::export::Ok(__Field::__field10),
                                    "reblogs_count" =>
                                    _serde::export::Ok(__Field::__field11),
                                    "favourites_count" =>
                                    _serde::export::Ok(__Field::__field12),
                                    "reblogged" =>
                                    _serde::export::Ok(__Field::__field13),
                                    "favourited" =>
                                    _serde::export::Ok(__Field::__field14),
                                    "sensitive" =>
                                    _serde::export::Ok(__Field::__field15),
                                    "spoiler_text" =>
                                    _serde::export::Ok(__Field::__field16),
                                    "visibility" =>
                                    _serde::export::Ok(__Field::__field17),
                                    "media_attachments" =>
                                    _serde::export::Ok(__Field::__field18),
                                    "mentions" =>
                                    _serde::export::Ok(__Field::__field19),
                                    "tags" =>
                                    _serde::export::Ok(__Field::__field20),
                                    "card" =>
                                    _serde::export::Ok(__Field::__field21),
                                    "application" =>
                                    _serde::export::Ok(__Field::__field22),
                                    "language" =>
                                    _serde::export::Ok(__Field::__field23),
                                    "pinned" =>
                                    _serde::export::Ok(__Field::__field24),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"uri" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"url" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"account" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"in_reply_to_id" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"in_reply_to_account_id" =>
                                    _serde::export::Ok(__Field::__field5),
                                    b"reblog" =>
                                    _serde::export::Ok(__Field::__field6),
                                    b"content" =>
                                    _serde::export::Ok(__Field::__field7),
                                    b"created_at" =>
                                    _serde::export::Ok(__Field::__field8),
                                    b"emojis" =>
                                    _serde::export::Ok(__Field::__field9),
                                    b"replies_count" =>
                                    _serde::export::Ok(__Field::__field10),
                                    b"reblogs_count" =>
                                    _serde::export::Ok(__Field::__field11),
                                    b"favourites_count" =>
                                    _serde::export::Ok(__Field::__field12),
                                    b"reblogged" =>
                                    _serde::export::Ok(__Field::__field13),
                                    b"favourited" =>
                                    _serde::export::Ok(__Field::__field14),
                                    b"sensitive" =>
                                    _serde::export::Ok(__Field::__field15),
                                    b"spoiler_text" =>
                                    _serde::export::Ok(__Field::__field16),
                                    b"visibility" =>
                                    _serde::export::Ok(__Field::__field17),
                                    b"media_attachments" =>
                                    _serde::export::Ok(__Field::__field18),
                                    b"mentions" =>
                                    _serde::export::Ok(__Field::__field19),
                                    b"tags" =>
                                    _serde::export::Ok(__Field::__field20),
                                    b"card" =>
                                    _serde::export::Ok(__Field::__field21),
                                    b"application" =>
                                    _serde::export::Ok(__Field::__field22),
                                    b"language" =>
                                    _serde::export::Ok(__Field::__field23),
                                    b"pinned" =>
                                    _serde::export::Ok(__Field::__field24),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Status>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Status;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Status")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Account>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field5 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field6 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Box<Status>>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field7 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(7usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field8 =
                                    match match _serde::de::SeqAccess::next_element::<DateTime<Utc>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(8usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field9 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Emoji>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(9usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field10 =
                                    match match _serde::de::SeqAccess::next_element::<Option<u64>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(10usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field11 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(11usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field12 =
                                    match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(12usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field13 =
                                    match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(13usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field14 =
                                    match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(14usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field15 =
                                    match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(15usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field16 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(16usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field17 =
                                    match match _serde::de::SeqAccess::next_element::<Visibility>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(17usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field18 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Attachment>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(18usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field19 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Mention>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(19usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field20 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<Tag>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(20usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field21 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Card>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(21usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field22 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Application>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(22usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field23 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(23usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                let __field24 =
                                    match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(24usize,
                                                                                                         &"struct Status with 25 elements"));
                                        }
                                    };
                                _serde::export::Ok(Status{id: __field0,
                                                          uri: __field1,
                                                          url: __field2,
                                                          account: __field3,
                                                          in_reply_to_id:
                                                              __field4,
                                                          in_reply_to_account_id:
                                                              __field5,
                                                          reblog: __field6,
                                                          content: __field7,
                                                          created_at:
                                                              __field8,
                                                          emojis: __field9,
                                                          replies_count:
                                                              __field10,
                                                          reblogs_count:
                                                              __field11,
                                                          favourites_count:
                                                              __field12,
                                                          reblogged:
                                                              __field13,
                                                          favourited:
                                                              __field14,
                                                          sensitive:
                                                              __field15,
                                                          spoiler_text:
                                                              __field16,
                                                          visibility:
                                                              __field17,
                                                          media_attachments:
                                                              __field18,
                                                          mentions: __field19,
                                                          tags: __field20,
                                                          card: __field21,
                                                          application:
                                                              __field22,
                                                          language: __field23,
                                                          pinned: __field24,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Account> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field5:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field6:
                                        _serde::export::Option<Option<Box<Status>>> =
                                    _serde::export::None;
                                let mut __field7:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field8:
                                        _serde::export::Option<DateTime<Utc>> =
                                    _serde::export::None;
                                let mut __field9:
                                        _serde::export::Option<Vec<Emoji>> =
                                    _serde::export::None;
                                let mut __field10:
                                        _serde::export::Option<Option<u64>> =
                                    _serde::export::None;
                                let mut __field11:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                let mut __field12:
                                        _serde::export::Option<u64> =
                                    _serde::export::None;
                                let mut __field13:
                                        _serde::export::Option<Option<bool>> =
                                    _serde::export::None;
                                let mut __field14:
                                        _serde::export::Option<Option<bool>> =
                                    _serde::export::None;
                                let mut __field15:
                                        _serde::export::Option<bool> =
                                    _serde::export::None;
                                let mut __field16:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field17:
                                        _serde::export::Option<Visibility> =
                                    _serde::export::None;
                                let mut __field18:
                                        _serde::export::Option<Vec<Attachment>> =
                                    _serde::export::None;
                                let mut __field19:
                                        _serde::export::Option<Vec<Mention>> =
                                    _serde::export::None;
                                let mut __field20:
                                        _serde::export::Option<Vec<Tag>> =
                                    _serde::export::None;
                                let mut __field21:
                                        _serde::export::Option<Option<Card>> =
                                    _serde::export::None;
                                let mut __field22:
                                        _serde::export::Option<Option<Application>> =
                                    _serde::export::None;
                                let mut __field23:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field24:
                                        _serde::export::Option<Option<bool>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("uri"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("url"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("account"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Account>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("in_reply_to_id"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field5 => {
                                            if _serde::export::Option::is_some(&__field5)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("in_reply_to_account_id"));
                                            }
                                            __field5 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field6 => {
                                            if _serde::export::Option::is_some(&__field6)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("reblog"));
                                            }
                                            __field6 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Box<Status>>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field7 => {
                                            if _serde::export::Option::is_some(&__field7)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("content"));
                                            }
                                            __field7 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field8 => {
                                            if _serde::export::Option::is_some(&__field8)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("created_at"));
                                            }
                                            __field8 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<DateTime<Utc>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field9 => {
                                            if _serde::export::Option::is_some(&__field9)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("emojis"));
                                            }
                                            __field9 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Emoji>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field10 => {
                                            if _serde::export::Option::is_some(&__field10)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("replies_count"));
                                            }
                                            __field10 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<u64>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field11 => {
                                            if _serde::export::Option::is_some(&__field11)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("reblogs_count"));
                                            }
                                            __field11 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field12 => {
                                            if _serde::export::Option::is_some(&__field12)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("favourites_count"));
                                            }
                                            __field12 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<u64>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field13 => {
                                            if _serde::export::Option::is_some(&__field13)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("reblogged"));
                                            }
                                            __field13 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field14 => {
                                            if _serde::export::Option::is_some(&__field14)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("favourited"));
                                            }
                                            __field14 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field15 => {
                                            if _serde::export::Option::is_some(&__field15)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("sensitive"));
                                            }
                                            __field15 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field16 => {
                                            if _serde::export::Option::is_some(&__field16)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("spoiler_text"));
                                            }
                                            __field16 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field17 => {
                                            if _serde::export::Option::is_some(&__field17)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("visibility"));
                                            }
                                            __field17 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Visibility>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field18 => {
                                            if _serde::export::Option::is_some(&__field18)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("media_attachments"));
                                            }
                                            __field18 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Attachment>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field19 => {
                                            if _serde::export::Option::is_some(&__field19)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("mentions"));
                                            }
                                            __field19 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Mention>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field20 => {
                                            if _serde::export::Option::is_some(&__field20)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("tags"));
                                            }
                                            __field20 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<Tag>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field21 => {
                                            if _serde::export::Option::is_some(&__field21)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("card"));
                                            }
                                            __field21 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Card>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field22 => {
                                            if _serde::export::Option::is_some(&__field22)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("application"));
                                            }
                                            __field22 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Application>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field23 => {
                                            if _serde::export::Option::is_some(&__field23)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("language"));
                                            }
                                            __field23 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field24 => {
                                            if _serde::export::Option::is_some(&__field24)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("pinned"));
                                            }
                                            __field24 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("uri")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("account")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("in_reply_to_id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::export::Some(__field5) =>
                                        __field5,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("in_reply_to_account_id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field6 =
                                    match __field6 {
                                        _serde::export::Some(__field6) =>
                                        __field6,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("reblog")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field7 =
                                    match __field7 {
                                        _serde::export::Some(__field7) =>
                                        __field7,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("content")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field8 =
                                    match __field8 {
                                        _serde::export::Some(__field8) =>
                                        __field8,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("created_at")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field9 =
                                    match __field9 {
                                        _serde::export::Some(__field9) =>
                                        __field9,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("emojis")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field10 =
                                    match __field10 {
                                        _serde::export::Some(__field10) =>
                                        __field10,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("replies_count")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field11 =
                                    match __field11 {
                                        _serde::export::Some(__field11) =>
                                        __field11,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("reblogs_count")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field12 =
                                    match __field12 {
                                        _serde::export::Some(__field12) =>
                                        __field12,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("favourites_count")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field13 =
                                    match __field13 {
                                        _serde::export::Some(__field13) =>
                                        __field13,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("reblogged")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field14 =
                                    match __field14 {
                                        _serde::export::Some(__field14) =>
                                        __field14,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("favourited")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field15 =
                                    match __field15 {
                                        _serde::export::Some(__field15) =>
                                        __field15,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("sensitive")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field16 =
                                    match __field16 {
                                        _serde::export::Some(__field16) =>
                                        __field16,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("spoiler_text")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field17 =
                                    match __field17 {
                                        _serde::export::Some(__field17) =>
                                        __field17,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("visibility")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field18 =
                                    match __field18 {
                                        _serde::export::Some(__field18) =>
                                        __field18,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("media_attachments")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field19 =
                                    match __field19 {
                                        _serde::export::Some(__field19) =>
                                        __field19,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("mentions")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field20 =
                                    match __field20 {
                                        _serde::export::Some(__field20) =>
                                        __field20,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("tags")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field21 =
                                    match __field21 {
                                        _serde::export::Some(__field21) =>
                                        __field21,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("card")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field22 =
                                    match __field22 {
                                        _serde::export::Some(__field22) =>
                                        __field22,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("application")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field23 =
                                    match __field23 {
                                        _serde::export::Some(__field23) =>
                                        __field23,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("language")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field24 =
                                    match __field24 {
                                        _serde::export::Some(__field24) =>
                                        __field24,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("pinned")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Status{id: __field0,
                                                          uri: __field1,
                                                          url: __field2,
                                                          account: __field3,
                                                          in_reply_to_id:
                                                              __field4,
                                                          in_reply_to_account_id:
                                                              __field5,
                                                          reblog: __field6,
                                                          content: __field7,
                                                          created_at:
                                                              __field8,
                                                          emojis: __field9,
                                                          replies_count:
                                                              __field10,
                                                          reblogs_count:
                                                              __field11,
                                                          favourites_count:
                                                              __field12,
                                                          reblogged:
                                                              __field13,
                                                          favourited:
                                                              __field14,
                                                          sensitive:
                                                              __field15,
                                                          spoiler_text:
                                                              __field16,
                                                          visibility:
                                                              __field17,
                                                          media_attachments:
                                                              __field18,
                                                          mentions: __field19,
                                                          tags: __field20,
                                                          card: __field21,
                                                          application:
                                                              __field22,
                                                          language: __field23,
                                                          pinned: __field24,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["id", "uri", "url", "account", "in_reply_to_id",
                              "in_reply_to_account_id", "reblog", "content",
                              "created_at", "emojis", "replies_count",
                              "reblogs_count", "favourites_count",
                              "reblogged", "favourited", "sensitive",
                              "spoiler_text", "visibility",
                              "media_attachments", "mentions", "tags", "card",
                              "application", "language", "pinned"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Status",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Status>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Status { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Status {
            #[inline]
            fn eq(&self, other: &Status) -> bool {
                match *other {
                    Status {
                    id: ref __self_1_0,
                    uri: ref __self_1_1,
                    url: ref __self_1_2,
                    account: ref __self_1_3,
                    in_reply_to_id: ref __self_1_4,
                    in_reply_to_account_id: ref __self_1_5,
                    reblog: ref __self_1_6,
                    content: ref __self_1_7,
                    created_at: ref __self_1_8,
                    emojis: ref __self_1_9,
                    replies_count: ref __self_1_10,
                    reblogs_count: ref __self_1_11,
                    favourites_count: ref __self_1_12,
                    reblogged: ref __self_1_13,
                    favourited: ref __self_1_14,
                    sensitive: ref __self_1_15,
                    spoiler_text: ref __self_1_16,
                    visibility: ref __self_1_17,
                    media_attachments: ref __self_1_18,
                    mentions: ref __self_1_19,
                    tags: ref __self_1_20,
                    card: ref __self_1_21,
                    application: ref __self_1_22,
                    language: ref __self_1_23,
                    pinned: ref __self_1_24 } =>
                    match *self {
                        Status {
                        id: ref __self_0_0,
                        uri: ref __self_0_1,
                        url: ref __self_0_2,
                        account: ref __self_0_3,
                        in_reply_to_id: ref __self_0_4,
                        in_reply_to_account_id: ref __self_0_5,
                        reblog: ref __self_0_6,
                        content: ref __self_0_7,
                        created_at: ref __self_0_8,
                        emojis: ref __self_0_9,
                        replies_count: ref __self_0_10,
                        reblogs_count: ref __self_0_11,
                        favourites_count: ref __self_0_12,
                        reblogged: ref __self_0_13,
                        favourited: ref __self_0_14,
                        sensitive: ref __self_0_15,
                        spoiler_text: ref __self_0_16,
                        visibility: ref __self_0_17,
                        media_attachments: ref __self_0_18,
                        mentions: ref __self_0_19,
                        tags: ref __self_0_20,
                        card: ref __self_0_21,
                        application: ref __self_0_22,
                        language: ref __self_0_23,
                        pinned: ref __self_0_24 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5) &&
                            (*__self_0_6) == (*__self_1_6) &&
                            (*__self_0_7) == (*__self_1_7) &&
                            (*__self_0_8) == (*__self_1_8) &&
                            (*__self_0_9) == (*__self_1_9) &&
                            (*__self_0_10) == (*__self_1_10) &&
                            (*__self_0_11) == (*__self_1_11) &&
                            (*__self_0_12) == (*__self_1_12) &&
                            (*__self_0_13) == (*__self_1_13) &&
                            (*__self_0_14) == (*__self_1_14) &&
                            (*__self_0_15) == (*__self_1_15) &&
                            (*__self_0_16) == (*__self_1_16) &&
                            (*__self_0_17) == (*__self_1_17) &&
                            (*__self_0_18) == (*__self_1_18) &&
                            (*__self_0_19) == (*__self_1_19) &&
                            (*__self_0_20) == (*__self_1_20) &&
                            (*__self_0_21) == (*__self_1_21) &&
                            (*__self_0_22) == (*__self_1_22) &&
                            (*__self_0_23) == (*__self_1_23) &&
                            (*__self_0_24) == (*__self_1_24),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Status) -> bool {
                match *other {
                    Status {
                    id: ref __self_1_0,
                    uri: ref __self_1_1,
                    url: ref __self_1_2,
                    account: ref __self_1_3,
                    in_reply_to_id: ref __self_1_4,
                    in_reply_to_account_id: ref __self_1_5,
                    reblog: ref __self_1_6,
                    content: ref __self_1_7,
                    created_at: ref __self_1_8,
                    emojis: ref __self_1_9,
                    replies_count: ref __self_1_10,
                    reblogs_count: ref __self_1_11,
                    favourites_count: ref __self_1_12,
                    reblogged: ref __self_1_13,
                    favourited: ref __self_1_14,
                    sensitive: ref __self_1_15,
                    spoiler_text: ref __self_1_16,
                    visibility: ref __self_1_17,
                    media_attachments: ref __self_1_18,
                    mentions: ref __self_1_19,
                    tags: ref __self_1_20,
                    card: ref __self_1_21,
                    application: ref __self_1_22,
                    language: ref __self_1_23,
                    pinned: ref __self_1_24 } =>
                    match *self {
                        Status {
                        id: ref __self_0_0,
                        uri: ref __self_0_1,
                        url: ref __self_0_2,
                        account: ref __self_0_3,
                        in_reply_to_id: ref __self_0_4,
                        in_reply_to_account_id: ref __self_0_5,
                        reblog: ref __self_0_6,
                        content: ref __self_0_7,
                        created_at: ref __self_0_8,
                        emojis: ref __self_0_9,
                        replies_count: ref __self_0_10,
                        reblogs_count: ref __self_0_11,
                        favourites_count: ref __self_0_12,
                        reblogged: ref __self_0_13,
                        favourited: ref __self_0_14,
                        sensitive: ref __self_0_15,
                        spoiler_text: ref __self_0_16,
                        visibility: ref __self_0_17,
                        media_attachments: ref __self_0_18,
                        mentions: ref __self_0_19,
                        tags: ref __self_0_20,
                        card: ref __self_0_21,
                        application: ref __self_0_22,
                        language: ref __self_0_23,
                        pinned: ref __self_0_24 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5) ||
                            (*__self_0_6) != (*__self_1_6) ||
                            (*__self_0_7) != (*__self_1_7) ||
                            (*__self_0_8) != (*__self_1_8) ||
                            (*__self_0_9) != (*__self_1_9) ||
                            (*__self_0_10) != (*__self_1_10) ||
                            (*__self_0_11) != (*__self_1_11) ||
                            (*__self_0_12) != (*__self_1_12) ||
                            (*__self_0_13) != (*__self_1_13) ||
                            (*__self_0_14) != (*__self_1_14) ||
                            (*__self_0_15) != (*__self_1_15) ||
                            (*__self_0_16) != (*__self_1_16) ||
                            (*__self_0_17) != (*__self_1_17) ||
                            (*__self_0_18) != (*__self_1_18) ||
                            (*__self_0_19) != (*__self_1_19) ||
                            (*__self_0_20) != (*__self_1_20) ||
                            (*__self_0_21) != (*__self_1_21) ||
                            (*__self_0_22) != (*__self_1_22) ||
                            (*__self_0_23) != (*__self_1_23) ||
                            (*__self_0_24) != (*__self_1_24),
                    },
                }
            }
        }
        /// A mention of another user.
        pub struct Mention {
            /// URL of user's profile (can be remote).
            pub url: String,
            /// The username of the account.
            pub username: String,
            /// Equals `username` for local users, includes `@domain` for remote ones.
            pub acct: String,
            /// Account ID.
            pub id: String,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Mention {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Mention {
                    url: ref __self_0_0,
                    username: ref __self_0_1,
                    acct: ref __self_0_2,
                    id: ref __self_0_3 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Mention");
                        let _ =
                            debug_trait_builder.field("url", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("username",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("acct",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Mention {
            #[inline]
            fn clone(&self) -> Mention {
                match *self {
                    Mention {
                    url: ref __self_0_0,
                    username: ref __self_0_1,
                    acct: ref __self_0_2,
                    id: ref __self_0_3 } =>
                    Mention{url: ::core::clone::Clone::clone(&(*__self_0_0)),
                            username:
                                ::core::clone::Clone::clone(&(*__self_0_1)),
                            acct: ::core::clone::Clone::clone(&(*__self_0_2)),
                            id: ::core::clone::Clone::clone(&(*__self_0_3)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Mention: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Mention {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 4")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "url" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "username" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "acct" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "id" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"url" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"username" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"acct" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"id" =>
                                    _serde::export::Ok(__Field::__field3),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Mention>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Mention;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Mention")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Mention with 4 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Mention with 4 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Mention with 4 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Mention with 4 elements"));
                                        }
                                    };
                                _serde::export::Ok(Mention{url: __field0,
                                                           username: __field1,
                                                           acct: __field2,
                                                           id: __field3,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("url"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("username"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("acct"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("id"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("username")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("acct")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("id")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Mention{url: __field0,
                                                           username: __field1,
                                                           acct: __field2,
                                                           id: __field3,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["url", "username", "acct", "id"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Mention",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Mention>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Mention { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Mention {
            #[inline]
            fn eq(&self, other: &Mention) -> bool {
                match *other {
                    Mention {
                    url: ref __self_1_0,
                    username: ref __self_1_1,
                    acct: ref __self_1_2,
                    id: ref __self_1_3 } =>
                    match *self {
                        Mention {
                        url: ref __self_0_0,
                        username: ref __self_0_1,
                        acct: ref __self_0_2,
                        id: ref __self_0_3 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Mention) -> bool {
                match *other {
                    Mention {
                    url: ref __self_1_0,
                    username: ref __self_1_1,
                    acct: ref __self_1_2,
                    id: ref __self_1_3 } =>
                    match *self {
                        Mention {
                        url: ref __self_0_0,
                        username: ref __self_0_1,
                        acct: ref __self_0_2,
                        id: ref __self_0_3 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3),
                    },
                }
            }
        }
        /// Struct representing an emoji within text.
        pub struct Emoji {
            /// The shortcode of the emoji
            pub shortcode: String,
            /// URL to the emoji static image
            pub static_url: String,
            /// URL to the emoji image
            pub url: String,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Emoji {
            #[inline]
            fn clone(&self) -> Emoji {
                match *self {
                    Emoji {
                    shortcode: ref __self_0_0,
                    static_url: ref __self_0_1,
                    url: ref __self_0_2 } =>
                    Emoji{shortcode:
                              ::core::clone::Clone::clone(&(*__self_0_0)),
                          static_url:
                              ::core::clone::Clone::clone(&(*__self_0_1)),
                          url: ::core::clone::Clone::clone(&(*__self_0_2)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Emoji {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Emoji {
                    shortcode: ref __self_0_0,
                    static_url: ref __self_0_1,
                    url: ref __self_0_2 } => {
                        let mut debug_trait_builder = f.debug_struct("Emoji");
                        let _ =
                            debug_trait_builder.field("shortcode",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("static_url",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("url", &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Emoji: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Emoji {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 3")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "shortcode" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "static_url" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "url" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"shortcode" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"static_url" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"url" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Emoji>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Emoji;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Emoji")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Emoji with 3 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Emoji with 3 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Emoji with 3 elements"));
                                        }
                                    };
                                _serde::export::Ok(Emoji{shortcode: __field0,
                                                         static_url: __field1,
                                                         url: __field2,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("shortcode"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("static_url"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("url"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("shortcode")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("static_url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Emoji{shortcode: __field0,
                                                         static_url: __field1,
                                                         url: __field2,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["shortcode", "static_url", "url"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Emoji",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Emoji>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Emoji { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Emoji {
            #[inline]
            fn eq(&self, other: &Emoji) -> bool {
                match *other {
                    Emoji {
                    shortcode: ref __self_1_0,
                    static_url: ref __self_1_1,
                    url: ref __self_1_2 } =>
                    match *self {
                        Emoji {
                        shortcode: ref __self_0_0,
                        static_url: ref __self_0_1,
                        url: ref __self_0_2 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Emoji) -> bool {
                match *other {
                    Emoji {
                    shortcode: ref __self_1_0,
                    static_url: ref __self_1_1,
                    url: ref __self_1_2 } =>
                    match *self {
                        Emoji {
                        shortcode: ref __self_0_0,
                        static_url: ref __self_0_1,
                        url: ref __self_0_2 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2),
                    },
                }
            }
        }
        /// Hashtags in the status.
        pub struct Tag {
            /// The hashtag, not including the preceding `#`.
            pub name: String,
            /// The URL of the hashtag.
            pub url: String,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Tag {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Tag { name: ref __self_0_0, url: ref __self_0_1 } => {
                        let mut debug_trait_builder = f.debug_struct("Tag");
                        let _ =
                            debug_trait_builder.field("name",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("url", &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Tag {
            #[inline]
            fn clone(&self) -> Tag {
                match *self {
                    Tag { name: ref __self_0_0, url: ref __self_0_1 } =>
                    Tag{name: ::core::clone::Clone::clone(&(*__self_0_0)),
                        url: ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Tag: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Tag {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field { __field0, __field1, __ignore, }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 2")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "name" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "url" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"name" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"url" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Tag>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Tag;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Tag")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Tag with 2 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Tag with 2 elements"));
                                        }
                                    };
                                _serde::export::Ok(Tag{name: __field0,
                                                       url: __field1,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("name"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("url"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("name")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Tag{name: __field0,
                                                       url: __field1,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["name", "url"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Tag",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Tag>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Tag { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Tag {
            #[inline]
            fn eq(&self, other: &Tag) -> bool {
                match *other {
                    Tag { name: ref __self_1_0, url: ref __self_1_1 } =>
                    match *self {
                        Tag { name: ref __self_0_0, url: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Tag) -> bool {
                match *other {
                    Tag { name: ref __self_1_0, url: ref __self_1_1 } =>
                    match *self {
                        Tag { name: ref __self_0_0, url: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        /// Application details.
        pub struct Application {
            /// Name of the application.
            pub name: String,
            /// Homepage URL of the application.
            pub website: Option<String>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Application {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Application {
                    name: ref __self_0_0, website: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("Application");
                        let _ =
                            debug_trait_builder.field("name",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("website",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Application {
            #[inline]
            fn clone(&self) -> Application {
                match *self {
                    Application {
                    name: ref __self_0_0, website: ref __self_0_1 } =>
                    Application{name:
                                    ::core::clone::Clone::clone(&(*__self_0_0)),
                                website:
                                    ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Application: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Application {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field { __field0, __field1, __ignore, }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type Value = __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 2")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "name" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "website" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"name" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"website" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Application>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type Value = Application;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Application")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Application with 2 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Application with 2 elements"));
                                        }
                                    };
                                _serde::export::Ok(Application{name: __field0,
                                                               website:
                                                                   __field1,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<String> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("name"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("website"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("name")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("website")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Application{name: __field0,
                                                               website:
                                                                   __field1,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["name", "website"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Application",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Application>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        impl ::core::marker::StructuralPartialEq for Application { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Application {
            #[inline]
            fn eq(&self, other: &Application) -> bool {
                match *other {
                    Application {
                    name: ref __self_1_0, website: ref __self_1_1 } =>
                    match *self {
                        Application {
                        name: ref __self_0_0, website: ref __self_0_1 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Application) -> bool {
                match *other {
                    Application {
                    name: ref __self_1_0, website: ref __self_1_1 } =>
                    match *self {
                        Application {
                        name: ref __self_0_0, website: ref __self_0_1 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
    }
    /// An empty JSON object.
    pub struct Empty {
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Empty: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl <'de> _serde::Deserialize<'de> for Empty {
                fn deserialize<__D>(__deserializer: __D)
                 -> _serde::export::Result<Self, __D::Error> where
                 __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    enum __Field { __ignore, }
                    struct __FieldVisitor;
                    impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                _ =>
                                _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                     &"field index 0 <= i < 0")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    impl <'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                         __FieldVisitor)
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Empty>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Empty;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "struct Empty")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, _: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::SeqAccess<'de> {
                            _serde::export::Ok(Empty{})
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::MapAccess<'de> {
                            while let _serde::export::Some(__key) =
                                      match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                match __key {
                                    _ => {
                                        let _ =
                                            match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                    }
                                }
                            }
                            _serde::export::Ok(Empty{})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                                                             "Empty", FIELDS,
                                                             __Visitor{marker:
                                                                           _serde::export::PhantomData::<Empty>,
                                                                       lifetime:
                                                                           _serde::export::PhantomData,})
                }
            }
        };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Empty {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Empty {  } => {
                    let mut debug_trait_builder = f.debug_struct("Empty");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Empty { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Empty {
        #[inline]
        fn clone(&self) -> Empty { { *self } }
    }
    impl ::core::marker::StructuralPartialEq for Empty { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Empty {
        #[inline]
        fn eq(&self, other: &Empty) -> bool {
            match *other {
                Empty {  } => match *self { Empty {  } => true, },
            }
        }
    }
    /// The purpose of this module is to alleviate imports of many common
    /// structs by adding a glob import to the top of mastodon heavy
    /// modules:
    pub mod prelude {
        pub use super::{account::{Account, Source},
                        attachment::{Attachment, MediaType}, card::Card,
                        context::Context, event::Event,
                        filter::{Filter, FilterContext}, instance::*,
                        list::List, mention::Mention,
                        notification::Notification, push::Subscription,
                        relationship::Relationship, report::Report,
                        search_result::{SearchResult, SearchResultV2},
                        status::{Application, Emoji, Status}, Empty};
    }
}
/// Errors
pub mod errors {
    use std::{error, fmt, io::Error as IoError};
    use hyper_old_types::Error as HeaderParseError;
    use reqwest::{header::ToStrError as HeaderStrError, Error as HttpError,
                  StatusCode};
    use serde_json::Error as SerdeError;
    use serde_qs::Error as SerdeQsError;
    use serde_urlencoded::ser::Error as UrlEncodedError;
    use url::ParseError as UrlError;
    use tungstenite::error::Error as WebSocketError;
    /// Convience type over `std::result::Result` with `Error` as the error type.
    pub type Result<T> = ::std::result::Result<T, Error>;
    /// enum of possible errors encountered using the mastodon API.
    pub enum Error {

        /// Error from the Mastodon API. This typically means something went
        /// wrong with your authentication or data.
        Api(ApiError),

        /// Error deserialising to json. Typically represents a breaking change in
        /// the Mastodon API
        Serde(SerdeError),

        /// Error serializing to url-encoded string
        UrlEncoded(UrlEncodedError),

        /// Error encountered in the HTTP backend while requesting a route.
        Http(HttpError),

        /// Wrapper around the `std::io::Error` struct.
        Io(IoError),

        /// Wrapper around the `url::ParseError` struct.
        Url(UrlError),

        /// Missing Client Id.
        ClientIdRequired,

        /// Missing Client Secret.
        ClientSecretRequired,

        /// Missing Access Token.
        AccessTokenRequired,

        /// Generic client error.
        Client(StatusCode),

        /// Generic server error.
        Server(StatusCode),

        /// MastodonBuilder & AppBuilder error
        MissingField(&'static str),

        /// Error converting an http header to a string
        HeaderStrError(HeaderStrError),

        /// Error parsing the http Link header
        HeaderParseError(HeaderParseError),

        /// Error serializing to a query string
        SerdeQs(SerdeQsError),

        /// WebSocket error
        WebSocket(WebSocketError),

        /// Other errors
        Other(String),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Error::Api(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Api");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::Serde(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Serde");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::UrlEncoded(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("UrlEncoded");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::Http(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Http");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::Io(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Io");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::Url(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Url");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::ClientIdRequired,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("ClientIdRequired");
                    debug_trait_builder.finish()
                }
                (&Error::ClientSecretRequired,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("ClientSecretRequired");
                    debug_trait_builder.finish()
                }
                (&Error::AccessTokenRequired,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("AccessTokenRequired");
                    debug_trait_builder.finish()
                }
                (&Error::Client(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Client");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::Server(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Server");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::MissingField(ref __self_0),) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("MissingField");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::HeaderStrError(ref __self_0),) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("HeaderStrError");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::HeaderParseError(ref __self_0),) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("HeaderParseError");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::SerdeQs(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("SerdeQs");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::WebSocket(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("WebSocket");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Error::Other(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Other");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl fmt::Display for Error {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                       &match (&self,) {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Debug::fmt)],
                                                        }))
        }
    }
    impl error::Error for Error {
        fn source(&self) -> Option<&(dyn error::Error + 'static)> {
            Some(match *self {
                     Error::Api(ref e) => e,
                     Error::Serde(ref e) => e,
                     Error::UrlEncoded(ref e) => e,
                     Error::Http(ref e) => e,
                     Error::Io(ref e) => e,
                     Error::Url(ref e) => e,
                     Error::HeaderStrError(ref e) => e,
                     Error::HeaderParseError(ref e) => e,
                     Error::SerdeQs(ref e) => e,
                     Error::WebSocket(ref e) => e,
                     Error::Client(..) | Error::Server(..) => { return None }
                     Error::ClientIdRequired => return None,
                     Error::ClientSecretRequired => return None,
                     Error::AccessTokenRequired => return None,
                     Error::MissingField(_) => return None,
                     Error::Other(..) => return None,
                 })
        }
    }
    /// Error returned from the Mastodon API.
    pub struct ApiError {
        /// The type of error.
        pub error: Option<String>,
        /// The description of the error.
        pub error_description: Option<String>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ApiError {
        #[inline]
        fn clone(&self) -> ApiError {
            match *self {
                ApiError {
                error: ref __self_0_0, error_description: ref __self_0_1 } =>
                ApiError{error: ::core::clone::Clone::clone(&(*__self_0_0)),
                         error_description:
                             ::core::clone::Clone::clone(&(*__self_0_1)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ApiError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                ApiError {
                error: ref __self_0_0, error_description: ref __self_0_1 } =>
                {
                    let mut debug_trait_builder = f.debug_struct("ApiError");
                    let _ =
                        debug_trait_builder.field("error", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("error_description",
                                                  &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_ApiError: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl <'de> _serde::Deserialize<'de> for ApiError {
                fn deserialize<__D>(__deserializer: __D)
                 -> _serde::export::Result<Self, __D::Error> where
                 __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    enum __Field { __field0, __field1, __ignore, }
                    struct __FieldVisitor;
                    impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ =>
                                _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                     &"field index 0 <= i < 2")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                "error" =>
                                _serde::export::Ok(__Field::__field0),
                                "error_description" =>
                                _serde::export::Ok(__Field::__field1),
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                b"error" =>
                                _serde::export::Ok(__Field::__field0),
                                b"error_description" =>
                                _serde::export::Ok(__Field::__field1),
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    impl <'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                         __FieldVisitor)
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<ApiError>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ApiError;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "struct ApiError")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                     &"struct ApiError with 2 elements"));
                                    }
                                };
                            let __field1 =
                                match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                     &"struct ApiError with 2 elements"));
                                    }
                                };
                            _serde::export::Ok(ApiError{error: __field0,
                                                        error_description:
                                                            __field1,})
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::MapAccess<'de> {
                            let mut __field0:
                                    _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1:
                                    _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                      match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("error"));
                                        }
                                        __field0 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("error_description"));
                                        }
                                        __field1 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    _ => {
                                        let _ =
                                            match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::export::Some(__field0) =>
                                    __field0,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("error")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            let __field1 =
                                match __field1 {
                                    _serde::export::Some(__field1) =>
                                    __field1,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("error_description")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            _serde::export::Ok(ApiError{error: __field0,
                                                        error_description:
                                                            __field1,})
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["error", "error_description"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                                                             "ApiError",
                                                             FIELDS,
                                                             __Visitor{marker:
                                                                           _serde::export::PhantomData::<ApiError>,
                                                                       lifetime:
                                                                           _serde::export::PhantomData,})
                }
            }
        };
    impl fmt::Display for ApiError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                       &match (&self,) {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Debug::fmt)],
                                                        }))
        }
    }
    impl error::Error for ApiError { }
    macro_rules! from {
        ($ ($ (# [$ met : meta]) * $ typ : ident, $ variant : ident,) *) =>
        {
            $
            ($ (# [$ met]) * impl From < $ typ > for Error
             {
                 fn from(from : $ typ) -> Self
                 { use crate :: Error :: * ; $ variant(from) }
             }) *
        }
    }
    impl From<HttpError> for Error {
        fn from(from: HttpError) -> Self {
            use crate::Error::*;
            Http(from)
        }
    }
    impl From<IoError> for Error {
        fn from(from: IoError) -> Self {
            use crate::Error::*;
            Io(from)
        }
    }
    impl From<SerdeError> for Error {
        fn from(from: SerdeError) -> Self {
            use crate::Error::*;
            Serde(from)
        }
    }
    impl From<UrlEncodedError> for Error {
        fn from(from: UrlEncodedError) -> Self {
            use crate::Error::*;
            UrlEncoded(from)
        }
    }
    impl From<UrlError> for Error {
        fn from(from: UrlError) -> Self {
            use crate::Error::*;
            Url(from)
        }
    }
    impl From<ApiError> for Error {
        fn from(from: ApiError) -> Self {
            use crate::Error::*;
            Api(from)
        }
    }
    impl From<HeaderStrError> for Error {
        fn from(from: HeaderStrError) -> Self {
            use crate::Error::*;
            HeaderStrError(from)
        }
    }
    impl From<HeaderParseError> for Error {
        fn from(from: HeaderParseError) -> Self {
            use crate::Error::*;
            HeaderParseError(from)
        }
    }
    impl From<SerdeQsError> for Error {
        fn from(from: SerdeQsError) -> Self {
            use crate::Error::*;
            SerdeQs(from)
        }
    }
    impl From<WebSocketError> for Error {
        fn from(from: WebSocketError) -> Self {
            use crate::Error::*;
            WebSocket(from)
        }
    }
    impl From<String> for Error {
        fn from(from: String) -> Self {
            use crate::Error::*;
            Other(from)
        }
    }
    #[macro_export]
    /// Used to easily create errors from strings
    macro_rules! format_err {
        ($ ($ arg : tt) *) =>
        { { use elefren :: Error ; Error :: Other(format ! ($ ($ arg) *)) } }
    }
}
/// Collection of helpers for serializing/deserializing `Data` objects
pub mod helpers {
    /// Helpers for working with the command line
    pub mod cli {
        use std::io::{self, BufRead, Write};
        use crate::errors::Result;
        use crate::registration::Registered;
        use crate::Mastodon;
        /// Finishes the authentication process for the given `Registered` object,
        /// using the command-line
        pub fn authenticate(registration: Registered) -> Result<Mastodon> {
            let url = registration.authorize_url()?;
            let stdout = io::stdout();
            let stdin = io::stdin();
            let mut stdout = stdout.lock();
            let mut stdin = stdin.lock();
            (&mut stdout).write_fmt(::core::fmt::Arguments::new_v1(&["Click this link to authorize: ",
                                                                     "\n"],
                                                                   &match (&url,)
                                                                        {
                                                                        (arg0,)
                                                                        =>
                                                                        [::core::fmt::ArgumentV1::new(arg0,
                                                                                                      ::core::fmt::Display::fmt)],
                                                                    }))?;
            (&mut stdout).write_fmt(::core::fmt::Arguments::new_v1(&["Paste the returned authorization code: "],
                                                                   &match () {
                                                                        () =>
                                                                        [],
                                                                    }))?;
            stdout.flush()?;
            let mut input = String::new();
            stdin.read_line(&mut input)?;
            let code = input.trim();
            Ok(registration.complete(code)?)
        }
    }
}
mod mastodon_client {
    use async_trait::async_trait;
    use std::borrow::Cow;
    use crate::entities::prelude::*;
    use crate::errors::Result;
    use crate::page::Page;
    use crate::requests::{AddFilterRequest, AddPushRequest, StatusesRequest,
                          UpdateCredsRequest, UpdatePushRequest};
    use crate::status_builder::NewStatus;
    #[doc =
      " Represents the set of methods that a Mastodon Client can do, so that"]
    #[doc = " implementations might be swapped out for testing"]
    #[allow(unused)]
    pub trait MastodonClient {
        #[doc = " GET /api/v1/favourites"]
        #[must_use]
        fn favourites<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Status>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __favourites<AsyncTrait: ?Sized + MastodonClient +
                                  ::core::marker::Sync>(_self: &AsyncTrait)
             -> Result<Page<'_, Status>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__favourites::<Self>(self))
        }
        #[doc = " GET /api/v1/blocks"]
        #[must_use]
        fn blocks<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Account>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __blocks<AsyncTrait: ?Sized + MastodonClient +
                              ::core::marker::Sync>(_self: &AsyncTrait)
             -> Result<Page<'_, Account>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__blocks::<Self>(self))
        }
        #[doc = " GET /api/v1/domain_blocks"]
        #[must_use]
        fn domain_blocks<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         String>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __domain_blocks<AsyncTrait: ?Sized + MastodonClient +
                                     ::core::marker::Sync>(_self: &AsyncTrait)
             -> Result<Page<'_, String>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__domain_blocks::<Self>(self))
        }
        #[doc = " GET /api/v1/follow_requests"]
        #[must_use]
        fn follow_requests<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Account>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __follow_requests<AsyncTrait: ?Sized + MastodonClient +
                                       ::core::marker::Sync>(_self:
                                                                 &AsyncTrait)
             -> Result<Page<'_, Account>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__follow_requests::<Self>(self))
        }
        #[doc = " GET /api/v1/timelines/home"]
        #[must_use]
        fn get_home_timeline<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Status>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __get_home_timeline<AsyncTrait: ?Sized + MastodonClient +
                                         ::core::marker::Sync>(_self:
                                                                   &AsyncTrait)
             -> Result<Page<'_, Status>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__get_home_timeline::<Self>(self))
        }
        #[doc = " GET /api/v1/custom_emojis"]
        #[must_use]
        fn get_emojis<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Emoji>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __get_emojis<AsyncTrait: ?Sized + MastodonClient +
                                  ::core::marker::Sync>(_self: &AsyncTrait)
             -> Result<Page<'_, Emoji>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__get_emojis::<Self>(self))
        }
        #[doc = " GET /api/v1/mutes"]
        #[must_use]
        fn mutes<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Account>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __mutes<AsyncTrait: ?Sized + MastodonClient +
                             ::core::marker::Sync>(_self: &AsyncTrait)
             -> Result<Page<'_, Account>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__mutes::<Self>(self))
        }
        #[doc = " GET /api/v1/notifications"]
        #[must_use]
        fn notifications<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Notification>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __notifications<AsyncTrait: ?Sized + MastodonClient +
                                     ::core::marker::Sync>(_self: &AsyncTrait)
             -> Result<Page<'_, Notification>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__notifications::<Self>(self))
        }
        #[doc = " GET /api/v1/reports"]
        #[must_use]
        fn reports<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Report>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __reports<AsyncTrait: ?Sized + MastodonClient +
                               ::core::marker::Sync>(_self: &AsyncTrait)
             -> Result<Page<'_, Report>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__reports::<Self>(self))
        }
        #[doc = " GET /api/v1/accounts/:id/followers"]
        fn followers(&self, id: &str) -> Result<Page<Account>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/accounts/:id/following"]
        fn following(&self, id: &str) -> Result<Page<Account>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/statuses/:id/reblogged_by"]
        fn reblogged_by(&self, id: &str) -> Result<Page<Account>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/statuses/:id/favourited_by"]
        fn favourited_by(&self, id: &str) -> Result<Page<Account>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " DELETE /api/v1/domain_blocks"]
        fn unblock_domain(&self, domain: String) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/instance"]
        fn instance(&self) -> Result<Instance> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/accounts/verify_credentials"]
        fn verify_credentials(&self) -> Result<Account> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/reports"]
        fn report(&self, account_id: &str, status_ids: Vec<&str>,
                  comment: String) -> Result<Report> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/domain_blocks"]
        fn block_domain(&self, domain: String) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/accounts/follow_requests/authorize"]
        fn authorize_follow_request(&self, id: &str) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/accounts/follow_requests/reject"]
        fn reject_follow_request(&self, id: &str) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/search"]
        fn search<'a>(&self, q: &'a str, resolve: bool)
         -> Result<SearchResult> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v2/search"]
        fn search_v2<'a>(&self, q: &'a str, resolve: bool)
         -> Result<SearchResultV2> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/follows"]
        fn follows(&self, uri: Cow<'static, str>) -> Result<Account> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/media"]
        fn media(&self, file: Cow<'static, str>) -> Result<Attachment> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/notifications/clear"]
        fn clear_notifications(&self) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/notifications/dismiss"]
        fn dismiss_notification(&self, id: &str) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/accounts/:id"]
        fn get_account(&self, id: &str) -> Result<Account> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/accounts/:id/follow"]
        fn follow(&self, id: &str) -> Result<Relationship> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/accounts/:id/unfollow"]
        fn unfollow(&self, id: &str) -> Result<Relationship> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/accounts/:id/block"]
        fn block(&self, id: &str) -> Result<Relationship> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/accounts/:id/unblock"]
        fn unblock(&self, id: &str) -> Result<Relationship> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/accounts/:id/mute"]
        fn mute(&self, id: &str) -> Result<Relationship> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/accounts/:id/unmute"]
        fn unmute(&self, id: &str) -> Result<Relationship> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/notifications/:id"]
        fn get_notification(&self, id: &str) -> Result<Notification> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/statuses/:id"]
        fn get_status(&self, id: &str) -> Result<Status> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/statuses/:id/context"]
        fn get_context(&self, id: &str) -> Result<Context> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/statuses/:id/card"]
        fn get_card(&self, id: &str) -> Result<Card> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/statuses/:id/reblog"]
        fn reblog(&self, id: &str) -> Result<Status> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/statuses/:id/unreblog"]
        fn unreblog(&self, id: &str) -> Result<Status> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/statuses/:id/favourite"]
        fn favourite(&self, id: &str) -> Result<Status> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/statuses/:id/unfavourite"]
        fn unfavourite(&self, id: &str) -> Result<Status> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " DELETE /api/v1/statuses/:id"]
        fn delete_status(&self, id: &str) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " PATCH /api/v1/accounts/update_credentials"]
        fn update_credentials(&self, builder: &mut UpdateCredsRequest)
         -> Result<Account> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/statuses"]
        fn new_status(&self, status: NewStatus) -> Result<Status> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/timelines/public"]
        fn get_public_timeline(&self, local: bool) -> Result<Vec<Status>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/timelines/tag/:hashtag"]
        fn get_tagged_timeline(&self, hashtag: String, local: bool)
         -> Result<Vec<Status>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/accounts/:id/statuses"]
        fn statuses<'a, 'b: 'a, S>(&'b self, id: &'b str, request: S)
         -> Result<Page<Status>> where S: Into<Option<StatusesRequest<'a>>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/accounts/relationships"]
        fn relationships(&self, ids: &[&str]) -> Result<Page<Relationship>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc =
          " GET /api/v1/accounts/search?q=:query&limit=:limit&following=:following"]
        #[must_use]
        fn search_accounts<'life0, 'life1,
                           'async_trait>(&'life0 self, query: &'life1 str,
                                         limit: Option<u64>, following: bool)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Account>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, 'life1: 'async_trait,
         Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __search_accounts<AsyncTrait: ?Sized + MastodonClient +
                                       ::core::marker::Sync>(_self:
                                                                 &AsyncTrait,
                                                             query: &str,
                                                             limit:
                                                                 Option<u64>,
                                                             following: bool)
             -> Result<Page<'_, Account>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__search_accounts::<Self>(self, query, limit, following))
        }
        #[doc = " POST /api/v1/push/subscription"]
        fn add_push_subscription(&self, request: &AddPushRequest)
         -> Result<Subscription> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " PUT /api/v1/push/subscription"]
        fn update_push_data(&self, request: &UpdatePushRequest)
         -> Result<Subscription> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/push/subscription"]
        fn get_push_subscription(&self) -> Result<Subscription> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " DELETE /api/v1/push/subscription"]
        fn delete_push_subscription(&self) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/filters"]
        fn get_filters(&self) -> Result<Vec<Filter>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/filters"]
        fn add_filter(&self, request: &mut AddFilterRequest)
         -> Result<Filter> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/filters/:id"]
        fn get_filter(&self, id: &str) -> Result<Filter> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " PUT /api/v1/filters/:id"]
        fn update_filter(&self, id: &str, request: &mut AddFilterRequest)
         -> Result<Filter> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " DELETE /api/v1/filters/:id"]
        fn delete_filter(&self, id: &str) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/suggestions"]
        fn get_follow_suggestions(&self) -> Result<Vec<Account>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " DELETE /api/v1/suggestions/:account_id"]
        fn delete_from_suggestions(&self, id: &str) -> Result<Empty> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " GET /api/v1/endorsements"]
        #[must_use]
        fn get_endorsements<'life0, 'async_trait>(&'life0 self)
         ->
             ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                                                             Result<Page<'_,
                                                                         Account>>> +
                                  ::core::marker::Send + 'async_trait>> where
         'life0: 'async_trait, Self: ::core::marker::Sync + 'async_trait {
            #[allow(clippy :: missing_docs_in_private_items, clippy ::
                    type_repetition_in_bounds, clippy ::
                    used_underscore_binding,)]
            async fn __get_endorsements<AsyncTrait: ?Sized + MastodonClient +
                                        ::core::marker::Sync>(_self:
                                                                  &AsyncTrait)
             -> Result<Page<'_, Account>> {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                               &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                       &match ()
                                                                                                                            {
                                                                                                                            ()
                                                                                                                            =>
                                                                                                                            [],
                                                                                                                        }),)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }))
                };
            }
            Box::pin(__get_endorsements::<Self>(self))
        }
        #[doc = " POST /api/v1/accounts/:id/pin"]
        fn endorse_user(&self, id: &str) -> Result<Relationship> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " POST /api/v1/accounts/:id/unpin"]
        fn unendorse_user(&self, id: &str) -> Result<Relationship> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc =
          " Shortcut for: `let me = client.verify_credentials(); client.followers()`"]
        #[doc = ""]
        #[doc = " ```no_run"]
        #[doc = " # extern crate elefren;"]
        #[doc = " # use std::error::Error;"]
        #[doc = " # use elefren::prelude::*;"]
        #[doc = " # fn main() -> Result<(), Box<Error>> {"]
        #[doc = " # let data = Data {"]
        #[doc = " #   base: \"\".into(),"]
        #[doc = " #   client_id: \"\".into(),"]
        #[doc = " #   client_secret: \"\".into(),"]
        #[doc = " #   redirect: \"\".into(),"]
        #[doc = " #   token: \"\".into(),"]
        #[doc = " # };"]
        #[doc = " # let client = Mastodon::from(data);"]
        #[doc = " let follows_me = client.follows_me()?;"]
        #[doc = " #   Ok(())"]
        #[doc = " # }"]
        fn follows_me(&self) -> Result<Page<Account>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        #[doc = " Shortcut for"]
        #[doc =
          " `let me = client.verify_credentials(); client.following(&me.id)`"]
        #[doc = ""]
        #[doc = " ```no_run"]
        #[doc = " # extern crate elefren;"]
        #[doc = " # use std::error::Error;"]
        #[doc = " # use elefren::prelude::*;"]
        #[doc = " # fn main() -> Result<(), Box<Error>> {"]
        #[doc = " # let data = Data {"]
        #[doc = " #   base: \"\".into(),"]
        #[doc = " #   client_id: \"\".into(),"]
        #[doc = " #   client_secret: \"\".into(),"]
        #[doc = " #   redirect: \"\".into(),"]
        #[doc = " #   token: \"\".into(),"]
        #[doc = " # };"]
        #[doc = " # let client = Mastodon::from(data);"]
        #[doc = " let follows_me = client.followed_by_me()?;"]
        #[doc = " #   Ok(())"]
        #[doc = " # }"]
        fn followed_by_me(&self) -> Result<Page<Account>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
    }
    /// Trait that represents clients that can make unauthenticated calls to a
    /// mastodon instance
    #[allow(unused)]
    pub trait MastodonUnauthenticated {
        /// GET /api/v1/statuses/:id
        fn get_status(&self, id: &str) -> Result<Status> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        /// GET /api/v1/statuses/:id/context
        fn get_context(&self, id: &str) -> Result<Context> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        /// GET /api/v1/statuses/:id/card
        fn get_card(&self, id: &str) -> Result<Card> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        /// GET /api/v1/statuses/:id/reblogged_by
        fn reblogged_by(&self, id: &str) -> Result<Page<Account>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
        /// GET /api/v1/statuses/:id/favourited_by
        fn favourited_by(&self, id: &str) -> Result<Page<Account>> {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(&["not implemented: "],
                                                                           &match (&::core::fmt::Arguments::new_v1(&["This method was not implemented"],
                                                                                                                   &match ()
                                                                                                                        {
                                                                                                                        ()
                                                                                                                        =>
                                                                                                                        [],
                                                                                                                    }),)
                                                                                {
                                                                                (arg0,)
                                                                                =>
                                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                                              ::core::fmt::Display::fmt)],
                                                                            }))
            };
        }
    }
}
/// Handling multiple pages of entities.
pub mod page {
    use super::{deserialise, Mastodon, Result};
    use hyper_old_types::header::{parsing, Link, RelationType};
    use reqwest::{header::LINK, Response};
    use serde::Deserialize;
    use url::Url;
    macro_rules! pages {
        ($ ($ direction : ident : $ fun : ident), *) =>
        {
            $
            (doc_comment !
             (concat !
              ("Method to retrieve the ", stringify ! ($ direction),
               " page of results"), pub async fn $ fun(& mut self) -> Result <
              Option < Vec < T >> >
              {
                  let url = match self . $ direction . take()
                  { Some(s) => s, None => return Ok(None), } ; let response =
                  self . mastodon . send(self . mastodon . client . get(url))
                  ? ; let(prev, next) = get_links(& response) ? ; self . next
                  = next ; self . prev = prev ; deserialise(response)
              }) ;) *
        }
    }
    /// Owned version of the `Page` struct in this module. Allows this to be more
    /// easily stored for later use
    ///
    /// # Example
    ///
    /// ```no_run
    /// # extern crate elefren;
    /// # use elefren::Mastodon;
    /// # use elefren::page::OwnedPage;
    /// # use elefren::entities::status::Status;
    /// # use std::cell::RefCell;
    /// # use elefren::prelude::*;
    /// # fn main() -> Result<(), elefren::Error> {
    /// # let data = Data {
    /// #   base: "".into(),
    /// #   client_id: "".into(),
    /// #   client_secret: "".into(),
    /// #   redirect: "".into(),
    /// #   token: "".into(),
    /// # };
    /// struct HomeTimeline {
    ///     client: Mastodon,
    ///     page: RefCell<Option<OwnedPage<Status>>>,
    /// }
    /// let client = Mastodon::from(data);
    /// let home = client.get_home_timeline()?.to_owned();
    /// let tl = HomeTimeline {
    ///     client,
    ///     page: RefCell::new(Some(home)),
    /// };
    /// # Ok(())
    /// # }
    /// ```
    pub struct OwnedPage<T: for<'de> Deserialize<'de>> {
        mastodon: Mastodon,
        next: Option<Url>,
        prev: Option<Url>,
        /// Initial set of items
        pub initial_items: Vec<T>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::fmt::Debug + for<'de> Deserialize<'de>>
     ::core::fmt::Debug for OwnedPage<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                OwnedPage {
                mastodon: ref __self_0_0,
                next: ref __self_0_1,
                prev: ref __self_0_2,
                initial_items: ref __self_0_3 } => {
                    let mut debug_trait_builder = f.debug_struct("OwnedPage");
                    let _ =
                        debug_trait_builder.field("mastodon",
                                                  &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("next", &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("prev", &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("initial_items",
                                                  &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <T: ::core::clone::Clone + for<'de> Deserialize<'de>>
     ::core::clone::Clone for OwnedPage<T> {
        #[inline]
        fn clone(&self) -> OwnedPage<T> {
            match *self {
                OwnedPage {
                mastodon: ref __self_0_0,
                next: ref __self_0_1,
                prev: ref __self_0_2,
                initial_items: ref __self_0_3 } =>
                OwnedPage{mastodon:
                              ::core::clone::Clone::clone(&(*__self_0_0)),
                          next: ::core::clone::Clone::clone(&(*__self_0_1)),
                          prev: ::core::clone::Clone::clone(&(*__self_0_2)),
                          initial_items:
                              ::core::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    impl <T: for<'de> Deserialize<'de>> OwnedPage<T> {
        #[doc = "Method to retrieve the next page of results"]
        pub async fn next_page(&mut self) -> Result<Option<Vec<T>>> {
            let url =
                match self.next.take() {
                    Some(s) => s,
                    None => return Ok(None),
                };
            let response = self.mastodon.send(self.mastodon.client.get(url))?;
            let (prev, next) = get_links(&response)?;
            self.next = next;
            self.prev = prev;
            deserialise(response)
        }
        #[doc = "Method to retrieve the prev page of results"]
        pub async fn prev_page(&mut self) -> Result<Option<Vec<T>>> {
            let url =
                match self.prev.take() {
                    Some(s) => s,
                    None => return Ok(None),
                };
            let response = self.mastodon.send(self.mastodon.client.get(url))?;
            let (prev, next) = get_links(&response)?;
            self.next = next;
            self.prev = prev;
            deserialise(response)
        }
    }
    impl <'a, T: for<'de> Deserialize<'de>> From<Page<'a, T>> for OwnedPage<T>
     {
        fn from(page: Page<'a, T>) -> OwnedPage<T> {
            OwnedPage{mastodon: page.mastodon.clone(),
                      next: page.next,
                      prev: page.prev,
                      initial_items: page.initial_items,}
        }
    }
    /// Represents a single page of API results
    pub struct Page<'a, T: for<'de> Deserialize<'de>> {
        mastodon: &'a Mastodon,
        next: Option<Url>,
        prev: Option<Url>,
        /// Initial set of items
        pub initial_items: Vec<T>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <'a, T: ::core::fmt::Debug + for<'de> Deserialize<'de>>
     ::core::fmt::Debug for Page<'a, T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Page {
                mastodon: ref __self_0_0,
                next: ref __self_0_1,
                prev: ref __self_0_2,
                initial_items: ref __self_0_3 } => {
                    let mut debug_trait_builder = f.debug_struct("Page");
                    let _ =
                        debug_trait_builder.field("mastodon",
                                                  &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("next", &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("prev", &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("initial_items",
                                                  &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <'a, T: ::core::clone::Clone + for<'de> Deserialize<'de>>
     ::core::clone::Clone for Page<'a, T> {
        #[inline]
        fn clone(&self) -> Page<'a, T> {
            match *self {
                Page {
                mastodon: ref __self_0_0,
                next: ref __self_0_1,
                prev: ref __self_0_2,
                initial_items: ref __self_0_3 } =>
                Page{mastodon: ::core::clone::Clone::clone(&(*__self_0_0)),
                     next: ::core::clone::Clone::clone(&(*__self_0_1)),
                     prev: ::core::clone::Clone::clone(&(*__self_0_2)),
                     initial_items:
                         ::core::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    impl <'a, T: for<'de> Deserialize<'de>> Page<'a, T> {
        #[doc = "Method to retrieve the next page of results"]
        pub async fn next_page(&mut self) -> Result<Option<Vec<T>>> {
            let url =
                match self.next.take() {
                    Some(s) => s,
                    None => return Ok(None),
                };
            let response = self.mastodon.send(self.mastodon.client.get(url))?;
            let (prev, next) = get_links(&response)?;
            self.next = next;
            self.prev = prev;
            deserialise(response)
        }
        #[doc = "Method to retrieve the prev page of results"]
        pub async fn prev_page(&mut self) -> Result<Option<Vec<T>>> {
            let url =
                match self.prev.take() {
                    Some(s) => s,
                    None => return Ok(None),
                };
            let response = self.mastodon.send(self.mastodon.client.get(url))?;
            let (prev, next) = get_links(&response)?;
            self.next = next;
            self.prev = prev;
            deserialise(response)
        }
        pub(crate) fn new(mastodon: &'a Mastodon, response: Response)
         -> Result<Self> {
            let (prev, next) = get_links(&response)?;
            Ok(Page{initial_items: deserialise(response)?,
                    next,
                    prev,
                    mastodon,})
        }
    }
    impl <'a, T: Clone + for<'de> Deserialize<'de>> Page<'a, T> {
        /// Returns an owned version of this struct that doesn't borrow the client
        /// that created it
        ///
        /// # Example
        ///
        /// ```no_run
        /// # extern crate elefren;
        /// # use elefren::Mastodon;
        /// # use elefren::page::OwnedPage;
        /// # use elefren::entities::status::Status;
        /// # use std::cell::RefCell;
        /// # use elefren::prelude::*;
        /// # fn main() -> Result<(), elefren::Error> {
        /// # let data = Data {
        /// #   base: "".into(),
        /// #   client_id: "".into(),
        /// #   client_secret: "".into(),
        /// #   redirect: "".into(),
        /// #   token: "".into(),
        /// # };
        /// struct HomeTimeline {
        ///     client: Mastodon,
        ///     page: RefCell<Option<OwnedPage<Status>>>,
        /// }
        /// let client = Mastodon::from(data);
        /// let home = client.get_home_timeline()?.to_owned();
        /// let tl = HomeTimeline {
        ///     client,
        ///     page: RefCell::new(Some(home)),
        /// };
        /// # Ok(())
        /// # }
        /// ```
        pub fn to_owned(self) -> OwnedPage<T> { OwnedPage::from(self) }
    }
    fn get_links(response: &Response) -> Result<(Option<Url>, Option<Url>)> {
        let mut prev = None;
        let mut next = None;
        if let Some(link_header) = response.headers().get(LINK) {
            let link_header = link_header.to_str()?;
            let link_header = link_header.as_bytes();
            let link_header: Link = parsing::from_raw_str(&link_header)?;
            for value in link_header.values() {
                if let Some(relations) = value.rel() {
                    if relations.contains(&RelationType::Next) {
                        next = Some(Url::parse(value.link())?);
                    }
                    if relations.contains(&RelationType::Prev) {
                        prev = Some(Url::parse(value.link())?);
                    }
                }
            }
        }
        Ok((prev, next))
    }
}
/// Registering your app.
pub mod registration {
    use std::borrow::Cow;
    use reqwest::{Client, RequestBuilder, Response};
    use try_from::TryInto;
    use url::percent_encoding::{utf8_percent_encode, DEFAULT_ENCODE_SET};
    use crate::apps::{App, AppBuilder};
    use crate::scopes::Scopes;
    use crate::Data;
    use crate::Error;
    use crate::Mastodon;
    use crate::MastodonBuilder;
    use crate::Result;
    const DEFAULT_REDIRECT_URI: &'static str = "urn:ietf:wg:oauth:2.0:oob";
    /// Handles registering your mastodon app to your instance. It is recommended
    /// you cache your data struct to avoid registering on every run.
    pub struct Registration<'a> {
        base: String,
        client: Client,
        app_builder: AppBuilder<'a>,
        force_login: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <'a> ::core::fmt::Debug for Registration<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Registration {
                base: ref __self_0_0,
                client: ref __self_0_1,
                app_builder: ref __self_0_2,
                force_login: ref __self_0_3 } => {
                    let mut debug_trait_builder =
                        f.debug_struct("Registration");
                    let _ =
                        debug_trait_builder.field("base", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("client", &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("app_builder",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("force_login",
                                                  &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <'a> ::core::clone::Clone for Registration<'a> {
        #[inline]
        fn clone(&self) -> Registration<'a> {
            match *self {
                Registration {
                base: ref __self_0_0,
                client: ref __self_0_1,
                app_builder: ref __self_0_2,
                force_login: ref __self_0_3 } =>
                Registration{base:
                                 ::core::clone::Clone::clone(&(*__self_0_0)),
                             client:
                                 ::core::clone::Clone::clone(&(*__self_0_1)),
                             app_builder:
                                 ::core::clone::Clone::clone(&(*__self_0_2)),
                             force_login:
                                 ::core::clone::Clone::clone(&(*__self_0_3)),},
            }
        }
    }
    struct OAuth {
        client_id: String,
        client_secret: String,
        #[serde(default = "default_redirect_uri")]
        redirect_uri: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_OAuth: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl <'de> _serde::Deserialize<'de> for OAuth {
                fn deserialize<__D>(__deserializer: __D)
                 -> _serde::export::Result<Self, __D::Error> where
                 __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    enum __Field { __field0, __field1, __field2, __ignore, }
                    struct __FieldVisitor;
                    impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                _ =>
                                _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                     &"field index 0 <= i < 3")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                "client_id" =>
                                _serde::export::Ok(__Field::__field0),
                                "client_secret" =>
                                _serde::export::Ok(__Field::__field1),
                                "redirect_uri" =>
                                _serde::export::Ok(__Field::__field2),
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                b"client_id" =>
                                _serde::export::Ok(__Field::__field0),
                                b"client_secret" =>
                                _serde::export::Ok(__Field::__field1),
                                b"redirect_uri" =>
                                _serde::export::Ok(__Field::__field2),
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    impl <'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                         __FieldVisitor)
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<OAuth>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OAuth;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "struct OAuth")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                     &"struct OAuth with 3 elements"));
                                    }
                                };
                            let __field1 =
                                match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                     &"struct OAuth with 3 elements"));
                                    }
                                };
                            let __field2 =
                                match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        default_redirect_uri()
                                    }
                                };
                            _serde::export::Ok(OAuth{client_id: __field0,
                                                     client_secret: __field1,
                                                     redirect_uri: __field2,})
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::MapAccess<'de> {
                            let mut __field0: _serde::export::Option<String> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<String> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<String> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                      match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("client_id"));
                                        }
                                        __field0 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("client_secret"));
                                        }
                                        __field1 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("redirect_uri"));
                                        }
                                        __field2 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    _ => {
                                        let _ =
                                            match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::export::Some(__field0) =>
                                    __field0,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("client_id")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            let __field1 =
                                match __field1 {
                                    _serde::export::Some(__field1) =>
                                    __field1,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("client_secret")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            let __field2 =
                                match __field2 {
                                    _serde::export::Some(__field2) =>
                                    __field2,
                                    _serde::export::None =>
                                    default_redirect_uri(),
                                };
                            _serde::export::Ok(OAuth{client_id: __field0,
                                                     client_secret: __field1,
                                                     redirect_uri: __field2,})
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["client_id", "client_secret", "redirect_uri"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                                                             "OAuth", FIELDS,
                                                             __Visitor{marker:
                                                                           _serde::export::PhantomData::<OAuth>,
                                                                       lifetime:
                                                                           _serde::export::PhantomData,})
                }
            }
        };
    fn default_redirect_uri() -> String { DEFAULT_REDIRECT_URI.to_string() }
    struct AccessToken {
        access_token: String,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_AccessToken: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl <'de> _serde::Deserialize<'de> for AccessToken {
                fn deserialize<__D>(__deserializer: __D)
                 -> _serde::export::Result<Self, __D::Error> where
                 __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    enum __Field { __field0, __ignore, }
                    struct __FieldVisitor;
                    impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ =>
                                _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                     &"field index 0 <= i < 1")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                "access_token" =>
                                _serde::export::Ok(__Field::__field0),
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                b"access_token" =>
                                _serde::export::Ok(__Field::__field0),
                                _ => { _serde::export::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    impl <'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                         __FieldVisitor)
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<AccessToken>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AccessToken;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "struct AccessToken")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                     &"struct AccessToken with 1 element"));
                                    }
                                };
                            _serde::export::Ok(AccessToken{access_token:
                                                               __field0,})
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::MapAccess<'de> {
                            let mut __field0: _serde::export::Option<String> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                      match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                          {
                                          _serde::export::Ok(__val) => __val,
                                          _serde::export::Err(__err) => {
                                              return _serde::export::Err(__err);
                                          }
                                      } {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0)
                                           {
                                            return _serde::export::Err(<__A::Error
                                                                           as
                                                                           _serde::de::Error>::duplicate_field("access_token"));
                                        }
                                        __field0 =
                                            _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                     {
                                                                     _serde::export::Ok(__val)
                                                                     => __val,
                                                                     _serde::export::Err(__err)
                                                                     => {
                                                                         return _serde::export::Err(__err);
                                                                     }
                                                                 });
                                    }
                                    _ => {
                                        let _ =
                                            match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::export::Some(__field0) =>
                                    __field0,
                                    _serde::export::None =>
                                    match _serde::private::de::missing_field("access_token")
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                };
                            _serde::export::Ok(AccessToken{access_token:
                                                               __field0,})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["access_token"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                                                             "AccessToken",
                                                             FIELDS,
                                                             __Visitor{marker:
                                                                           _serde::export::PhantomData::<AccessToken>,
                                                                       lifetime:
                                                                           _serde::export::PhantomData,})
                }
            }
        };
    impl <'a> Registration<'a> {
        /// Construct a new registration process to the instance of the `base` url.
        /// ```
        /// use elefren::prelude::*;
        ///
        /// let registration = Registration::new("https://mastodon.social");
        /// ```
        pub fn new<I: Into<String>>(base: I) -> Self {
            Registration{base: base.into(),
                         client: Client::new(),
                         app_builder: AppBuilder::new(),
                         force_login: false,}
        }
    }
    impl <'a> Registration<'a> {
        /// Sets the name of this app
        ///
        /// This is required, and if this isn't set then the AppBuilder::build
        /// method will fail
        pub fn client_name<I: Into<Cow<'a, str>>>(&mut self, name: I)
         -> &mut Self {
            self.app_builder.client_name(name.into());
            self
        }
        /// Sets the redirect uris that this app uses
        pub fn redirect_uris<I: Into<Cow<'a, str>>>(&mut self, uris: I)
         -> &mut Self {
            self.app_builder.redirect_uris(uris);
            self
        }
        /// Sets the scopes that this app requires
        ///
        /// The default for an app is Scopes::Read
        pub fn scopes(&mut self, scopes: Scopes) -> &mut Self {
            self.app_builder.scopes(scopes);
            self
        }
        /// Sets the optional "website" to register the app with
        pub fn website<I: Into<Cow<'a, str>>>(&mut self, website: I)
         -> &mut Self {
            self.app_builder.website(website);
            self
        }
        /// Forces the user to re-login (useful if you need to re-auth as a
        /// different user on the same instance
        pub fn force_login(&mut self, force_login: bool) -> &mut Self {
            self.force_login = force_login;
            self
        }
        fn send(&self, req: RequestBuilder) -> Result<Response> {
            let req = req.build()?;
            Ok(self.client.execute(req)?)
        }
        /// Register the given application
        ///
        /// ```no_run
        /// # extern crate elefren;
        /// # fn main () -> elefren::Result<()> {
        /// use elefren::{apps::App, prelude::*};
        ///
        /// let mut app = App::builder();
        /// app.client_name("elefren_test");
        ///
        /// let registration = Registration::new("https://mastodon.social").register(app)?;
        /// let url = registration.authorize_url()?;
        /// // Here you now need to open the url in the browser
        /// // And handle a the redirect url coming back with the code.
        /// let code = String::from("RETURNED_FROM_BROWSER");
        /// let mastodon = registration.complete(&code)?;
        ///
        /// println!("{:?}", mastodon.get_home_timeline()?.initial_items);
        /// # Ok(())
        /// # }
        /// ```
        pub fn register<I: TryInto<App>>(&mut self, app: I)
         -> Result<Registered> where Error: From<<I as TryInto<App>>::Err> {
            let app = app.try_into()?;
            let oauth = self.send_app(&app)?;
            Ok(Registered{base: self.base.clone(),
                          client: self.client.clone(),
                          client_id: oauth.client_id,
                          client_secret: oauth.client_secret,
                          redirect: oauth.redirect_uri,
                          scopes: app.scopes().clone(),
                          force_login: self.force_login,})
        }
        /// Register the application with the server from the `base` url.
        ///
        /// ```no_run
        /// # extern crate elefren;
        /// # fn main () -> elefren::Result<()> {
        /// use elefren::prelude::*;
        ///
        /// let registration = Registration::new("https://mastodon.social")
        ///     .client_name("elefren_test")
        ///     .build()?;
        /// let url = registration.authorize_url()?;
        /// // Here you now need to open the url in the browser
        /// // And handle a the redirect url coming back with the code.
        /// let code = String::from("RETURNED_FROM_BROWSER");
        /// let mastodon = registration.complete(&code)?;
        ///
        /// println!("{:?}", mastodon.get_home_timeline()?.initial_items);
        /// # Ok(())
        /// # }
        /// ```
        pub fn build(&mut self) -> Result<Registered> {
            let app: App = self.app_builder.clone().build()?;
            let oauth = self.send_app(&app)?;
            Ok(Registered{base: self.base.clone(),
                          client: self.client.clone(),
                          client_id: oauth.client_id,
                          client_secret: oauth.client_secret,
                          redirect: oauth.redirect_uri,
                          scopes: app.scopes().clone(),
                          force_login: self.force_login,})
        }
        fn send_app(&self, app: &App) -> Result<OAuth> {
            let url =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["",
                                                                              "/api/v1/apps"],
                                                                            &match (&self.base,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                };
            Ok(self.send(self.client.post(&url).json(&app))?.json()?)
        }
    }
    impl Registered {
        /// Skip having to retrieve the client id and secret from the server by
        /// creating a `Registered` struct directly
        ///
        /// # Example
        ///
        /// ```no_run
        /// # extern crate elefren;
        /// # fn main() -> elefren::Result<()> {
        /// use elefren::{prelude::*, registration::Registered};
        ///
        /// let registration = Registered::from_parts(
        ///     "https://example.com",
        ///     "the-client-id",
        ///     "the-client-secret",
        ///     "https://example.com/redirect",
        ///     Scopes::read_all(),
        ///     false,
        /// );
        /// let url = registration.authorize_url()?;
        /// // Here you now need to open the url in the browser
        /// // And handle a the redirect url coming back with the code.
        /// let code = String::from("RETURNED_FROM_BROWSER");
        /// let mastodon = registration.complete(&code)?;
        ///
        /// println!("{:?}", mastodon.get_home_timeline()?.initial_items);
        /// #   Ok(())
        /// # }
        /// ```
        pub fn from_parts(base: &str, client_id: &str, client_secret: &str,
                          redirect: &str, scopes: Scopes, force_login: bool)
         -> Registered {
            Registered{base: base.to_string(),
                       client: Client::new(),
                       client_id: client_id.to_string(),
                       client_secret: client_secret.to_string(),
                       redirect: redirect.to_string(),
                       scopes,
                       force_login,}
        }
    }
    impl Registered {
        fn send(&self, req: RequestBuilder) -> Result<Response> {
            let req = req.build()?;
            Ok(self.client.execute(req)?)
        }
        /// Returns the parts of the `Registered` struct that can be used to
        /// recreate another `Registered` struct
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate elefren;
        /// use elefren::{prelude::*, registration::Registered};
        /// # fn main() -> Result<(), Box<std::error::Error>> {
        ///
        /// let origbase = "https://example.social";
        /// let origclient_id = "some-client_id";
        /// let origclient_secret = "some-client-secret";
        /// let origredirect = "https://example.social/redirect";
        /// let origscopes = Scopes::all();
        /// let origforce_login = false;
        ///
        /// let registered = Registered::from_parts(
        ///     origbase,
        ///     origclient_id,
        ///     origclient_secret,
        ///     origredirect,
        ///     origscopes.clone(),
        ///     origforce_login,
        /// );
        ///
        /// let (base, client_id, client_secret, redirect, scopes, force_login) = registered.into_parts();
        ///
        /// assert_eq!(origbase, &base);
        /// assert_eq!(origclient_id, &client_id);
        /// assert_eq!(origclient_secret, &client_secret);
        /// assert_eq!(origredirect, &redirect);
        /// assert_eq!(origscopes, scopes);
        /// assert_eq!(origforce_login, force_login);
        /// #   Ok(())
        /// # }
        /// ```
        pub fn into_parts(self)
         -> (String, String, String, String, Scopes, bool) {
            (self.base, self.client_id, self.client_secret, self.redirect,
             self.scopes, self.force_login)
        }
        /// Returns the full url needed for authorisation. This needs to be opened
        /// in a browser.
        pub fn authorize_url(&self) -> Result<String> {
            let scopes =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&self.scopes,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                };
            let scopes: String =
                utf8_percent_encode(&scopes, DEFAULT_ENCODE_SET).collect();
            let url =
                if self.force_login {
                    {
                        let res =
                            ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["",
                                                                                  "/oauth/authorize?client_id=",
                                                                                  "&redirect_uri=",
                                                                                  "&scope=",
                                                                                  "&force_login=true&response_type=code"],
                                                                                &match (&self.base,
                                                                                        &self.client_id,
                                                                                        &self.redirect,
                                                                                        &scopes)
                                                                                     {
                                                                                     (arg0,
                                                                                      arg1,
                                                                                      arg2,
                                                                                      arg3)
                                                                                     =>
                                                                                     [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                   ::core::fmt::Display::fmt),
                                                                                      ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                   ::core::fmt::Display::fmt),
                                                                                      ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                   ::core::fmt::Display::fmt),
                                                                                      ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                   ::core::fmt::Display::fmt)],
                                                                                 }));
                        res
                    }
                } else {
                    {
                        let res =
                            ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["",
                                                                                  "/oauth/authorize?client_id=",
                                                                                  "&redirect_uri=",
                                                                                  "&scope=",
                                                                                  "&response_type=code"],
                                                                                &match (&self.base,
                                                                                        &self.client_id,
                                                                                        &self.redirect,
                                                                                        &scopes)
                                                                                     {
                                                                                     (arg0,
                                                                                      arg1,
                                                                                      arg2,
                                                                                      arg3)
                                                                                     =>
                                                                                     [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                   ::core::fmt::Display::fmt),
                                                                                      ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                   ::core::fmt::Display::fmt),
                                                                                      ::core::fmt::ArgumentV1::new(arg2,
                                                                                                                   ::core::fmt::Display::fmt),
                                                                                      ::core::fmt::ArgumentV1::new(arg3,
                                                                                                                   ::core::fmt::Display::fmt)],
                                                                                 }));
                        res
                    }
                };
            Ok(url)
        }
        /// Create an access token from the client id, client secret, and code
        /// provided by the authorisation url.
        pub fn complete(&self, code: &str) -> Result<Mastodon> {
            let url =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["",
                                                                              "/oauth/token?client_id=",
                                                                              "&client_secret=",
                                                                              "&code=",
                                                                              "&grant_type=authorization_code&redirect_uri="],
                                                                            &match (&self.base,
                                                                                    &self.client_id,
                                                                                    &self.client_secret,
                                                                                    &code,
                                                                                    &self.redirect)
                                                                                 {
                                                                                 (arg0,
                                                                                  arg1,
                                                                                  arg2,
                                                                                  arg3,
                                                                                  arg4)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt),
                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                               ::core::fmt::Display::fmt),
                                                                                  ::core::fmt::ArgumentV1::new(arg2,
                                                                                                               ::core::fmt::Display::fmt),
                                                                                  ::core::fmt::ArgumentV1::new(arg3,
                                                                                                               ::core::fmt::Display::fmt),
                                                                                  ::core::fmt::ArgumentV1::new(arg4,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                };
            let token: AccessToken =
                self.send(self.client.post(&url))?.json()?;
            let data =
                Data{base: self.base.clone().into(),
                     client_id: self.client_id.clone().into(),
                     client_secret: self.client_secret.clone().into(),
                     redirect: self.redirect.clone().into(),
                     token: token.access_token.into(),};
            let mut builder = MastodonBuilder::new();
            builder.client(self.client.clone()).data(data);
            Ok(builder.build()?)
        }
    }
    /// Represents the state of the auth flow when the app has been registered but
    /// the user is not authenticated
    pub struct Registered {
        base: String,
        client: Client,
        client_id: String,
        client_secret: String,
        redirect: String,
        scopes: Scopes,
        force_login: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Registered {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Registered {
                base: ref __self_0_0,
                client: ref __self_0_1,
                client_id: ref __self_0_2,
                client_secret: ref __self_0_3,
                redirect: ref __self_0_4,
                scopes: ref __self_0_5,
                force_login: ref __self_0_6 } => {
                    let mut debug_trait_builder =
                        f.debug_struct("Registered");
                    let _ =
                        debug_trait_builder.field("base", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("client", &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("client_id",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("client_secret",
                                                  &&(*__self_0_3));
                    let _ =
                        debug_trait_builder.field("redirect",
                                                  &&(*__self_0_4));
                    let _ =
                        debug_trait_builder.field("scopes", &&(*__self_0_5));
                    let _ =
                        debug_trait_builder.field("force_login",
                                                  &&(*__self_0_6));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Registered {
        #[inline]
        fn clone(&self) -> Registered {
            match *self {
                Registered {
                base: ref __self_0_0,
                client: ref __self_0_1,
                client_id: ref __self_0_2,
                client_secret: ref __self_0_3,
                redirect: ref __self_0_4,
                scopes: ref __self_0_5,
                force_login: ref __self_0_6 } =>
                Registered{base: ::core::clone::Clone::clone(&(*__self_0_0)),
                           client:
                               ::core::clone::Clone::clone(&(*__self_0_1)),
                           client_id:
                               ::core::clone::Clone::clone(&(*__self_0_2)),
                           client_secret:
                               ::core::clone::Clone::clone(&(*__self_0_3)),
                           redirect:
                               ::core::clone::Clone::clone(&(*__self_0_4)),
                           scopes:
                               ::core::clone::Clone::clone(&(*__self_0_5)),
                           force_login:
                               ::core::clone::Clone::clone(&(*__self_0_6)),},
            }
        }
    }
}
/// Requests
pub mod requests {
    /// Data structure for the MastodonClient::add_filter method
    pub use self::filter::AddFilterRequest;
    /// Data structure for the MastodonClient::add_push_subscription method
    pub use self::push::{AddPushRequest, Keys, UpdatePushRequest};
    /// Data structure for the MastodonClient::statuses method
    pub use self::statuses::StatusesRequest;
    /// Data structure for the MastodonClient::update_credentials method
    pub use self::update_credentials::UpdateCredsRequest;
    mod filter {
        use crate::entities::filter::FilterContext;
        use std::time::Duration;
        /// Form used to create a filter
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate elefren;
        /// # use std::error::Error;
        /// use elefren::{entities::filter::FilterContext, requests::AddFilterRequest};
        /// # fn main() -> Result<(), Box<Error>> {
        /// let request = AddFilterRequest::new("foo", FilterContext::Home);
        /// #   Ok(())
        /// # }
        /// ```
        pub struct AddFilterRequest {
            phrase: String,
            context: FilterContext,
            irreversible: Option<bool>,
            whole_word: Option<bool>,
            #[serde(serialize_with = "serialize_duration::ser")]
            expires_in: Option<Duration>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for AddFilterRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    AddFilterRequest {
                    phrase: ref __self_0_0,
                    context: ref __self_0_1,
                    irreversible: ref __self_0_2,
                    whole_word: ref __self_0_3,
                    expires_in: ref __self_0_4 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("AddFilterRequest");
                        let _ =
                            debug_trait_builder.field("phrase",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("context",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("irreversible",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("whole_word",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("expires_in",
                                                      &&(*__self_0_4));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for AddFilterRequest {
            #[inline]
            fn clone(&self) -> AddFilterRequest {
                match *self {
                    AddFilterRequest {
                    phrase: ref __self_0_0,
                    context: ref __self_0_1,
                    irreversible: ref __self_0_2,
                    whole_word: ref __self_0_3,
                    expires_in: ref __self_0_4 } =>
                    AddFilterRequest{phrase:
                                         ::core::clone::Clone::clone(&(*__self_0_0)),
                                     context:
                                         ::core::clone::Clone::clone(&(*__self_0_1)),
                                     irreversible:
                                         ::core::clone::Clone::clone(&(*__self_0_2)),
                                     whole_word:
                                         ::core::clone::Clone::clone(&(*__self_0_3)),
                                     expires_in:
                                         ::core::clone::Clone::clone(&(*__self_0_4)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for AddFilterRequest { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for AddFilterRequest {
            #[inline]
            fn eq(&self, other: &AddFilterRequest) -> bool {
                match *other {
                    AddFilterRequest {
                    phrase: ref __self_1_0,
                    context: ref __self_1_1,
                    irreversible: ref __self_1_2,
                    whole_word: ref __self_1_3,
                    expires_in: ref __self_1_4 } =>
                    match *self {
                        AddFilterRequest {
                        phrase: ref __self_0_0,
                        context: ref __self_0_1,
                        irreversible: ref __self_0_2,
                        whole_word: ref __self_0_3,
                        expires_in: ref __self_0_4 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &AddFilterRequest) -> bool {
                match *other {
                    AddFilterRequest {
                    phrase: ref __self_1_0,
                    context: ref __self_1_1,
                    irreversible: ref __self_1_2,
                    whole_word: ref __self_1_3,
                    expires_in: ref __self_1_4 } =>
                    match *self {
                        AddFilterRequest {
                        phrase: ref __self_0_0,
                        context: ref __self_0_1,
                        irreversible: ref __self_0_2,
                        whole_word: ref __self_0_3,
                        expires_in: ref __self_0_4 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_AddFilterRequest: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl _serde::Serialize for AddFilterRequest {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "AddFilterRequest",
                                                                       false
                                                                           as
                                                                           usize
                                                                           + 1
                                                                           + 1
                                                                           + 1
                                                                           + 1
                                                                           +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "phrase",
                                                                            &self.phrase)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "context",
                                                                            &self.context)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "irreversible",
                                                                            &self.irreversible)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "whole_word",
                                                                            &self.whole_word)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "expires_in",
                                                                            {
                                                                                struct __SerializeWith<'__a> {
                                                                                    values: (&'__a Option<Duration>,),
                                                                                    phantom: _serde::export::PhantomData<AddFilterRequest>,
                                                                                }
                                                                                impl <'__a>
                                                                                 _serde::Serialize
                                                                                 for
                                                                                 __SerializeWith<'__a>
                                                                                 {
                                                                                    fn serialize<__S>(&self,
                                                                                                      __s:
                                                                                                          __S)
                                                                                     ->
                                                                                         _serde::export::Result<__S::Ok,
                                                                                                                __S::Error>
                                                                                     where
                                                                                     __S: _serde::Serializer {
                                                                                        serialize_duration::ser(self.values.0,
                                                                                                                __s)
                                                                                    }
                                                                                }
                                                                                &__SerializeWith{values:
                                                                                                     (&self.expires_in,),
                                                                                                 phantom:
                                                                                                     _serde::export::PhantomData::<AddFilterRequest>,}
                                                                            })
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        impl AddFilterRequest {
            /// Create a new AddFilterRequest
            pub fn new(phrase: &str, context: FilterContext)
             -> AddFilterRequest {
                AddFilterRequest{phrase: phrase.to_string(),
                                 context,
                                 irreversible: None,
                                 whole_word: None,
                                 expires_in: None,}
            }
            /// Set `irreversible` to `true`
            pub fn irreversible(&mut self) -> &mut Self {
                self.irreversible = Some(true);
                self
            }
            /// Set `whole_word` to `true`
            pub fn whole_word(&mut self) -> &mut Self {
                self.whole_word = Some(true);
                self
            }
            /// Set `expires_in` to a duration
            pub fn expires_in(&mut self, d: Duration) -> &mut Self {
                self.expires_in = Some(d);
                self
            }
        }
        mod serialize_duration {
            use serde::ser::Serializer;
            use std::time::Duration;
            pub(crate) fn ser<S>(duration: &Option<Duration>, s: S)
             -> Result<S::Ok, S::Error> where S: Serializer {
                if let Some(d) = duration {
                    let sec = d.as_secs();
                    s.serialize_u64(sec)
                } else { s.serialize_none() }
            }
        }
    }
    mod push {
        use crate::entities::push::{add_subscription, update_data};
        use crate::errors::Result;
        /// Container for the key & auth strings for an AddPushRequest
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate elefren;
        /// use elefren::requests::Keys;
        ///
        /// let keys = Keys::new("anetohias===", "oeatssah=");
        /// ```
        pub struct Keys {
            pub(crate) p256dh: String,
            pub(crate) auth: String,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Keys {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    Keys { p256dh: ref __self_0_0, auth: ref __self_0_1 } => {
                        let mut debug_trait_builder = f.debug_struct("Keys");
                        let _ =
                            debug_trait_builder.field("p256dh",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("auth",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for Keys {
            #[inline]
            fn default() -> Keys {
                Keys{p256dh: ::core::default::Default::default(),
                     auth: ::core::default::Default::default(),}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Keys {
            #[inline]
            fn clone(&self) -> Keys {
                match *self {
                    Keys { p256dh: ref __self_0_0, auth: ref __self_0_1 } =>
                    Keys{p256dh: ::core::clone::Clone::clone(&(*__self_0_0)),
                         auth: ::core::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Keys { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Keys {
            #[inline]
            fn eq(&self, other: &Keys) -> bool {
                match *other {
                    Keys { p256dh: ref __self_1_0, auth: ref __self_1_1 } =>
                    match *self {
                        Keys { p256dh: ref __self_0_0, auth: ref __self_0_1 }
                        =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Keys) -> bool {
                match *other {
                    Keys { p256dh: ref __self_1_0, auth: ref __self_1_1 } =>
                    match *self {
                        Keys { p256dh: ref __self_0_0, auth: ref __self_0_1 }
                        =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl Keys {
            /// Create the `Keys` container
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::Keys;
            ///
            /// let keys = Keys::new("anetohias===", "oeatssah=");
            /// ```
            pub fn new(p256dh: &str, auth: &str) -> Keys {
                Keys{p256dh: p256dh.to_string(), auth: auth.to_string(),}
            }
        }
        /// Builder to pass to the Mastodon::add_push_subscription method
        ///
        /// # Example
        ///
        /// ```no_run
        /// # extern crate elefren;
        /// # use elefren::{MastodonClient, Mastodon, Data};
        /// # fn main() -> Result<(), elefren::Error> {
        /// # let data = Data {
        /// #   base: "".into(),
        /// #   client_id: "".into(),
        /// #   client_secret: "".into(),
        /// #   redirect: "".into(),
        /// #   token: "".into(),
        /// # };
        /// use elefren::requests::{AddPushRequest, Keys};
        ///
        /// let client = Mastodon::from(data);
        ///
        /// let keys = Keys::new("stahesuahoei293ise===", "tasecoa,nmeozka==");
        /// let mut request = AddPushRequest::new("http://example.com/push/endpoint", &keys);
        /// request.follow().reblog();
        ///
        /// client.add_push_subscription(&request)?;
        /// #   Ok(())
        /// # }
        /// ```
        pub struct AddPushRequest {
            endpoint: String,
            p256dh: String,
            auth: String,
            follow: Option<bool>,
            favourite: Option<bool>,
            reblog: Option<bool>,
            mention: Option<bool>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for AddPushRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    AddPushRequest {
                    endpoint: ref __self_0_0,
                    p256dh: ref __self_0_1,
                    auth: ref __self_0_2,
                    follow: ref __self_0_3,
                    favourite: ref __self_0_4,
                    reblog: ref __self_0_5,
                    mention: ref __self_0_6 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("AddPushRequest");
                        let _ =
                            debug_trait_builder.field("endpoint",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("p256dh",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("auth",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("follow",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("favourite",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("reblog",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("mention",
                                                      &&(*__self_0_6));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for AddPushRequest {
            #[inline]
            fn default() -> AddPushRequest {
                AddPushRequest{endpoint: ::core::default::Default::default(),
                               p256dh: ::core::default::Default::default(),
                               auth: ::core::default::Default::default(),
                               follow: ::core::default::Default::default(),
                               favourite: ::core::default::Default::default(),
                               reblog: ::core::default::Default::default(),
                               mention: ::core::default::Default::default(),}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for AddPushRequest {
            #[inline]
            fn clone(&self) -> AddPushRequest {
                match *self {
                    AddPushRequest {
                    endpoint: ref __self_0_0,
                    p256dh: ref __self_0_1,
                    auth: ref __self_0_2,
                    follow: ref __self_0_3,
                    favourite: ref __self_0_4,
                    reblog: ref __self_0_5,
                    mention: ref __self_0_6 } =>
                    AddPushRequest{endpoint:
                                       ::core::clone::Clone::clone(&(*__self_0_0)),
                                   p256dh:
                                       ::core::clone::Clone::clone(&(*__self_0_1)),
                                   auth:
                                       ::core::clone::Clone::clone(&(*__self_0_2)),
                                   follow:
                                       ::core::clone::Clone::clone(&(*__self_0_3)),
                                   favourite:
                                       ::core::clone::Clone::clone(&(*__self_0_4)),
                                   reblog:
                                       ::core::clone::Clone::clone(&(*__self_0_5)),
                                   mention:
                                       ::core::clone::Clone::clone(&(*__self_0_6)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for AddPushRequest { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for AddPushRequest {
            #[inline]
            fn eq(&self, other: &AddPushRequest) -> bool {
                match *other {
                    AddPushRequest {
                    endpoint: ref __self_1_0,
                    p256dh: ref __self_1_1,
                    auth: ref __self_1_2,
                    follow: ref __self_1_3,
                    favourite: ref __self_1_4,
                    reblog: ref __self_1_5,
                    mention: ref __self_1_6 } =>
                    match *self {
                        AddPushRequest {
                        endpoint: ref __self_0_0,
                        p256dh: ref __self_0_1,
                        auth: ref __self_0_2,
                        follow: ref __self_0_3,
                        favourite: ref __self_0_4,
                        reblog: ref __self_0_5,
                        mention: ref __self_0_6 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5) &&
                            (*__self_0_6) == (*__self_1_6),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &AddPushRequest) -> bool {
                match *other {
                    AddPushRequest {
                    endpoint: ref __self_1_0,
                    p256dh: ref __self_1_1,
                    auth: ref __self_1_2,
                    follow: ref __self_1_3,
                    favourite: ref __self_1_4,
                    reblog: ref __self_1_5,
                    mention: ref __self_1_6 } =>
                    match *self {
                        AddPushRequest {
                        endpoint: ref __self_0_0,
                        p256dh: ref __self_0_1,
                        auth: ref __self_0_2,
                        follow: ref __self_0_3,
                        favourite: ref __self_0_4,
                        reblog: ref __self_0_5,
                        mention: ref __self_0_6 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5) ||
                            (*__self_0_6) != (*__self_1_6),
                    },
                }
            }
        }
        impl AddPushRequest {
            /// Construct a new AddPushRequest
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::{AddPushRequest, Keys};
            /// let keys = Keys::new("abcdef===", "foobar==");
            /// let push_endpoint = "https://example.com/push/endpoint";
            /// let request = AddPushRequest::new(push_endpoint, &keys);
            /// ```
            pub fn new(endpoint: &str, keys: &Keys) -> AddPushRequest {
                AddPushRequest{endpoint: endpoint.to_string(),
                               p256dh: keys.p256dh.clone(),
                               auth: keys.auth.clone(), ..Default::default()}
            }
            /// A flag that indicates if you want follow notifications pushed
            ///
            /// # Example
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::{AddPushRequest, Keys};
            /// let keys = Keys::new("abcdef===", "foobar==");
            /// let push_endpoint = "https://example.com/push/endpoint";
            /// let mut request = AddPushRequest::new(push_endpoint, &keys);
            /// request.follow();
            /// ```
            pub fn follow(&mut self) -> &mut Self {
                self.follow = Some(true);
                self
            }
            /// A flag that indicates if you want favourite notifications pushed
            ///
            /// # Example
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::{AddPushRequest, Keys};
            /// let keys = Keys::new("abcdef===", "foobar==");
            /// let push_endpoint = "https://example.com/push/endpoint";
            /// let mut request = AddPushRequest::new(push_endpoint, &keys);
            /// request.favourite();
            /// ```
            pub fn favourite(&mut self) -> &mut Self {
                self.favourite = Some(true);
                self
            }
            /// A flag that indicates if you want reblog notifications pushed
            ///
            /// # Example
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::{AddPushRequest, Keys};
            /// let keys = Keys::new("abcdef===", "foobar==");
            /// let push_endpoint = "https://example.com/push/endpoint";
            /// let mut request = AddPushRequest::new(push_endpoint, &keys);
            /// request.reblog();
            /// ```
            pub fn reblog(&mut self) -> &mut Self {
                self.reblog = Some(true);
                self
            }
            /// A flag that indicates if you want mention notifications pushed
            ///
            /// # Example
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::{AddPushRequest, Keys};
            /// let keys = Keys::new("abcdef===", "foobar==");
            /// let push_endpoint = "https://example.com/push/endpoint";
            /// let mut request = AddPushRequest::new(push_endpoint, &keys);
            /// request.mention();
            /// ```
            pub fn mention(&mut self) -> &mut Self {
                self.mention = Some(true);
                self
            }
            fn flags_present(&self) -> bool {
                self.follow.is_some() || self.favourite.is_some() ||
                    self.reblog.is_some() || self.mention.is_some()
            }
            pub(crate) fn build(&self) -> Result<add_subscription::Form> {
                use crate::entities::push::{add_subscription::{Data, Form,
                                                               Keys,
                                                               Subscription},
                                            Alerts};
                let mut form =
                    Form{subscription:
                             Subscription{endpoint: self.endpoint.clone(),
                                          keys:
                                              Keys{p256dh:
                                                       self.p256dh.clone(),
                                                   auth:
                                                       self.auth.clone(),},},
                         data: None,};
                if self.flags_present() {
                    let mut alerts = Alerts::default();
                    if let Some(follow) = self.follow {
                        alerts.follow = Some(follow);
                    }
                    if let Some(favourite) = self.favourite {
                        alerts.favourite = Some(favourite);
                    }
                    if let Some(reblog) = self.reblog {
                        alerts.reblog = Some(reblog);
                    }
                    if let Some(mention) = self.mention {
                        alerts.mention = Some(mention);
                    }
                    form.data = Some(Data{alerts: Some(alerts),});
                }
                Ok(form)
            }
        }
        /// Builder to pass to the Mastodon::update_push_data method
        ///
        /// # Example
        ///
        /// ```no_run
        /// # extern crate elefren;
        /// # use elefren::{MastodonClient, Mastodon, Data};
        /// # fn main() -> Result<(), elefren::Error> {
        /// # let data = Data {
        /// #   base: "".into(),
        /// #   client_id: "".into(),
        /// #   client_secret: "".into(),
        /// #   redirect: "".into(),
        /// #   token: "".into(),
        /// # };
        /// use elefren::requests::UpdatePushRequest;
        ///
        /// let client = Mastodon::from(data);
        ///
        /// let mut request = UpdatePushRequest::new("foobar");
        /// request.follow(true).reblog(true);
        ///
        /// client.update_push_data(&request)?;
        /// #   Ok(())
        /// # }
        /// ```
        pub struct UpdatePushRequest {
            id: String,
            follow: Option<bool>,
            favourite: Option<bool>,
            reblog: Option<bool>,
            mention: Option<bool>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UpdatePushRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    UpdatePushRequest {
                    id: ref __self_0_0,
                    follow: ref __self_0_1,
                    favourite: ref __self_0_2,
                    reblog: ref __self_0_3,
                    mention: ref __self_0_4 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("UpdatePushRequest");
                        let _ =
                            debug_trait_builder.field("id", &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("follow",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("favourite",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("reblog",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("mention",
                                                      &&(*__self_0_4));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for UpdatePushRequest {
            #[inline]
            fn default() -> UpdatePushRequest {
                UpdatePushRequest{id: ::core::default::Default::default(),
                                  follow: ::core::default::Default::default(),
                                  favourite:
                                      ::core::default::Default::default(),
                                  reblog: ::core::default::Default::default(),
                                  mention:
                                      ::core::default::Default::default(),}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UpdatePushRequest {
            #[inline]
            fn clone(&self) -> UpdatePushRequest {
                match *self {
                    UpdatePushRequest {
                    id: ref __self_0_0,
                    follow: ref __self_0_1,
                    favourite: ref __self_0_2,
                    reblog: ref __self_0_3,
                    mention: ref __self_0_4 } =>
                    UpdatePushRequest{id:
                                          ::core::clone::Clone::clone(&(*__self_0_0)),
                                      follow:
                                          ::core::clone::Clone::clone(&(*__self_0_1)),
                                      favourite:
                                          ::core::clone::Clone::clone(&(*__self_0_2)),
                                      reblog:
                                          ::core::clone::Clone::clone(&(*__self_0_3)),
                                      mention:
                                          ::core::clone::Clone::clone(&(*__self_0_4)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for UpdatePushRequest { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for UpdatePushRequest {
            #[inline]
            fn eq(&self, other: &UpdatePushRequest) -> bool {
                match *other {
                    UpdatePushRequest {
                    id: ref __self_1_0,
                    follow: ref __self_1_1,
                    favourite: ref __self_1_2,
                    reblog: ref __self_1_3,
                    mention: ref __self_1_4 } =>
                    match *self {
                        UpdatePushRequest {
                        id: ref __self_0_0,
                        follow: ref __self_0_1,
                        favourite: ref __self_0_2,
                        reblog: ref __self_0_3,
                        mention: ref __self_0_4 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &UpdatePushRequest) -> bool {
                match *other {
                    UpdatePushRequest {
                    id: ref __self_1_0,
                    follow: ref __self_1_1,
                    favourite: ref __self_1_2,
                    reblog: ref __self_1_3,
                    mention: ref __self_1_4 } =>
                    match *self {
                        UpdatePushRequest {
                        id: ref __self_0_0,
                        follow: ref __self_0_1,
                        favourite: ref __self_0_2,
                        reblog: ref __self_0_3,
                        mention: ref __self_0_4 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_UpdatePushRequest: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl _serde::Serialize for UpdatePushRequest {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "UpdatePushRequest",
                                                                       false
                                                                           as
                                                                           usize
                                                                           + 1
                                                                           + 1
                                                                           + 1
                                                                           + 1
                                                                           +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "id",
                                                                            &self.id)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "follow",
                                                                            &self.follow)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "favourite",
                                                                            &self.favourite)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "reblog",
                                                                            &self.reblog)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "mention",
                                                                            &self.mention)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        impl UpdatePushRequest {
            /// Construct a new UpdatePushRequest
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::UpdatePushRequest;
            /// let request = UpdatePushRequest::new("some-id");
            /// ```
            pub fn new(id: &str) -> UpdatePushRequest {
                UpdatePushRequest{id: id.to_string(), ..Default::default()}
            }
            /// A flag that indicates if you want follow notifications pushed
            ///
            /// # Example
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::UpdatePushRequest;
            /// let mut request = UpdatePushRequest::new("foobar");
            /// request.follow(true);
            /// ```
            pub fn follow(&mut self, follow: bool) -> &mut Self {
                self.follow = Some(follow);
                self
            }
            /// A flag that indicates if you want favourite notifications pushed
            ///
            /// # Example
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::UpdatePushRequest;
            /// let mut request = UpdatePushRequest::new("foobar");
            /// request.favourite(true);
            /// ```
            pub fn favourite(&mut self, favourite: bool) -> &mut Self {
                self.favourite = Some(favourite);
                self
            }
            /// A flag that indicates if you want reblog notifications pushed
            ///
            /// # Example
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::UpdatePushRequest;
            /// let mut request = UpdatePushRequest::new("foobar");
            /// request.reblog(true);
            /// ```
            pub fn reblog(&mut self, reblog: bool) -> &mut Self {
                self.reblog = Some(reblog);
                self
            }
            /// A flag that indicates if you want mention notifications pushed
            ///
            /// # Example
            /// ```
            /// # extern crate elefren;
            /// use elefren::requests::UpdatePushRequest;
            /// let mut request = UpdatePushRequest::new("foobar");
            /// request.mention(true);
            /// ```
            pub fn mention(&mut self, mention: bool) -> &mut Self {
                self.mention = Some(mention);
                self
            }
            fn flags_present(&self) -> bool {
                self.follow.is_some() || self.favourite.is_some() ||
                    self.reblog.is_some() || self.mention.is_some()
            }
            pub(crate) fn build(&self) -> update_data::Form {
                use crate::entities::push::{update_data::{Data, Form},
                                            Alerts};
                let mut form =
                    Form{id: self.id.clone(), ..Default::default()};
                if self.flags_present() {
                    let mut alerts = Alerts::default();
                    if let Some(follow) = self.follow {
                        alerts.follow = Some(follow);
                    }
                    if let Some(favourite) = self.favourite {
                        alerts.favourite = Some(favourite);
                    }
                    if let Some(reblog) = self.reblog {
                        alerts.reblog = Some(reblog);
                    }
                    if let Some(mention) = self.mention {
                        alerts.mention = Some(mention);
                    }
                    form.data = Data{alerts: Some(alerts),};
                }
                form
            }
        }
    }
    mod statuses {
        use crate::errors::Error;
        use serde_qs;
        use std::{borrow::Cow, convert::Into};
        mod bool_qs_serialize {
            use serde::Serializer;
            pub fn is_false(b: &bool) -> bool { !*b }
            pub fn serialize<S: Serializer>(b: &bool, s: S)
             -> Result<S::Ok, S::Error> {
                if *b { s.serialize_i64(1) } else { s.serialize_i64(0) }
            }
        }
        /// Builder for making a client.statuses() call
        ///
        /// # Example
        ///
        /// ```
        /// # extern crate elefren;
        /// # use elefren::StatusesRequest;
        /// let mut request = StatusesRequest::new();
        /// request.only_media().pinned().since_id("foo");
        /// # assert_eq!(&request.to_querystring().expect("Couldn't serialize qs")[..], "?only_media=1&pinned=1&since_id=foo");
        /// ```
        pub struct StatusesRequest<'a> {
            #[serde(skip_serializing_if = "bool_qs_serialize::is_false")]
            #[serde(serialize_with = "bool_qs_serialize::serialize")]
            only_media: bool,
            #[serde(skip_serializing_if = "bool_qs_serialize::is_false")]
            #[serde(serialize_with = "bool_qs_serialize::serialize")]
            exclude_replies: bool,
            #[serde(skip_serializing_if = "bool_qs_serialize::is_false")]
            #[serde(serialize_with = "bool_qs_serialize::serialize")]
            pinned: bool,
            #[serde(skip_serializing_if = "Option::is_none")]
            max_id: Option<Cow<'a, str>>,
            #[serde(skip_serializing_if = "Option::is_none")]
            since_id: Option<Cow<'a, str>>,
            #[serde(skip_serializing_if = "Option::is_none")]
            limit: Option<usize>,
            #[serde(skip_serializing_if = "Option::is_none")]
            min_id: Option<Cow<'a, str>>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <'a> ::core::clone::Clone for StatusesRequest<'a> {
            #[inline]
            fn clone(&self) -> StatusesRequest<'a> {
                match *self {
                    StatusesRequest {
                    only_media: ref __self_0_0,
                    exclude_replies: ref __self_0_1,
                    pinned: ref __self_0_2,
                    max_id: ref __self_0_3,
                    since_id: ref __self_0_4,
                    limit: ref __self_0_5,
                    min_id: ref __self_0_6 } =>
                    StatusesRequest{only_media:
                                        ::core::clone::Clone::clone(&(*__self_0_0)),
                                    exclude_replies:
                                        ::core::clone::Clone::clone(&(*__self_0_1)),
                                    pinned:
                                        ::core::clone::Clone::clone(&(*__self_0_2)),
                                    max_id:
                                        ::core::clone::Clone::clone(&(*__self_0_3)),
                                    since_id:
                                        ::core::clone::Clone::clone(&(*__self_0_4)),
                                    limit:
                                        ::core::clone::Clone::clone(&(*__self_0_5)),
                                    min_id:
                                        ::core::clone::Clone::clone(&(*__self_0_6)),},
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <'a> ::core::fmt::Debug for StatusesRequest<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    StatusesRequest {
                    only_media: ref __self_0_0,
                    exclude_replies: ref __self_0_1,
                    pinned: ref __self_0_2,
                    max_id: ref __self_0_3,
                    since_id: ref __self_0_4,
                    limit: ref __self_0_5,
                    min_id: ref __self_0_6 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("StatusesRequest");
                        let _ =
                            debug_trait_builder.field("only_media",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("exclude_replies",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("pinned",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("max_id",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("since_id",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("limit",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("min_id",
                                                      &&(*__self_0_6));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <'a> ::core::default::Default for StatusesRequest<'a> {
            #[inline]
            fn default() -> StatusesRequest<'a> {
                StatusesRequest{only_media:
                                    ::core::default::Default::default(),
                                exclude_replies:
                                    ::core::default::Default::default(),
                                pinned: ::core::default::Default::default(),
                                max_id: ::core::default::Default::default(),
                                since_id: ::core::default::Default::default(),
                                limit: ::core::default::Default::default(),
                                min_id: ::core::default::Default::default(),}
            }
        }
        impl <'a> ::core::marker::StructuralPartialEq for StatusesRequest<'a>
         {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <'a> ::core::cmp::PartialEq for StatusesRequest<'a> {
            #[inline]
            fn eq(&self, other: &StatusesRequest<'a>) -> bool {
                match *other {
                    StatusesRequest {
                    only_media: ref __self_1_0,
                    exclude_replies: ref __self_1_1,
                    pinned: ref __self_1_2,
                    max_id: ref __self_1_3,
                    since_id: ref __self_1_4,
                    limit: ref __self_1_5,
                    min_id: ref __self_1_6 } =>
                    match *self {
                        StatusesRequest {
                        only_media: ref __self_0_0,
                        exclude_replies: ref __self_0_1,
                        pinned: ref __self_0_2,
                        max_id: ref __self_0_3,
                        since_id: ref __self_0_4,
                        limit: ref __self_0_5,
                        min_id: ref __self_0_6 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5) &&
                            (*__self_0_6) == (*__self_1_6),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &StatusesRequest<'a>) -> bool {
                match *other {
                    StatusesRequest {
                    only_media: ref __self_1_0,
                    exclude_replies: ref __self_1_1,
                    pinned: ref __self_1_2,
                    max_id: ref __self_1_3,
                    since_id: ref __self_1_4,
                    limit: ref __self_1_5,
                    min_id: ref __self_1_6 } =>
                    match *self {
                        StatusesRequest {
                        only_media: ref __self_0_0,
                        exclude_replies: ref __self_0_1,
                        pinned: ref __self_0_2,
                        max_id: ref __self_0_3,
                        since_id: ref __self_0_4,
                        limit: ref __self_0_5,
                        min_id: ref __self_0_6 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5) ||
                            (*__self_0_6) != (*__self_1_6),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_StatusesRequest: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'a> _serde::Serialize for StatusesRequest<'a> {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "StatusesRequest",
                                                                       false
                                                                           as
                                                                           usize
                                                                           +
                                                                           if bool_qs_serialize::is_false(&self.only_media)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if bool_qs_serialize::is_false(&self.exclude_replies)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if bool_qs_serialize::is_false(&self.pinned)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if Option::is_none(&self.max_id)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if Option::is_none(&self.since_id)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if Option::is_none(&self.limit)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           if Option::is_none(&self.min_id)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           })
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        if !bool_qs_serialize::is_false(&self.only_media) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "only_media",
                                                                                {
                                                                                    struct __SerializeWith<'__a,
                                                                                                           'a: '__a> {
                                                                                        values: (&'__a bool,),
                                                                                        phantom: _serde::export::PhantomData<StatusesRequest<'a>>,
                                                                                    }
                                                                                    impl <'__a,
                                                                                          'a: '__a>
                                                                                     _serde::Serialize
                                                                                     for
                                                                                     __SerializeWith<'__a,
                                                                                                     'a>
                                                                                     {
                                                                                        fn serialize<__S>(&self,
                                                                                                          __s:
                                                                                                              __S)
                                                                                         ->
                                                                                             _serde::export::Result<__S::Ok,
                                                                                                                    __S::Error>
                                                                                         where
                                                                                         __S: _serde::Serializer {
                                                                                            bool_qs_serialize::serialize(self.values.0,
                                                                                                                         __s)
                                                                                        }
                                                                                    }
                                                                                    &__SerializeWith{values:
                                                                                                         (&self.only_media,),
                                                                                                     phantom:
                                                                                                         _serde::export::PhantomData::<StatusesRequest<'a>>,}
                                                                                })
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "only_media")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !bool_qs_serialize::is_false(&self.exclude_replies)
                           {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "exclude_replies",
                                                                                {
                                                                                    struct __SerializeWith<'__a,
                                                                                                           'a: '__a> {
                                                                                        values: (&'__a bool,),
                                                                                        phantom: _serde::export::PhantomData<StatusesRequest<'a>>,
                                                                                    }
                                                                                    impl <'__a,
                                                                                          'a: '__a>
                                                                                     _serde::Serialize
                                                                                     for
                                                                                     __SerializeWith<'__a,
                                                                                                     'a>
                                                                                     {
                                                                                        fn serialize<__S>(&self,
                                                                                                          __s:
                                                                                                              __S)
                                                                                         ->
                                                                                             _serde::export::Result<__S::Ok,
                                                                                                                    __S::Error>
                                                                                         where
                                                                                         __S: _serde::Serializer {
                                                                                            bool_qs_serialize::serialize(self.values.0,
                                                                                                                         __s)
                                                                                        }
                                                                                    }
                                                                                    &__SerializeWith{values:
                                                                                                         (&self.exclude_replies,),
                                                                                                     phantom:
                                                                                                         _serde::export::PhantomData::<StatusesRequest<'a>>,}
                                                                                })
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "exclude_replies")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !bool_qs_serialize::is_false(&self.pinned) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "pinned",
                                                                                {
                                                                                    struct __SerializeWith<'__a,
                                                                                                           'a: '__a> {
                                                                                        values: (&'__a bool,),
                                                                                        phantom: _serde::export::PhantomData<StatusesRequest<'a>>,
                                                                                    }
                                                                                    impl <'__a,
                                                                                          'a: '__a>
                                                                                     _serde::Serialize
                                                                                     for
                                                                                     __SerializeWith<'__a,
                                                                                                     'a>
                                                                                     {
                                                                                        fn serialize<__S>(&self,
                                                                                                          __s:
                                                                                                              __S)
                                                                                         ->
                                                                                             _serde::export::Result<__S::Ok,
                                                                                                                    __S::Error>
                                                                                         where
                                                                                         __S: _serde::Serializer {
                                                                                            bool_qs_serialize::serialize(self.values.0,
                                                                                                                         __s)
                                                                                        }
                                                                                    }
                                                                                    &__SerializeWith{values:
                                                                                                         (&self.pinned,),
                                                                                                     phantom:
                                                                                                         _serde::export::PhantomData::<StatusesRequest<'a>>,}
                                                                                })
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "pinned")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.max_id) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "max_id",
                                                                                &self.max_id)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "max_id")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.since_id) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "since_id",
                                                                                &self.since_id)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "since_id")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.limit) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "limit",
                                                                                &self.limit)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "limit")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        if !Option::is_none(&self.min_id) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "min_id",
                                                                                &self.min_id)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "min_id")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        impl <'a> Into<Option<StatusesRequest<'a>>> for
         &'a mut StatusesRequest<'a> {
            fn into(self) -> Option<StatusesRequest<'a>> {
                Some(StatusesRequest{only_media: self.only_media,
                                     exclude_replies: self.exclude_replies,
                                     pinned: self.pinned,
                                     max_id: self.max_id.clone(),
                                     since_id: self.since_id.clone(),
                                     limit: self.limit.clone(),
                                     min_id: self.min_id.clone(),})
            }
        }
        impl <'a> StatusesRequest<'a> {
            /// Construct a new `StatusesRequest` object
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// # use elefren::StatusesRequest;
            /// let request = StatusesRequest::new();
            /// ```
            pub fn new() -> Self { Self::default() }
            /// Set the `?only_media=1` flag for the .statuses() request
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// # use elefren::StatusesRequest;
            /// let mut request = StatusesRequest::new();
            /// assert_eq!(&request.only_media().to_querystring().expect("Couldn't serialize qs"), "?only_media=1");
            pub fn only_media(&mut self) -> &mut Self {
                self.only_media = true;
                self
            }
            /// Set the `?exclude_replies=1` flag for the .statuses() request
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// # use elefren::StatusesRequest;
            /// let mut request = StatusesRequest::new();
            /// assert_eq!(
            ///     &request
            ///         .exclude_replies()
            ///         .to_querystring()
            ///         .expect("Couldn't serialize qs"),
            ///     "?exclude_replies=1"
            /// );
            /// ```
            pub fn exclude_replies(&mut self) -> &mut Self {
                self.exclude_replies = true;
                self
            }
            /// Set the `?pinned=1` flag for the .statuses() request
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// # use elefren::StatusesRequest;
            /// let mut request = StatusesRequest::new();
            /// assert_eq!(
            ///     &request
            ///         .pinned()
            ///         .to_querystring()
            ///         .expect("Couldn't serialize qs"),
            ///     "?pinned=1"
            /// );
            /// ```
            pub fn pinned(&mut self) -> &mut Self { self.pinned = true; self }
            /// Set the `?max_id=:max_id` flag for the .statuses() request
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// # use elefren::StatusesRequest;
            /// let mut request = StatusesRequest::new();
            /// assert_eq!(
            ///     &request
            ///         .max_id("foo")
            ///         .to_querystring()
            ///         .expect("Couldn't serialize qs"),
            ///     "?max_id=foo"
            /// );
            /// ```
            pub fn max_id<S: Into<Cow<'a, str>>>(&mut self, max_id: S)
             -> &mut Self {
                self.max_id = Some(max_id.into());
                self
            }
            /// Set the `?since_id=:since_id` flag for the .statuses() request
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// # use elefren::StatusesRequest;
            /// let mut request = StatusesRequest::new();
            /// assert_eq!(
            ///     &request
            ///         .since_id("foo")
            ///         .to_querystring()
            ///         .expect("Couldn't serialize qs"),
            ///     "?since_id=foo"
            /// );
            /// ```
            pub fn since_id<S: Into<Cow<'a, str>>>(&mut self, since_id: S)
             -> &mut Self {
                self.since_id = Some(since_id.into());
                self
            }
            /// Set the `?limit=:limit` flag for the .statuses() request
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// # use elefren::StatusesRequest;
            /// let mut request = StatusesRequest::new();
            /// assert_eq!(
            ///     &request
            ///         .limit(10)
            ///         .to_querystring()
            ///         .expect("Couldn't serialize qs"),
            ///     "?limit=10"
            /// );
            /// ```
            pub fn limit(&mut self, limit: usize) -> &mut Self {
                self.limit = Some(limit);
                self
            }
            /// Set the `?min_id=:min_id` flag for the .statuses() request
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// # use elefren::StatusesRequest;
            /// let mut request = StatusesRequest::new();
            /// assert_eq!(
            ///     &request
            ///         .min_id("foobar")
            ///         .to_querystring()
            ///         .expect("Couldn't serialize qs"),
            ///     "?min_id=foobar"
            /// );
            /// ```
            pub fn min_id<S: Into<Cow<'a, str>>>(&mut self, min_id: S)
             -> &mut Self {
                self.min_id = Some(min_id.into());
                self
            }
            /// Turns this builder into a querystring
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// # use elefren::StatusesRequest;
            /// let mut request = StatusesRequest::new();
            /// assert_eq!(
            ///     &request
            ///         .limit(10)
            ///         .pinned()
            ///         .to_querystring()
            ///         .expect("Couldn't serialize qs"),
            ///     "?pinned=1&limit=10"
            /// );
            /// ```
            pub fn to_querystring(&self) -> Result<String, Error> {
                Ok({
                       let res =
                           ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["?"],
                                                                               &match (&serde_qs::to_string(&self)?,)
                                                                                    {
                                                                                    (arg0,)
                                                                                    =>
                                                                                    [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                  ::core::fmt::Display::fmt)],
                                                                                }));
                       res
                   })
            }
        }
    }
    mod update_credentials {
        use std::{fmt::Display, path::{Path, PathBuf}};
        use crate::entities::account::{Credentials, MetadataField,
                                       UpdateSource};
        use crate::errors::Result;
        use crate::status_builder;
        /// Builder to pass to the Mastodon::update_credentials method
        ///
        /// # Example
        ///
        /// ```no_run
        /// # extern crate elefren;
        /// # use elefren::Data;
        /// # fn main() -> Result<(), elefren::Error> {
        /// # let data = Data {
        /// #   base: "".into(),
        /// #   client_id: "".into(),
        /// #   client_secret: "".into(),
        /// #   redirect: "".into(),
        /// #   token: "".into(),
        /// # };
        /// use elefren::{prelude::*, status_builder::Visibility, UpdateCredsRequest};
        ///
        /// let client = Mastodon::from(data);
        /// let mut builder = UpdateCredsRequest::new();
        ///
        /// builder.privacy(Visibility::Unlisted);
        ///
        /// let result = client.update_credentials(&mut builder)?;
        /// #   Ok(())
        /// # }
        /// ```
        pub struct UpdateCredsRequest {
            display_name: Option<String>,
            note: Option<String>,
            avatar: Option<PathBuf>,
            header: Option<PathBuf>,
            field_attributes: Vec<MetadataField>,
            privacy: Option<status_builder::Visibility>,
            sensitive: Option<bool>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for UpdateCredsRequest {
            fn fmt(&self, f: &mut ::core::fmt::Formatter)
             -> ::core::fmt::Result {
                match *self {
                    UpdateCredsRequest {
                    display_name: ref __self_0_0,
                    note: ref __self_0_1,
                    avatar: ref __self_0_2,
                    header: ref __self_0_3,
                    field_attributes: ref __self_0_4,
                    privacy: ref __self_0_5,
                    sensitive: ref __self_0_6 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("UpdateCredsRequest");
                        let _ =
                            debug_trait_builder.field("display_name",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("note",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("avatar",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("header",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("field_attributes",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("privacy",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("sensitive",
                                                      &&(*__self_0_6));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for UpdateCredsRequest {
            #[inline]
            fn default() -> UpdateCredsRequest {
                UpdateCredsRequest{display_name:
                                       ::core::default::Default::default(),
                                   note: ::core::default::Default::default(),
                                   avatar:
                                       ::core::default::Default::default(),
                                   header:
                                       ::core::default::Default::default(),
                                   field_attributes:
                                       ::core::default::Default::default(),
                                   privacy:
                                       ::core::default::Default::default(),
                                   sensitive:
                                       ::core::default::Default::default(),}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for UpdateCredsRequest {
            #[inline]
            fn clone(&self) -> UpdateCredsRequest {
                match *self {
                    UpdateCredsRequest {
                    display_name: ref __self_0_0,
                    note: ref __self_0_1,
                    avatar: ref __self_0_2,
                    header: ref __self_0_3,
                    field_attributes: ref __self_0_4,
                    privacy: ref __self_0_5,
                    sensitive: ref __self_0_6 } =>
                    UpdateCredsRequest{display_name:
                                           ::core::clone::Clone::clone(&(*__self_0_0)),
                                       note:
                                           ::core::clone::Clone::clone(&(*__self_0_1)),
                                       avatar:
                                           ::core::clone::Clone::clone(&(*__self_0_2)),
                                       header:
                                           ::core::clone::Clone::clone(&(*__self_0_3)),
                                       field_attributes:
                                           ::core::clone::Clone::clone(&(*__self_0_4)),
                                       privacy:
                                           ::core::clone::Clone::clone(&(*__self_0_5)),
                                       sensitive:
                                           ::core::clone::Clone::clone(&(*__self_0_6)),},
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for UpdateCredsRequest { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for UpdateCredsRequest {
            #[inline]
            fn eq(&self, other: &UpdateCredsRequest) -> bool {
                match *other {
                    UpdateCredsRequest {
                    display_name: ref __self_1_0,
                    note: ref __self_1_1,
                    avatar: ref __self_1_2,
                    header: ref __self_1_3,
                    field_attributes: ref __self_1_4,
                    privacy: ref __self_1_5,
                    sensitive: ref __self_1_6 } =>
                    match *self {
                        UpdateCredsRequest {
                        display_name: ref __self_0_0,
                        note: ref __self_0_1,
                        avatar: ref __self_0_2,
                        header: ref __self_0_3,
                        field_attributes: ref __self_0_4,
                        privacy: ref __self_0_5,
                        sensitive: ref __self_0_6 } =>
                        (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1) &&
                            (*__self_0_2) == (*__self_1_2) &&
                            (*__self_0_3) == (*__self_1_3) &&
                            (*__self_0_4) == (*__self_1_4) &&
                            (*__self_0_5) == (*__self_1_5) &&
                            (*__self_0_6) == (*__self_1_6),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &UpdateCredsRequest) -> bool {
                match *other {
                    UpdateCredsRequest {
                    display_name: ref __self_1_0,
                    note: ref __self_1_1,
                    avatar: ref __self_1_2,
                    header: ref __self_1_3,
                    field_attributes: ref __self_1_4,
                    privacy: ref __self_1_5,
                    sensitive: ref __self_1_6 } =>
                    match *self {
                        UpdateCredsRequest {
                        display_name: ref __self_0_0,
                        note: ref __self_0_1,
                        avatar: ref __self_0_2,
                        header: ref __self_0_3,
                        field_attributes: ref __self_0_4,
                        privacy: ref __self_0_5,
                        sensitive: ref __self_0_6 } =>
                        (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1) ||
                            (*__self_0_2) != (*__self_1_2) ||
                            (*__self_0_3) != (*__self_1_3) ||
                            (*__self_0_4) != (*__self_1_4) ||
                            (*__self_0_5) != (*__self_1_5) ||
                            (*__self_0_6) != (*__self_1_6),
                    },
                }
            }
        }
        impl UpdateCredsRequest {
            /// Create a new UpdateCredsRequest
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::UpdateCredsRequest;
            ///
            /// let mut builder = UpdateCredsRequest::new();
            /// ```
            pub fn new() -> UpdateCredsRequest { Default::default() }
            /// Set the new display_name value
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::UpdateCredsRequest;
            ///
            /// let mut builder = UpdateCredsRequest::new();
            ///
            /// builder.display_name("my new display name");
            /// ```
            pub fn display_name<D: Display>(&mut self, name: D) -> &mut Self {
                self.display_name = Some(name.to_string());
                self
            }
            /// Set the new note value
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::UpdateCredsRequest;
            ///
            /// let mut builder = UpdateCredsRequest::new();
            ///
            /// builder.note("my new note");
            /// ```
            pub fn note<D: Display>(&mut self, note: D) -> &mut Self {
                self.note = Some(note.to_string());
                self
            }
            /// Set the new avatar value
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::UpdateCredsRequest;
            ///
            /// let mut builder = UpdateCredsRequest::new();
            ///
            /// builder.avatar("/path/to/my/new/avatar");
            /// ```
            pub fn avatar<P: AsRef<Path>>(&mut self, path: P) -> &mut Self {
                let path = path.as_ref();
                let path = path.to_path_buf();
                self.avatar = Some(path);
                self
            }
            /// Set the new header value
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::UpdateCredsRequest;
            ///
            /// let mut builder = UpdateCredsRequest::new();
            ///
            /// builder.header("/path/to/my/new/header");
            /// ```
            pub fn header<P: AsRef<Path>>(&mut self, path: P) -> &mut Self {
                let path = path.as_ref();
                let path = path.to_path_buf();
                self.header = Some(path);
                self
            }
            /// Set the new privacy value
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::{status_builder::Visibility, UpdateCredsRequest};
            ///
            /// let mut builder = UpdateCredsRequest::new();
            ///
            /// builder.privacy(Visibility::Public);
            /// ```
            pub fn privacy(&mut self, privacy: status_builder::Visibility)
             -> &mut Self {
                self.privacy = Some(privacy);
                self
            }
            /// Set the new sensitive value
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::UpdateCredsRequest;
            ///
            /// let mut builder = UpdateCredsRequest::new();
            ///
            /// builder.sensitive(true);
            /// ```
            pub fn sensitive(&mut self, sensitive: bool) -> &mut Self {
                self.sensitive = Some(sensitive);
                self
            }
            /// Add a metadata field
            ///
            /// # Example
            ///
            /// ```
            /// # extern crate elefren;
            /// use elefren::UpdateCredsRequest;
            ///
            /// let mut builder = UpdateCredsRequest::new();
            ///
            /// builder.field_attribute("some key", "some value");
            /// ```
            pub fn field_attribute(&mut self, name: &str, value: &str)
             -> &mut Self {
                self.field_attributes.push(MetadataField::new(name, value));
                self
            }
            pub(crate) fn build(&mut self) -> Result<Credentials> {
                Ok(Credentials{display_name: self.display_name.clone(),
                               note: self.note.clone(),
                               avatar: self.avatar.clone(),
                               header: self.avatar.clone(),
                               source:
                                   Some(UpdateSource{privacy:
                                                         self.privacy.clone(),
                                                     sensitive:
                                                         self.sensitive.clone(),}),
                               fields_attributes:
                                   self.field_attributes.clone(),})
            }
        }
    }
}
/// OAuth Scopes
pub mod scopes {
    use std::{cmp::{Ordering, PartialEq, PartialOrd}, collections::HashSet,
              fmt, ops::BitOr, str::FromStr};
    use serde::ser::{Serialize, Serializer};
    use crate::errors::Error;
    use serde::{Deserialize, Deserializer};
    use serde::de::{self, Visitor};
    /// Represents a set of OAuth scopes
    ///
    /// # Example
    ///
    /// ```rust
    /// use elefren::prelude::*;
    ///
    /// let read = Scopes::read_all();
    /// let write = Scopes::write_all();
    /// let follow = Scopes::follow();
    /// let all = read | write | follow;
    /// ```
    pub struct Scopes {
        scopes: HashSet<Scope>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Scopes {
        #[inline]
        fn clone(&self) -> Scopes {
            match *self {
                Scopes { scopes: ref __self_0_0 } =>
                Scopes{scopes: ::core::clone::Clone::clone(&(*__self_0_0)),},
            }
        }
    }
    impl FromStr for Scopes {
        type Err = Error;
        fn from_str(s: &str) -> Result<Scopes, Self::Err> {
            let mut set = HashSet::new();
            for scope in s.split_whitespace() {
                let scope = Scope::from_str(&scope)?;
                set.insert(scope);
            }
            Ok(Scopes{scopes: set,})
        }
    }
    impl Serialize for Scopes {
        fn serialize<S>(&self, serializer: S)
         -> ::std::result::Result<S::Ok, S::Error> where S: Serializer {
            let repr =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&self,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                };
            serializer.serialize_str(&repr)
        }
    }
    struct DeserializeScopesVisitor;
    impl <'de> Visitor<'de> for DeserializeScopesVisitor {
        type Value = Scopes;
        fn expecting(&self, formatter: &mut fmt::Formatter)
         -> Result<(), fmt::Error> {
            formatter.write_fmt(::core::fmt::Arguments::new_v1(&["space separated scopes"],
                                                               &match () {
                                                                    () => [],
                                                                }))
        }
        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E> where
         E: de::Error {
            Scopes::from_str(v).map_err(de::Error::custom)
        }
    }
    impl <'de> Deserialize<'de> for Scopes {
        fn deserialize<D>(deserializer: D)
         -> Result<Self, <D as Deserializer<'de>>::Error> where
         D: Deserializer<'de> {
            deserializer.deserialize_str(DeserializeScopesVisitor)
        }
    }
    impl Scopes {
        /// Represents all available oauth scopes: "read write follow push"
        ///
        /// ```
        /// # extern crate elefren;
        /// # use std::error::Error;
        /// use elefren::scopes::Scopes;
        ///
        /// # fn main() -> Result<(), Box<Error>> {
        /// let scope = Scopes::all();
        /// assert_eq!(&format!("{}", scope), "read write follow push");
        /// #   Ok(())
        /// # }
        /// ```
        pub fn all() -> Scopes {
            Scopes::read_all() | Scopes::write_all() | Scopes::follow() |
                Scopes::push()
        }
        /// Represents the full "read" scope
        ///
        /// ```
        /// # extern crate elefren;
        /// # use std::error::Error;
        /// use elefren::scopes::Scopes;
        ///
        /// # fn main() -> Result<(), Box<Error>> {
        /// let scope = Scopes::read_all();
        /// assert_eq!(&format!("{}", scope), "read");
        /// #   Ok(())
        /// # }
        /// ```
        pub fn read_all() -> Scopes { Scopes::_read(None) }
        /// Represents a specific "read:___" scope
        ///
        /// ```
        /// # extern crate elefren;
        /// # use std::error::Error;
        /// use elefren::scopes::{Read, Scopes};
        ///
        /// # fn main() -> Result<(), Box<Error>> {
        /// let scope = Scopes::read(Read::Accounts);
        /// assert_eq!(&format!("{}", scope), "read:accounts");
        /// #   Ok(())
        /// # }
        /// ```
        pub fn read(subscope: Read) -> Scopes {
            Scopes::_read(Some(subscope))
        }
        /// Represents the full "write" scope
        ///
        /// ```
        /// # extern crate elefren;
        /// # use std::error::Error;
        /// use elefren::scopes::Scopes;
        ///
        /// # fn main() -> Result<(), Box<Error>> {
        /// let scope = Scopes::write_all();
        /// assert_eq!(&format!("{}", scope), "write");
        /// #   Ok(())
        /// # }
        /// ```
        pub fn write_all() -> Scopes { Scopes::_write(None) }
        /// Represents a specific "write:___" scope
        ///
        /// ```
        /// # extern crate elefren;
        /// # use std::error::Error;
        /// use elefren::scopes::{Scopes, Write};
        ///
        /// # fn main() -> Result<(), Box<Error>> {
        /// let scope = Scopes::write(Write::Accounts);
        /// assert_eq!(&format!("{}", scope), "write:accounts");
        /// #   Ok(())
        /// # }
        /// ```
        pub fn write(subscope: Write) -> Scopes {
            Scopes::_write(Some(subscope))
        }
        /// Represents the "follow" scope
        ///
        /// ```
        /// # extern crate elefren;
        /// # use std::error::Error;
        /// use elefren::scopes::Scopes;
        ///
        /// # fn main() -> Result<(), Box<Error>> {
        /// let scope = Scopes::follow();
        /// assert_eq!(&format!("{}", scope), "follow");
        /// #   Ok(())
        /// # }
        /// ```
        pub fn follow() -> Scopes { Scopes::new(Scope::Follow) }
        /// Represents the full "push" scope
        ///
        /// ```
        /// # extern crate elefren;
        /// # use std::error::Error;
        /// use elefren::scopes::Scopes;
        ///
        /// # fn main() -> Result<(), Box<Error>> {
        /// let scope = Scopes::push();
        /// assert_eq!(&format!("{}", scope), "push");
        /// #   Ok(())
        /// # }
        /// ```
        pub fn push() -> Scopes { Scopes::new(Scope::Push) }
        /// Combines 2 scopes together
        ///
        /// # Example
        ///
        /// ```rust
        /// use elefren::prelude::*;
        ///
        /// let read = Scopes::read_all();
        /// let write = Scopes::write_all();
        /// let read_write = read.and(write);
        /// ```
        pub fn and(self, other: Scopes) -> Scopes {
            let newset: HashSet<_> =
                self.scopes.union(&other.scopes).into_iter().map(|s|
                                                                     *s).collect();
            Scopes{scopes: newset,}
        }
        fn _write(subscope: Option<Write>) -> Scopes {
            Scopes::new(Scope::Write(subscope))
        }
        fn _read(subscope: Option<Read>) -> Scopes {
            Scopes::new(Scope::Read(subscope))
        }
        fn new(scope: Scope) -> Scopes {
            let mut set = HashSet::new();
            set.insert(scope);
            Scopes{scopes: set,}
        }
    }
    impl BitOr for Scopes {
        type Output = Scopes;
        fn bitor(self, other: Scopes) -> Self::Output { self.and(other) }
    }
    impl PartialEq for Scopes {
        fn eq(&self, other: &Scopes) -> bool {
            self.scopes.symmetric_difference(&other.scopes).next().is_none()
        }
    }
    impl Default for Scopes {
        fn default() -> Scopes { Scopes::read_all() }
    }
    impl fmt::Debug for Scopes {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&["["],
                                                       &match () {
                                                            () => [],
                                                        }))?;
            for scope in &self.scopes {
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&&scope,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Debug::fmt)],
                                                            }))?;
            }
            Ok(f.write_fmt(::core::fmt::Arguments::new_v1(&["]"],
                                                          &match () {
                                                               () => [],
                                                           }))?)
        }
    }
    impl fmt::Display for Scopes {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let mut start = true;
            let scopes =
                {
                    let mut scopes = self.scopes.iter().collect::<Vec<_>>();
                    scopes.sort();
                    scopes
                };
            for scope in &scopes {
                if !start {
                    f.write_fmt(::core::fmt::Arguments::new_v1(&[" "],
                                                               &match () {
                                                                    () => [],
                                                                }))?;
                } else { start = false; }
                f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                           &match (&&scope,) {
                                                                (arg0,) =>
                                                                [::core::fmt::ArgumentV1::new(arg0,
                                                                                              ::core::fmt::Display::fmt)],
                                                            }))?;
            }
            Ok(())
        }
    }
    /// Permission scope of the application.
    /// [Details on what each permission provides][1]
    /// [1]: https://github.com/tootsuite/documentation/blob/master/Using-the-API/OAuth-details.md)
    enum Scope {

        /// Read only permissions.
        #[serde(rename = "read")]
        Read(Option<Read>),

        /// Write only permissions.
        #[serde(rename = "write")]
        Write(Option<Write>),

        /// Only permission to add and remove followers.
        #[serde(rename = "follow")]
        Follow,

        /// Push permissions
        #[serde(rename = "push")]
        Push,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Scope {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Scope::Read(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Read");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Scope::Write(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Write");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Scope::Follow,) => {
                    let mut debug_trait_builder = f.debug_tuple("Follow");
                    debug_trait_builder.finish()
                }
                (&Scope::Push,) => {
                    let mut debug_trait_builder = f.debug_tuple("Push");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Scope {
        #[inline]
        fn clone(&self) -> Scope {
            {
                let _: ::core::clone::AssertParamIsClone<Option<Read>>;
                let _: ::core::clone::AssertParamIsClone<Option<Write>>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Scope { }
    impl ::core::marker::StructuralPartialEq for Scope { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Scope {
        #[inline]
        fn eq(&self, other: &Scope) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Scope::Read(ref __self_0),
                         &Scope::Read(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        (&Scope::Write(ref __self_0),
                         &Scope::Write(ref __arg_1_0)) =>
                        (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, other: &Scope) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Scope::Read(ref __self_0),
                         &Scope::Read(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        (&Scope::Write(ref __self_0),
                         &Scope::Write(ref __arg_1_0)) =>
                        (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for Scope {
        #[inline]
        fn partial_cmp(&self, other: &Scope)
         -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Scope::Read(ref __self_0),
                         &Scope::Read(ref __arg_1_0)) =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                   &(*__arg_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                            cmp => cmp,
                        },
                        (&Scope::Write(ref __self_0),
                         &Scope::Write(ref __arg_1_0)) =>
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                   &(*__arg_1_0))
                            {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            =>
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                            cmp => cmp,
                        },
                        _ =>
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else { __self_vi.partial_cmp(&__arg_1_vi) }
            }
        }
        #[inline]
        fn lt(&self, other: &Scope) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Scope::Read(ref __self_0),
                         &Scope::Read(ref __arg_1_0)) =>
                        ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                               &(*__arg_1_0)),
                                                          ::core::cmp::Ordering::Greater)
                            == ::core::cmp::Ordering::Less,
                        (&Scope::Write(ref __self_0),
                         &Scope::Write(ref __arg_1_0)) =>
                        ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                               &(*__arg_1_0)),
                                                          ::core::cmp::Ordering::Greater)
                            == ::core::cmp::Ordering::Less,
                        _ => false,
                    }
                } else { __self_vi.lt(&__arg_1_vi) }
            }
        }
        #[inline]
        fn le(&self, other: &Scope) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Scope::Read(ref __self_0),
                         &Scope::Read(ref __arg_1_0)) =>
                        ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                               &(*__arg_1_0)),
                                                          ::core::cmp::Ordering::Greater)
                            != ::core::cmp::Ordering::Greater,
                        (&Scope::Write(ref __self_0),
                         &Scope::Write(ref __arg_1_0)) =>
                        ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                               &(*__arg_1_0)),
                                                          ::core::cmp::Ordering::Greater)
                            != ::core::cmp::Ordering::Greater,
                        _ => true,
                    }
                } else { __self_vi.le(&__arg_1_vi) }
            }
        }
        #[inline]
        fn gt(&self, other: &Scope) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Scope::Read(ref __self_0),
                         &Scope::Read(ref __arg_1_0)) =>
                        ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                               &(*__arg_1_0)),
                                                          ::core::cmp::Ordering::Less)
                            == ::core::cmp::Ordering::Greater,
                        (&Scope::Write(ref __self_0),
                         &Scope::Write(ref __arg_1_0)) =>
                        ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                               &(*__arg_1_0)),
                                                          ::core::cmp::Ordering::Less)
                            == ::core::cmp::Ordering::Greater,
                        _ => false,
                    }
                } else { __self_vi.gt(&__arg_1_vi) }
            }
        }
        #[inline]
        fn ge(&self, other: &Scope) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Scope::Read(ref __self_0),
                         &Scope::Read(ref __arg_1_0)) =>
                        ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                               &(*__arg_1_0)),
                                                          ::core::cmp::Ordering::Less)
                            != ::core::cmp::Ordering::Less,
                        (&Scope::Write(ref __self_0),
                         &Scope::Write(ref __arg_1_0)) =>
                        ::core::option::Option::unwrap_or(::core::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                               &(*__arg_1_0)),
                                                          ::core::cmp::Ordering::Less)
                            != ::core::cmp::Ordering::Less,
                        _ => true,
                    }
                } else { __self_vi.ge(&__arg_1_vi) }
            }
        }
    }
    impl ::core::marker::StructuralEq for Scope { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Scope {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Option<Read>>;
                let _: ::core::cmp::AssertParamIsEq<Option<Write>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for Scope {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                (&Scope::Read(ref __self_0),) => {
                    ::core::hash::Hash::hash(&unsafe {
                                                  ::core::intrinsics::discriminant_value(self)
                                              }, state);
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
                (&Scope::Write(ref __self_0),) => {
                    ::core::hash::Hash::hash(&unsafe {
                                                  ::core::intrinsics::discriminant_value(self)
                                              }, state);
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
                _ => {
                    ::core::hash::Hash::hash(&unsafe {
                                                  ::core::intrinsics::discriminant_value(self)
                                              }, state)
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Scope: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl _serde::Serialize for Scope {
                fn serialize<__S>(&self, __serializer: __S)
                 -> _serde::export::Result<__S::Ok, __S::Error> where
                 __S: _serde::Serializer {
                    match *self {
                        Scope::Read(ref __field0) =>
                        _serde::Serializer::serialize_newtype_variant(__serializer,
                                                                      "Scope",
                                                                      0u32,
                                                                      "read",
                                                                      __field0),
                        Scope::Write(ref __field0) =>
                        _serde::Serializer::serialize_newtype_variant(__serializer,
                                                                      "Scope",
                                                                      1u32,
                                                                      "write",
                                                                      __field0),
                        Scope::Follow =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Scope",
                                                                   2u32,
                                                                   "follow"),
                        Scope::Push =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Scope",
                                                                   3u32,
                                                                   "push"),
                    }
                }
            }
        };
    impl FromStr for Scope {
        type Err = Error;
        fn from_str(s: &str) -> Result<Scope, Self::Err> {
            Ok(match s {
                   "read" => Scope::Read(None),
                   "write" => Scope::Write(None),
                   "follow" => Scope::Follow,
                   "push" => Scope::Push,
                   read if read.starts_with("read:") => {
                       let r: Read = Read::from_str(&read[5..])?;
                       Scope::Read(Some(r))
                   }
                   write if write.starts_with("write:") => {
                       let w: Write = Write::from_str(&write[6..])?;
                       Scope::Write(Some(w))
                   }
                   _ => return Err(Error::Other("Unknown scope".to_string())),
               })
        }
    }
    impl Ord for Scope {
        fn cmp(&self, other: &Scope) -> Ordering {
            match (*self, *other) {
                (Scope::Read(None), Scope::Read(None)) => Ordering::Equal,
                (Scope::Read(None), Scope::Read(Some(..))) => Ordering::Less,
                (Scope::Read(Some(..)), Scope::Read(None)) =>
                Ordering::Greater,
                (Scope::Read(Some(ref a)), Scope::Read(Some(ref b))) =>
                a.cmp(b),
                (Scope::Write(None), Scope::Write(None)) => Ordering::Equal,
                (Scope::Write(None), Scope::Write(Some(..))) =>
                Ordering::Less,
                (Scope::Write(Some(..)), Scope::Write(None)) =>
                Ordering::Greater,
                (Scope::Write(Some(ref a)), Scope::Write(Some(ref b))) =>
                a.cmp(b),
                (Scope::Read(..), Scope::Write(..)) => Ordering::Less,
                (Scope::Read(..), Scope::Follow) => Ordering::Less,
                (Scope::Read(..), Scope::Push) => Ordering::Less,
                (Scope::Write(..), Scope::Read(..)) => Ordering::Greater,
                (Scope::Write(..), Scope::Follow) => Ordering::Less,
                (Scope::Write(..), Scope::Push) => Ordering::Less,
                (Scope::Follow, Scope::Read(..)) => Ordering::Greater,
                (Scope::Follow, Scope::Write(..)) => Ordering::Greater,
                (Scope::Follow, Scope::Follow) => Ordering::Equal,
                (Scope::Follow, Scope::Push) => Ordering::Less,
                (Scope::Push, Scope::Push) => Ordering::Equal,
                (Scope::Push, _) => Ordering::Greater,
            }
        }
    }
    impl fmt::Display for Scope {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            use self::Scope::*;
            let s =
                match *self {
                    Read(Some(ref r)) => return fmt::Display::fmt(r, f),
                    Read(None) => "read",
                    Write(Some(ref w)) => return fmt::Display::fmt(w, f),
                    Write(None) => "write",
                    Follow => "follow",
                    Push => "push",
                };
            f.write_fmt(::core::fmt::Arguments::new_v1(&[""],
                                                       &match (&s,) {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    impl Default for Scope {
        fn default() -> Self { Scope::Read(None) }
    }
    /// Represents the granular "read:___" oauth scopes
    pub enum Read {

        /// Accounts
        #[serde(rename = "accounts")]
        Accounts,

        /// Blocks
        #[serde(rename = "blocks")]
        Blocks,

        /// Favourites
        #[serde(rename = "favourites")]
        Favourites,

        /// Filters
        #[serde(rename = "filters")]
        Filters,

        /// Follows
        #[serde(rename = "follows")]
        Follows,

        /// Lists
        #[serde(rename = "lists")]
        Lists,

        /// Mutes
        #[serde(rename = "mutes")]
        Mutes,

        /// Notifications
        #[serde(rename = "notifications")]
        Notifications,

        /// Reports
        #[serde(rename = "reports")]
        Reports,

        /// Search
        #[serde(rename = "search")]
        Search,

        /// Statuses
        #[serde(rename = "statuses")]
        Statuses,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Read {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Read::Accounts,) => {
                    let mut debug_trait_builder = f.debug_tuple("Accounts");
                    debug_trait_builder.finish()
                }
                (&Read::Blocks,) => {
                    let mut debug_trait_builder = f.debug_tuple("Blocks");
                    debug_trait_builder.finish()
                }
                (&Read::Favourites,) => {
                    let mut debug_trait_builder = f.debug_tuple("Favourites");
                    debug_trait_builder.finish()
                }
                (&Read::Filters,) => {
                    let mut debug_trait_builder = f.debug_tuple("Filters");
                    debug_trait_builder.finish()
                }
                (&Read::Follows,) => {
                    let mut debug_trait_builder = f.debug_tuple("Follows");
                    debug_trait_builder.finish()
                }
                (&Read::Lists,) => {
                    let mut debug_trait_builder = f.debug_tuple("Lists");
                    debug_trait_builder.finish()
                }
                (&Read::Mutes,) => {
                    let mut debug_trait_builder = f.debug_tuple("Mutes");
                    debug_trait_builder.finish()
                }
                (&Read::Notifications,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("Notifications");
                    debug_trait_builder.finish()
                }
                (&Read::Reports,) => {
                    let mut debug_trait_builder = f.debug_tuple("Reports");
                    debug_trait_builder.finish()
                }
                (&Read::Search,) => {
                    let mut debug_trait_builder = f.debug_tuple("Search");
                    debug_trait_builder.finish()
                }
                (&Read::Statuses,) => {
                    let mut debug_trait_builder = f.debug_tuple("Statuses");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Read {
        #[inline]
        fn clone(&self) -> Read { { *self } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Read { }
    impl ::core::marker::StructuralPartialEq for Read { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Read {
        #[inline]
        fn eq(&self, other: &Read) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    impl ::core::marker::StructuralEq for Read { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Read {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () { { } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for Read {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => {
                    ::core::hash::Hash::hash(&unsafe {
                                                  ::core::intrinsics::discriminant_value(self)
                                              }, state)
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Read: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl _serde::Serialize for Read {
                fn serialize<__S>(&self, __serializer: __S)
                 -> _serde::export::Result<__S::Ok, __S::Error> where
                 __S: _serde::Serializer {
                    match *self {
                        Read::Accounts =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   0u32,
                                                                   "accounts"),
                        Read::Blocks =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   1u32,
                                                                   "blocks"),
                        Read::Favourites =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   2u32,
                                                                   "favourites"),
                        Read::Filters =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   3u32,
                                                                   "filters"),
                        Read::Follows =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   4u32,
                                                                   "follows"),
                        Read::Lists =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   5u32,
                                                                   "lists"),
                        Read::Mutes =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   6u32,
                                                                   "mutes"),
                        Read::Notifications =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   7u32,
                                                                   "notifications"),
                        Read::Reports =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   8u32,
                                                                   "reports"),
                        Read::Search =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   9u32,
                                                                   "search"),
                        Read::Statuses =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Read",
                                                                   10u32,
                                                                   "statuses"),
                    }
                }
            }
        };
    impl FromStr for Read {
        type Err = Error;
        fn from_str(s: &str) -> Result<Read, Self::Err> {
            Ok(match s {
                   "accounts" => Read::Accounts,
                   "blocks" => Read::Blocks,
                   "favourites" => Read::Favourites,
                   "filters" => Read::Filters,
                   "follows" => Read::Follows,
                   "lists" => Read::Lists,
                   "mutes" => Read::Mutes,
                   "notifications" => Read::Notifications,
                   "reports" => Read::Reports,
                   "search" => Read::Search,
                   "statuses" => Read::Statuses,
                   _ =>
                   return Err(Error::Other("Unknown 'read' subcategory".to_string())),
               })
        }
    }
    impl PartialOrd for Read {
        fn partial_cmp(&self, other: &Read) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }
    impl Ord for Read {
        fn cmp(&self, other: &Read) -> Ordering {
            let a =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&self,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Debug::fmt)],
                                                                             }));
                    res
                };
            let b =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&other,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Debug::fmt)],
                                                                             }));
                    res
                };
            a.cmp(&b)
        }
    }
    impl fmt::Display for Read {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&["read:"],
                                                       &match (&match *self {
                                                                    Read::Accounts
                                                                    =>
                                                                    "accounts",
                                                                    Read::Blocks
                                                                    =>
                                                                    "blocks",
                                                                    Read::Favourites
                                                                    =>
                                                                    "favourites",
                                                                    Read::Filters
                                                                    =>
                                                                    "filters",
                                                                    Read::Follows
                                                                    =>
                                                                    "follows",
                                                                    Read::Lists
                                                                    =>
                                                                    "lists",
                                                                    Read::Mutes
                                                                    =>
                                                                    "mutes",
                                                                    Read::Notifications
                                                                    =>
                                                                    "notifications",
                                                                    Read::Reports
                                                                    =>
                                                                    "reports",
                                                                    Read::Search
                                                                    =>
                                                                    "search",
                                                                    Read::Statuses
                                                                    =>
                                                                    "statuses",
                                                                },) {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
    /// Represents the granular "write:___" oauth scopes
    pub enum Write {

        /// Accounts
        #[serde(rename = "accounts")]
        Accounts,

        /// Blocks
        #[serde(rename = "blocks")]
        Blocks,

        /// Favourites
        #[serde(rename = "favourites")]
        Favourites,

        /// Filters
        #[serde(rename = "filters")]
        Filters,

        /// Follows
        #[serde(rename = "follows")]
        Follows,

        /// Lists
        #[serde(rename = "lists")]
        Lists,

        /// Media
        #[serde(rename = "media")]
        Media,

        /// Mutes
        #[serde(rename = "mutes")]
        Mutes,

        /// Notifications
        #[serde(rename = "notifications")]
        Notifications,

        /// Reports
        #[serde(rename = "reports")]
        Reports,

        /// Statuses
        #[serde(rename = "statuses")]
        Statuses,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Write {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Write::Accounts,) => {
                    let mut debug_trait_builder = f.debug_tuple("Accounts");
                    debug_trait_builder.finish()
                }
                (&Write::Blocks,) => {
                    let mut debug_trait_builder = f.debug_tuple("Blocks");
                    debug_trait_builder.finish()
                }
                (&Write::Favourites,) => {
                    let mut debug_trait_builder = f.debug_tuple("Favourites");
                    debug_trait_builder.finish()
                }
                (&Write::Filters,) => {
                    let mut debug_trait_builder = f.debug_tuple("Filters");
                    debug_trait_builder.finish()
                }
                (&Write::Follows,) => {
                    let mut debug_trait_builder = f.debug_tuple("Follows");
                    debug_trait_builder.finish()
                }
                (&Write::Lists,) => {
                    let mut debug_trait_builder = f.debug_tuple("Lists");
                    debug_trait_builder.finish()
                }
                (&Write::Media,) => {
                    let mut debug_trait_builder = f.debug_tuple("Media");
                    debug_trait_builder.finish()
                }
                (&Write::Mutes,) => {
                    let mut debug_trait_builder = f.debug_tuple("Mutes");
                    debug_trait_builder.finish()
                }
                (&Write::Notifications,) => {
                    let mut debug_trait_builder =
                        f.debug_tuple("Notifications");
                    debug_trait_builder.finish()
                }
                (&Write::Reports,) => {
                    let mut debug_trait_builder = f.debug_tuple("Reports");
                    debug_trait_builder.finish()
                }
                (&Write::Statuses,) => {
                    let mut debug_trait_builder = f.debug_tuple("Statuses");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Write {
        #[inline]
        fn clone(&self) -> Write { { *self } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Write { }
    impl ::core::marker::StructuralPartialEq for Write { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Write {
        #[inline]
        fn eq(&self, other: &Write) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    impl ::core::marker::StructuralEq for Write { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Write {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () { { } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for Write {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => {
                    ::core::hash::Hash::hash(&unsafe {
                                                  ::core::intrinsics::discriminant_value(self)
                                              }, state)
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Write: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl _serde::Serialize for Write {
                fn serialize<__S>(&self, __serializer: __S)
                 -> _serde::export::Result<__S::Ok, __S::Error> where
                 __S: _serde::Serializer {
                    match *self {
                        Write::Accounts =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   0u32,
                                                                   "accounts"),
                        Write::Blocks =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   1u32,
                                                                   "blocks"),
                        Write::Favourites =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   2u32,
                                                                   "favourites"),
                        Write::Filters =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   3u32,
                                                                   "filters"),
                        Write::Follows =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   4u32,
                                                                   "follows"),
                        Write::Lists =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   5u32,
                                                                   "lists"),
                        Write::Media =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   6u32,
                                                                   "media"),
                        Write::Mutes =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   7u32,
                                                                   "mutes"),
                        Write::Notifications =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   8u32,
                                                                   "notifications"),
                        Write::Reports =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   9u32,
                                                                   "reports"),
                        Write::Statuses =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Write",
                                                                   10u32,
                                                                   "statuses"),
                    }
                }
            }
        };
    impl FromStr for Write {
        type Err = Error;
        fn from_str(s: &str) -> Result<Write, Self::Err> {
            Ok(match s {
                   "accounts" => Write::Accounts,
                   "blocks" => Write::Blocks,
                   "favourites" => Write::Favourites,
                   "filters" => Write::Filters,
                   "follows" => Write::Follows,
                   "lists" => Write::Lists,
                   "media" => Write::Media,
                   "mutes" => Write::Mutes,
                   "notifications" => Write::Notifications,
                   "reports" => Write::Reports,
                   "statuses" => Write::Statuses,
                   _ =>
                   return Err(Error::Other("Unknown 'write' subcategory".to_string())),
               })
        }
    }
    impl PartialOrd for Write {
        fn partial_cmp(&self, other: &Write) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }
    impl Ord for Write {
        fn cmp(&self, other: &Write) -> Ordering {
            let a =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&self,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Debug::fmt)],
                                                                             }));
                    res
                };
            let b =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&other,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Debug::fmt)],
                                                                             }));
                    res
                };
            a.cmp(&b)
        }
    }
    impl fmt::Display for Write {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&["write:"],
                                                       &match (&match *self {
                                                                    Write::Accounts
                                                                    =>
                                                                    "accounts",
                                                                    Write::Blocks
                                                                    =>
                                                                    "blocks",
                                                                    Write::Favourites
                                                                    =>
                                                                    "favourites",
                                                                    Write::Filters
                                                                    =>
                                                                    "filters",
                                                                    Write::Follows
                                                                    =>
                                                                    "follows",
                                                                    Write::Lists
                                                                    =>
                                                                    "lists",
                                                                    Write::Media
                                                                    =>
                                                                    "media",
                                                                    Write::Mutes
                                                                    =>
                                                                    "mutes",
                                                                    Write::Notifications
                                                                    =>
                                                                    "notifications",
                                                                    Write::Reports
                                                                    =>
                                                                    "reports",
                                                                    Write::Statuses
                                                                    =>
                                                                    "statuses",
                                                                },) {
                                                            (arg0,) =>
                                                            [::core::fmt::ArgumentV1::new(arg0,
                                                                                          ::core::fmt::Display::fmt)],
                                                        }))
        }
    }
}
/// Constructing a status
pub mod status_builder {
    use isolang::Language;
    /// A builder pattern struct for constructing a status.
    ///
    /// # Example
    ///
    /// ```
    /// # extern crate elefren;
    /// # use elefren::{Language, StatusBuilder};
    ///
    /// # fn main() -> Result<(), elefren::Error> {
    /// let status = StatusBuilder::new()
    ///     .status("a status")
    ///     .sensitive(true)
    ///     .spoiler_text("a CW")
    ///     .language(Language::Eng)
    ///     .build()?;
    /// # Ok(())
    /// # }
    /// ```
    pub struct StatusBuilder {
        status: Option<String>,
        in_reply_to_id: Option<String>,
        media_ids: Option<Vec<String>>,
        sensitive: Option<bool>,
        spoiler_text: Option<String>,
        content_type: Option<String>,
        visibility: Option<Visibility>,
        language: Option<Language>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StatusBuilder {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                StatusBuilder {
                status: ref __self_0_0,
                in_reply_to_id: ref __self_0_1,
                media_ids: ref __self_0_2,
                sensitive: ref __self_0_3,
                spoiler_text: ref __self_0_4,
                content_type: ref __self_0_5,
                visibility: ref __self_0_6,
                language: ref __self_0_7 } => {
                    let mut debug_trait_builder =
                        f.debug_struct("StatusBuilder");
                    let _ =
                        debug_trait_builder.field("status", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("in_reply_to_id",
                                                  &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("media_ids",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("sensitive",
                                                  &&(*__self_0_3));
                    let _ =
                        debug_trait_builder.field("spoiler_text",
                                                  &&(*__self_0_4));
                    let _ =
                        debug_trait_builder.field("content_type",
                                                  &&(*__self_0_5));
                    let _ =
                        debug_trait_builder.field("visibility",
                                                  &&(*__self_0_6));
                    let _ =
                        debug_trait_builder.field("language",
                                                  &&(*__self_0_7));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for StatusBuilder {
        #[inline]
        fn default() -> StatusBuilder {
            StatusBuilder{status: ::core::default::Default::default(),
                          in_reply_to_id: ::core::default::Default::default(),
                          media_ids: ::core::default::Default::default(),
                          sensitive: ::core::default::Default::default(),
                          spoiler_text: ::core::default::Default::default(),
                          content_type: ::core::default::Default::default(),
                          visibility: ::core::default::Default::default(),
                          language: ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StatusBuilder {
        #[inline]
        fn clone(&self) -> StatusBuilder {
            match *self {
                StatusBuilder {
                status: ref __self_0_0,
                in_reply_to_id: ref __self_0_1,
                media_ids: ref __self_0_2,
                sensitive: ref __self_0_3,
                spoiler_text: ref __self_0_4,
                content_type: ref __self_0_5,
                visibility: ref __self_0_6,
                language: ref __self_0_7 } =>
                StatusBuilder{status:
                                  ::core::clone::Clone::clone(&(*__self_0_0)),
                              in_reply_to_id:
                                  ::core::clone::Clone::clone(&(*__self_0_1)),
                              media_ids:
                                  ::core::clone::Clone::clone(&(*__self_0_2)),
                              sensitive:
                                  ::core::clone::Clone::clone(&(*__self_0_3)),
                              spoiler_text:
                                  ::core::clone::Clone::clone(&(*__self_0_4)),
                              content_type:
                                  ::core::clone::Clone::clone(&(*__self_0_5)),
                              visibility:
                                  ::core::clone::Clone::clone(&(*__self_0_6)),
                              language:
                                  ::core::clone::Clone::clone(&(*__self_0_7)),},
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for StatusBuilder { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StatusBuilder {
        #[inline]
        fn eq(&self, other: &StatusBuilder) -> bool {
            match *other {
                StatusBuilder {
                status: ref __self_1_0,
                in_reply_to_id: ref __self_1_1,
                media_ids: ref __self_1_2,
                sensitive: ref __self_1_3,
                spoiler_text: ref __self_1_4,
                content_type: ref __self_1_5,
                visibility: ref __self_1_6,
                language: ref __self_1_7 } =>
                match *self {
                    StatusBuilder {
                    status: ref __self_0_0,
                    in_reply_to_id: ref __self_0_1,
                    media_ids: ref __self_0_2,
                    sensitive: ref __self_0_3,
                    spoiler_text: ref __self_0_4,
                    content_type: ref __self_0_5,
                    visibility: ref __self_0_6,
                    language: ref __self_0_7 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3) &&
                        (*__self_0_4) == (*__self_1_4) &&
                        (*__self_0_5) == (*__self_1_5) &&
                        (*__self_0_6) == (*__self_1_6) &&
                        (*__self_0_7) == (*__self_1_7),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StatusBuilder) -> bool {
            match *other {
                StatusBuilder {
                status: ref __self_1_0,
                in_reply_to_id: ref __self_1_1,
                media_ids: ref __self_1_2,
                sensitive: ref __self_1_3,
                spoiler_text: ref __self_1_4,
                content_type: ref __self_1_5,
                visibility: ref __self_1_6,
                language: ref __self_1_7 } =>
                match *self {
                    StatusBuilder {
                    status: ref __self_0_0,
                    in_reply_to_id: ref __self_0_1,
                    media_ids: ref __self_0_2,
                    sensitive: ref __self_0_3,
                    spoiler_text: ref __self_0_4,
                    content_type: ref __self_0_5,
                    visibility: ref __self_0_6,
                    language: ref __self_0_7 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3) ||
                        (*__self_0_4) != (*__self_1_4) ||
                        (*__self_0_5) != (*__self_1_5) ||
                        (*__self_0_6) != (*__self_1_6) ||
                        (*__self_0_7) != (*__self_1_7),
                },
            }
        }
    }
    impl StatusBuilder {
        /// Create a StatusBuilder object
        ///
        /// # Example
        ///
        /// ```rust,no_run
        /// # use elefren::prelude::*;
        /// # use elefren::status_builder::Visibility;
        /// # fn main() -> Result<(), elefren::Error> {
        /// # let data = Data {
        /// #     base: "".into(),
        /// #     client_id: "".into(),
        /// #     client_secret: "".into(),
        /// #     redirect: "".into(),
        /// #     token: "".into(),
        /// # };
        /// # let client = Mastodon::from(data);
        /// let status = StatusBuilder::new()
        ///     .status("a status")
        ///     .visibility(Visibility::Public)
        ///     .build()?;
        /// client.new_status(status)?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn new() -> StatusBuilder { StatusBuilder::default() }
        /// Set the text for the post
        ///
        /// # Example
        ///
        /// ```rust
        /// # use elefren::prelude::*;
        /// # fn main() -> Result<(), elefren::Error> {
        /// let status = StatusBuilder::new().status("awoooooo").build()?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn status<I: Into<String>>(&mut self, status: I) -> &mut Self {
            self.status = Some(status.into());
            self
        }
        /// Set the in_reply_to_id for the post
        ///
        /// # Example
        ///
        /// ```rust
        /// # use elefren::prelude::*;
        /// # fn main() -> Result<(), elefren::Error> {
        /// let status = StatusBuilder::new()
        ///     .status("awooooo")
        ///     .in_reply_to("12345")
        ///     .build()?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn in_reply_to<I: Into<String>>(&mut self, id: I) -> &mut Self {
            self.in_reply_to_id = Some(id.into());
            self
        }
        /// Set the media_ids for the post
        ///
        /// # Example
        ///
        /// ```rust
        /// # use elefren::prelude::*;
        /// # fn main() -> Result<(), elefren::Error> {
        /// let status = StatusBuilder::new().media_ids(&["foo", "bar"]).build()?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn media_ids<S: std::fmt::Display,
                         I: IntoIterator<Item = S>>(&mut self, ids: I)
         -> &mut Self {
            self.media_ids =
                Some(ids.into_iter().map(|s|
                                             s.to_string()).collect::<Vec<_>>());
            self
        }
        /// Set the sensitive attribute for the post
        ///
        /// # Example
        ///
        /// ```rust
        /// # use elefren::prelude::*;
        /// # fn main() -> Result<(), elefren::Error> {
        /// let status = StatusBuilder::new()
        ///     .media_ids(&["foo", "bar"])
        ///     .sensitive(true)
        ///     .build()?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn sensitive(&mut self, sensitive: bool) -> &mut Self {
            self.sensitive = Some(sensitive);
            self
        }
        /// Set the spoiler text/CW for the post
        ///
        /// # Example
        ///
        /// ```rust
        /// # use elefren::prelude::*;
        /// # fn main() -> Result<(), elefren::Error> {
        /// let status = StatusBuilder::new()
        ///     .status("awoooo!!")
        ///     .spoiler_text("awoo inside")
        ///     .build()?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn spoiler_text<I: Into<String>>(&mut self, spoiler_text: I)
         -> &mut Self {
            self.spoiler_text = Some(spoiler_text.into());
            self
        }
        /// Set the content type of the post
        ///
        /// This is a Pleroma and Glitch-soc extension of the API.
        ///
        /// # Possible values
        /// - `text/plain`
        /// - `text/html`
        /// - `text/markdown`
        /// - `text/bbcode` (Pleroma only)
        ///
        /// The set of supported content types may vary by server.
        ///
        /// # Example
        ///
        /// ```rust
        /// # use elefren::prelude::*;
        /// # fn main() -> Result<(), elefren::Error> {
        /// let status = StatusBuilder::new()
        ///     .status("<b>thicc</b>")
        ///     .content_type("text/html")
        ///     .build()?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn content_type<I: Into<String>>(&mut self, content_type: I)
         -> &mut Self {
            self.content_type = Some(content_type.into());
            self
        }
        /// Set the visibility for the post
        ///
        /// # Example
        ///
        /// ```rust
        /// # use elefren::prelude::*;
        /// # use elefren::status_builder::Visibility;
        /// # fn main() -> Result<(), elefren::Error> {
        /// let status = StatusBuilder::new()
        ///     .status("awooooooo")
        ///     .visibility(Visibility::Public)
        ///     .build()?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn visibility(&mut self, visibility: Visibility) -> &mut Self {
            self.visibility = Some(visibility);
            self
        }
        /// Set the language for the post
        ///
        /// # Example
        ///
        /// ```rust
        /// # use elefren::prelude::*;
        /// # use elefren::Language;
        /// # fn main() -> Result<(), elefren::Error> {
        /// let status = StatusBuilder::new()
        ///     .status("awoo!!!!")
        ///     .language(Language::Eng)
        ///     .build()?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn language(&mut self, language: Language) -> &mut Self {
            self.language = Some(language);
            self
        }
        /// Constructs a NewStatus
        ///
        /// # Example
        ///
        /// ```rust
        /// # use elefren::prelude::*;
        /// # fn main() -> Result<(), elefren::Error> {
        /// let status = StatusBuilder::new().status("awoo!").build()?;
        /// #   Ok(())
        /// # }
        /// ```
        pub fn build(&self) -> Result<NewStatus, crate::Error> {
            if self.status.is_none() && self.media_ids.is_none() {
                return Err(crate::Error::Other("status text or media ids are required in order to post a status".to_string()));
            }
            Ok(NewStatus{status: self.status.clone(),
                         in_reply_to_id: self.in_reply_to_id.clone(),
                         media_ids: self.media_ids.clone(),
                         sensitive: self.sensitive.clone(),
                         spoiler_text: self.spoiler_text.clone(),
                         visibility: self.visibility.clone(),
                         language: self.language.clone(),
                         content_type: self.content_type.clone(),})
        }
    }
    /// Represents a post that can be sent to the POST /api/v1/status endpoint
    pub struct NewStatus {
        #[serde(skip_serializing_if = "Option::is_none")]
        status: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        in_reply_to_id: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        media_ids: Option<Vec<String>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        sensitive: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        spoiler_text: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        visibility: Option<Visibility>,
        #[serde(skip_serializing_if = "Option::is_none")]
        language: Option<Language>,
        #[serde(skip_serializing_if = "Option::is_none")]
        content_type: Option<String>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for NewStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                NewStatus {
                status: ref __self_0_0,
                in_reply_to_id: ref __self_0_1,
                media_ids: ref __self_0_2,
                sensitive: ref __self_0_3,
                spoiler_text: ref __self_0_4,
                visibility: ref __self_0_5,
                language: ref __self_0_6,
                content_type: ref __self_0_7 } => {
                    let mut debug_trait_builder = f.debug_struct("NewStatus");
                    let _ =
                        debug_trait_builder.field("status", &&(*__self_0_0));
                    let _ =
                        debug_trait_builder.field("in_reply_to_id",
                                                  &&(*__self_0_1));
                    let _ =
                        debug_trait_builder.field("media_ids",
                                                  &&(*__self_0_2));
                    let _ =
                        debug_trait_builder.field("sensitive",
                                                  &&(*__self_0_3));
                    let _ =
                        debug_trait_builder.field("spoiler_text",
                                                  &&(*__self_0_4));
                    let _ =
                        debug_trait_builder.field("visibility",
                                                  &&(*__self_0_5));
                    let _ =
                        debug_trait_builder.field("language",
                                                  &&(*__self_0_6));
                    let _ =
                        debug_trait_builder.field("content_type",
                                                  &&(*__self_0_7));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for NewStatus {
        #[inline]
        fn default() -> NewStatus {
            NewStatus{status: ::core::default::Default::default(),
                      in_reply_to_id: ::core::default::Default::default(),
                      media_ids: ::core::default::Default::default(),
                      sensitive: ::core::default::Default::default(),
                      spoiler_text: ::core::default::Default::default(),
                      visibility: ::core::default::Default::default(),
                      language: ::core::default::Default::default(),
                      content_type: ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NewStatus {
        #[inline]
        fn clone(&self) -> NewStatus {
            match *self {
                NewStatus {
                status: ref __self_0_0,
                in_reply_to_id: ref __self_0_1,
                media_ids: ref __self_0_2,
                sensitive: ref __self_0_3,
                spoiler_text: ref __self_0_4,
                visibility: ref __self_0_5,
                language: ref __self_0_6,
                content_type: ref __self_0_7 } =>
                NewStatus{status: ::core::clone::Clone::clone(&(*__self_0_0)),
                          in_reply_to_id:
                              ::core::clone::Clone::clone(&(*__self_0_1)),
                          media_ids:
                              ::core::clone::Clone::clone(&(*__self_0_2)),
                          sensitive:
                              ::core::clone::Clone::clone(&(*__self_0_3)),
                          spoiler_text:
                              ::core::clone::Clone::clone(&(*__self_0_4)),
                          visibility:
                              ::core::clone::Clone::clone(&(*__self_0_5)),
                          language:
                              ::core::clone::Clone::clone(&(*__self_0_6)),
                          content_type:
                              ::core::clone::Clone::clone(&(*__self_0_7)),},
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_NewStatus: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl _serde::Serialize for NewStatus {
                fn serialize<__S>(&self, __serializer: __S)
                 -> _serde::export::Result<__S::Ok, __S::Error> where
                 __S: _serde::Serializer {
                    let mut __serde_state =
                        match _serde::Serializer::serialize_struct(__serializer,
                                                                   "NewStatus",
                                                                   false as
                                                                       usize +
                                                                       if Option::is_none(&self.status)
                                                                          {
                                                                           0
                                                                       } else {
                                                                           1
                                                                       } +
                                                                       if Option::is_none(&self.in_reply_to_id)
                                                                          {
                                                                           0
                                                                       } else {
                                                                           1
                                                                       } +
                                                                       if Option::is_none(&self.media_ids)
                                                                          {
                                                                           0
                                                                       } else {
                                                                           1
                                                                       } +
                                                                       if Option::is_none(&self.sensitive)
                                                                          {
                                                                           0
                                                                       } else {
                                                                           1
                                                                       } +
                                                                       if Option::is_none(&self.spoiler_text)
                                                                          {
                                                                           0
                                                                       } else {
                                                                           1
                                                                       } +
                                                                       if Option::is_none(&self.visibility)
                                                                          {
                                                                           0
                                                                       } else {
                                                                           1
                                                                       } +
                                                                       if Option::is_none(&self.language)
                                                                          {
                                                                           0
                                                                       } else {
                                                                           1
                                                                       } +
                                                                       if Option::is_none(&self.content_type)
                                                                          {
                                                                           0
                                                                       } else {
                                                                           1
                                                                       }) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    if !Option::is_none(&self.status) {
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "status",
                                                                            &self.status)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                       "status")
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.in_reply_to_id) {
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "in_reply_to_id",
                                                                            &self.in_reply_to_id)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                       "in_reply_to_id")
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.media_ids) {
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "media_ids",
                                                                            &self.media_ids)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                       "media_ids")
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.sensitive) {
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "sensitive",
                                                                            &self.sensitive)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                       "sensitive")
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.spoiler_text) {
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "spoiler_text",
                                                                            &self.spoiler_text)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                       "spoiler_text")
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.visibility) {
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "visibility",
                                                                            &self.visibility)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                       "visibility")
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.language) {
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "language",
                                                                            &self.language)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                       "language")
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    }
                    if !Option::is_none(&self.content_type) {
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "content_type",
                                                                            &self.content_type)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    } else {
                        match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                       "content_type")
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                    }
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    impl ::core::marker::StructuralPartialEq for NewStatus { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NewStatus {
        #[inline]
        fn eq(&self, other: &NewStatus) -> bool {
            match *other {
                NewStatus {
                status: ref __self_1_0,
                in_reply_to_id: ref __self_1_1,
                media_ids: ref __self_1_2,
                sensitive: ref __self_1_3,
                spoiler_text: ref __self_1_4,
                visibility: ref __self_1_5,
                language: ref __self_1_6,
                content_type: ref __self_1_7 } =>
                match *self {
                    NewStatus {
                    status: ref __self_0_0,
                    in_reply_to_id: ref __self_0_1,
                    media_ids: ref __self_0_2,
                    sensitive: ref __self_0_3,
                    spoiler_text: ref __self_0_4,
                    visibility: ref __self_0_5,
                    language: ref __self_0_6,
                    content_type: ref __self_0_7 } =>
                    (*__self_0_0) == (*__self_1_0) &&
                        (*__self_0_1) == (*__self_1_1) &&
                        (*__self_0_2) == (*__self_1_2) &&
                        (*__self_0_3) == (*__self_1_3) &&
                        (*__self_0_4) == (*__self_1_4) &&
                        (*__self_0_5) == (*__self_1_5) &&
                        (*__self_0_6) == (*__self_1_6) &&
                        (*__self_0_7) == (*__self_1_7),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NewStatus) -> bool {
            match *other {
                NewStatus {
                status: ref __self_1_0,
                in_reply_to_id: ref __self_1_1,
                media_ids: ref __self_1_2,
                sensitive: ref __self_1_3,
                spoiler_text: ref __self_1_4,
                visibility: ref __self_1_5,
                language: ref __self_1_6,
                content_type: ref __self_1_7 } =>
                match *self {
                    NewStatus {
                    status: ref __self_0_0,
                    in_reply_to_id: ref __self_0_1,
                    media_ids: ref __self_0_2,
                    sensitive: ref __self_0_3,
                    spoiler_text: ref __self_0_4,
                    visibility: ref __self_0_5,
                    language: ref __self_0_6,
                    content_type: ref __self_0_7 } =>
                    (*__self_0_0) != (*__self_1_0) ||
                        (*__self_0_1) != (*__self_1_1) ||
                        (*__self_0_2) != (*__self_1_2) ||
                        (*__self_0_3) != (*__self_1_3) ||
                        (*__self_0_4) != (*__self_1_4) ||
                        (*__self_0_5) != (*__self_1_5) ||
                        (*__self_0_6) != (*__self_1_6) ||
                        (*__self_0_7) != (*__self_1_7),
                },
            }
        }
    }
    /// The visibility of a status.
    #[serde(rename_all = "lowercase")]
    pub enum Visibility {

        /// A Direct message to a user
        Direct,

        /// Only available to followers
        Private,

        /// Not shown in public timelines
        Unlisted,

        /// Posted to public timelines
        Public,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Visibility {
        #[inline]
        fn clone(&self) -> Visibility { { *self } }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Visibility { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Visibility {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Visibility::Direct,) => {
                    let mut debug_trait_builder = f.debug_tuple("Direct");
                    debug_trait_builder.finish()
                }
                (&Visibility::Private,) => {
                    let mut debug_trait_builder = f.debug_tuple("Private");
                    debug_trait_builder.finish()
                }
                (&Visibility::Unlisted,) => {
                    let mut debug_trait_builder = f.debug_tuple("Unlisted");
                    debug_trait_builder.finish()
                }
                (&Visibility::Public,) => {
                    let mut debug_trait_builder = f.debug_tuple("Public");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Visibility: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl <'de> _serde::Deserialize<'de> for Visibility {
                fn deserialize<__D>(__deserializer: __D)
                 -> _serde::export::Result<Self, __D::Error> where
                 __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    enum __Field { __field0, __field1, __field2, __field3, }
                    struct __FieldVisitor;
                    impl <'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "variant identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                3u64 => _serde::export::Ok(__Field::__field3),
                                _ =>
                                _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                     &"variant index 0 <= i < 4")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                "direct" =>
                                _serde::export::Ok(__Field::__field0),
                                "private" =>
                                _serde::export::Ok(__Field::__field1),
                                "unlisted" =>
                                _serde::export::Ok(__Field::__field2),
                                "public" =>
                                _serde::export::Ok(__Field::__field3),
                                _ => {
                                    _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                           VARIANTS))
                                }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                         -> _serde::export::Result<Self::Value, __E> where
                         __E: _serde::de::Error {
                            match __value {
                                b"direct" =>
                                _serde::export::Ok(__Field::__field0),
                                b"private" =>
                                _serde::export::Ok(__Field::__field1),
                                b"unlisted" =>
                                _serde::export::Ok(__Field::__field2),
                                b"public" =>
                                _serde::export::Ok(__Field::__field3),
                                _ => {
                                    let __value =
                                        &_serde::export::from_utf8_lossy(__value);
                                    _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                           VARIANTS))
                                }
                            }
                        }
                    }
                    impl <'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                         __FieldVisitor)
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Visibility>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl <'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Visibility;
                        fn expecting(&self,
                                     __formatter:
                                         &mut _serde::export::Formatter)
                         -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter,
                                                                 "enum Visibility")
                        }
                        fn visit_enum<__A>(self, __data: __A)
                         -> _serde::export::Result<Self::Value, __A::Error>
                         where __A: _serde::de::EnumAccess<'de> {
                            match match _serde::de::EnumAccess::variant(__data)
                                      {
                                      _serde::export::Ok(__val) => __val,
                                      _serde::export::Err(__err) => {
                                          return _serde::export::Err(__err);
                                      }
                                  } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                    _serde::export::Ok(Visibility::Direct)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                    _serde::export::Ok(Visibility::Private)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                    _serde::export::Ok(Visibility::Unlisted)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                    _serde::export::Ok(Visibility::Public)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["direct", "private", "unlisted", "public"];
                    _serde::Deserializer::deserialize_enum(__deserializer,
                                                           "Visibility",
                                                           VARIANTS,
                                                           __Visitor{marker:
                                                                         _serde::export::PhantomData::<Visibility>,
                                                                     lifetime:
                                                                         _serde::export::PhantomData,})
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Visibility: () =
        {
            #[allow(rust_2018_idioms, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[allow(unused_macros)]
            macro_rules! try {
                ($ __expr : expr) =>
                {
                    match $ __expr
                    {
                        _serde :: export :: Ok(__val) => __val, _serde ::
                        export :: Err(__err) =>
                        { return _serde :: export :: Err(__err) ; }
                    }
                }
            }
            #[automatically_derived]
            impl _serde::Serialize for Visibility {
                fn serialize<__S>(&self, __serializer: __S)
                 -> _serde::export::Result<__S::Ok, __S::Error> where
                 __S: _serde::Serializer {
                    match *self {
                        Visibility::Direct =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Visibility",
                                                                   0u32,
                                                                   "direct"),
                        Visibility::Private =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Visibility",
                                                                   1u32,
                                                                   "private"),
                        Visibility::Unlisted =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Visibility",
                                                                   2u32,
                                                                   "unlisted"),
                        Visibility::Public =>
                        _serde::Serializer::serialize_unit_variant(__serializer,
                                                                   "Visibility",
                                                                   3u32,
                                                                   "public"),
                    }
                }
            }
        };
    impl ::core::marker::StructuralPartialEq for Visibility { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Visibility {
        #[inline]
        fn eq(&self, other: &Visibility) -> bool {
            {
                let __self_vi =
                    unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi =
                    unsafe {
                        ::core::intrinsics::discriminant_value(&*other)
                    };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    impl Default for Visibility {
        fn default() -> Self { Visibility::Public }
    }
}
#[macro_use]
mod macros {
    macro_rules! methods {
        ($ ($ method : ident,) +) =>
        {
            $
            (fn $ method < T : for < 'de > serde :: Deserialize < 'de >>
             (& self, url : String) -> Result < T >
             {
                 let response = self . send(self . client . $ method(& url)) ?
                 ; deserialise(response)
             }) +
        } ;
    }
    macro_rules! paged_routes {
        (($ method : ident) $ name : ident : $ url : expr => $ ret : ty, $
         ($ rest : tt) *) =>
        {
            doc_comment !
            {
                concat !
                ("Equivalent to `", stringify ! ($ method), " /api/v1/", $
                 url, "`\n# Errors\nIf `access_token` is not set.", "\n",
                 "```no_run", "# extern crate elefren;\n",
                 "# use elefren::prelude::*;\n",
                 "# fn main() -> Result<(), Box<::std::error::Error>> {\n",
                 "# let data = Data {\n",
                 "#     base: \"https://example.com\".into(),\n",
                 "#     client_id: \"taosuah\".into(),\n",
                 "#     client_secret: \"htnjdiuae\".into(),\n",
                 "#     redirect: \"https://example.com\".into(),\n",
                 "#     token: \"tsaohueaheis\".into(),\n", "# };\n",
                 "let client = Mastodon::from(data);\n", "client.", stringify
                 ! ($ name), "();\n", "#   Ok(())\n", "# }\n", "```"), async
                fn $ name(& self) -> Result < Page < '_, $ ret >>
                {
                    let url = self . route(concat ! ("/api/v1/", $ url)) ; let
                    response = self . send(self . client . $ method(& url)) ?
                    ; Page :: new(self, response)
                }
            } paged_routes ! { $ ($ rest) * }
        } ;
        ((get($ ($ (# [$ m : meta]) * $ param : ident : $ typ : ty,) *)) $
         name : ident : $ url : expr => $ ret : ty, $ ($ rest : tt) *) =>
        {
            doc_comment !
            {
                concat !
                ("Equivalent to `get /api/v1/", $ url,
                 "`\n# Errors\nIf `access_token` is not set."), async fn $
                name < 'a > (& self, $ ($ param : $ typ,) *) -> Result < Page
                < '_, $ ret >>
                {
                    use serde_urlencoded ; # [derive(Serialize)] struct Data <
                    'a >
                    {
                        $ ($ (# [$ m]) * $ param : $ typ,) * # [serde(skip)]
                        _marker : :: std :: marker :: PhantomData < & 'a () >,
                    } let qs_data = Data
                    {
                        $ ($ param : $ param,) * _marker : :: std :: marker ::
                        PhantomData,
                    } ; let qs = serde_urlencoded :: to_string(& qs_data) ? ;
                    let url = format !
                    (concat ! ("/api/v1/", $ url, "?{}"), & qs) ; let response
                    = self . send(self . client . get(& url)) ? ; Page ::
                    new(self, response)
                }
            } paged_routes ! { $ ($ rest) * }
        } ; () => { }
    }
    macro_rules! route_v2 {
        ((get($ ($ param : ident : $ typ : ty,) *)) $ name : ident : $ url :
         expr => $ ret : ty, $ ($ rest : tt) *) =>
        {
            doc_comment !
            {
                concat !
                ("Equivalent to `get /api/v2/", $ url,
                 "`\n# Errors\nIf `access_token` is not set."), fn $ name < 'a
                > (& self, $ ($ param : $ typ,) *) -> Result < $ ret >
                {
                    use serde_urlencoded ; # [derive(Serialize)] struct Data <
                    'a >
                    {
                        $ ($ param : $ typ,) * # [serde(skip)] _marker : ::
                        std :: marker :: PhantomData < & 'a () >,
                    } let qs_data = Data
                    {
                        $ ($ param : $ param,) * _marker : :: std :: marker ::
                        PhantomData,
                    } ; let qs = serde_urlencoded :: to_string(& qs_data) ? ;
                    let url = format !
                    (concat ! ("/api/v2/", $ url, "?{}"), & qs) ;
                    Ok(self . get(self . route(& url)) ?)
                }
            } route_v2 ! { $ ($ rest) * }
        } ; () => { }
    }
    macro_rules! route {
        ((post multipart($ ($ param : ident : $ typ : ty,) *)) $ name : ident
         : $ url : expr => $ ret : ty, $ ($ rest : tt) *) =>
        {
            doc_comment !
            {
                concat !
                ("Equivalent to `post /api/v1/", $ url,
                 "`\n# Errors\nIf `access_token` is not set."), fn $
                name(& self, $ ($ param : $ typ,) *) -> Result < $ ret >
                {
                    use reqwest :: multipart :: Form ; let form_data = Form ::
                    new() $
                    (. file(stringify ! ($ param), $ param . as_ref()) ?) * ;
                    let response = self .
                    send(self . client .
                         post(& self . route(concat ! ("/api/v1/", $ url))) .
                         multipart(form_data)) ? ; let status = response .
                    status() . clone() ; if status . is_client_error()
                    { return Err(Error :: Client(status)) ; } else if status .
                    is_server_error()
                    { return Err(Error :: Server(status)) ; }
                    deserialise(response)
                }
            } route ! { $ ($ rest) * }
        } ;
        ((get($ ($ param : ident : $ typ : ty,) *)) $ name : ident : $ url :
         expr => $ ret : ty, $ ($ rest : tt) *) =>
        {
            doc_comment !
            {
                concat !
                ("Equivalent to `get /api/v1/", $ url,
                 "`\n# Errors\nIf `access_token` is not set."), fn $ name < 'a
                > (& self, $ ($ param : $ typ,) *) -> Result < $ ret >
                {
                    use serde_urlencoded ; # [derive(Serialize)] struct Data <
                    'a >
                    {
                        $ ($ param : $ typ,) * # [serde(skip)] _marker : ::
                        std :: marker :: PhantomData < & 'a () >,
                    } let qs_data = Data
                    {
                        $ ($ param : $ param,) * _marker : :: std :: marker ::
                        PhantomData,
                    } ; let qs = serde_urlencoded :: to_string(& qs_data) ? ;
                    let url = format !
                    (concat ! ("/api/v1/", $ url, "?{}"), & qs) ;
                    Ok(self . get(self . route(& url)) ?)
                }
            } route ! { $ ($ rest) * }
        } ;
        (($ method : ident($ ($ param : ident : $ typ : ty,) *)) $ name :
         ident : $ url : expr => $ ret : ty, $ ($ rest : tt) *) =>
        {
            doc_comment !
            {
                concat !
                ("Equivalent to `", stringify ! ($ method), " /api/v1/", $
                 url, "`\n# Errors\nIf `access_token` is not set.",), fn $
                name(& self, $ ($ param : $ typ,) *) -> Result < $ ret >
                {
                    let form_data = json !
                    ({ $ (stringify ! ($ param) : $ param,) * }) ; let
                    response = self .
                    send(self . client . $
                         method(& self . route(concat ! ("/api/v1/", $ url)))
                         . json(& form_data)) ? ; let status = response .
                    status() . clone() ; if status . is_client_error()
                    { return Err(Error :: Client(status)) ; } else if status .
                    is_server_error()
                    { return Err(Error :: Server(status)) ; }
                    deserialise(response)
                }
            } route ! { $ ($ rest) * }
        } ;
        (($ method : ident) $ name : ident : $ url : expr => $ ret : ty, $
         ($ rest : tt) *) =>
        {
            doc_comment !
            {
                concat !
                ("Equivalent to `", stringify ! ($ method), " /api/v1/", $
                 url, "`\n# Errors\nIf `access_token` is not set.", "\n",
                 "```no_run", "# extern crate elefren;\n",
                 "# use elefren::prelude::*;\n",
                 "# fn main() -> Result<(), Box<::std::error::Error>> {\n",
                 "# let data = Data {\n",
                 "#     base: \"https://example.com\".into(),\n",
                 "#     client_id: \"taosuah\".into(),\n",
                 "#     client_secret: \"htnjdiuae\".into(),\n",
                 "#     redirect: \"https://example.com\".into(),\n",
                 "#     token: \"tsaohueaheis\".into(),\n", "# };\n",
                 "let client = Mastodon::from(data);\n", "client.", stringify
                 ! ($ name), "();\n", "#   Ok(())\n", "# }\n", "```"), fn $
                name(& self) -> Result < $ ret >
                {
                    self . $
                    method(self . route(concat ! ("/api/v1/", $ url)))
                }
            } route ! { $ ($ rest) * }
        } ; () => { }
    }
    macro_rules! route_id {
        ($ (($ method : ident) $ name : ident : $ url : expr => $ ret : ty,)
         *) =>
        {
            $
            (doc_comment !
             {
                 concat !
                 ("Equivalent to `", stringify ! ($ method), " /api/v1/", $
                  url, "`\n# Errors\nIf `access_token` is not set.", "\n",
                  "```no_run", "# extern crate elefren;\n",
                  "# use elefren::prelude::*;\n",
                  "# fn main() -> Result<(), Box<::std::error::Error>> {\n",
                  "# let data = Data {\n",
                  "#     base: \"https://example.com\".into(),\n",
                  "#     client_id: \"taosuah\".into(),\n",
                  "#     client_secret: \"htnjdiuae\".into(),\n",
                  "#     redirect: \"https://example.com\".into(),\n",
                  "#     token: \"tsaohueaheis\".into(),\n", "# };\n",
                  "let client = Mastodon::from(data);\n", "client.", stringify
                  ! ($ name), "(\"42\");\n", "#   Ok(())\n", "# }\n", "```"),
                 fn $ name(& self, id : & str) -> Result < $ ret >
                 {
                     self . $
                     method(self .
                            route(& format !
                                  (concat ! ("/api/v1/", $ url), id)))
                 }
             }) *
        }
    }
    macro_rules! paged_routes_with_id {
        (($ method : ident) $ name : ident : $ url : expr => $ ret : ty, $
         ($ rest : tt) *) =>
        {
            doc_comment !
            {
                concat !
                ("Equivalent to `", stringify ! ($ method), " /api/v1/", $
                 url, "`\n# Errors\nIf `access_token` is not set.", "\n",
                 "```no_run", "# extern crate elefren;\n",
                 "# use elefren::prelude::*;\n",
                 "# fn main() -> Result<(), Box<::std::error::Error>> {\n",
                 "# let data = Data {\n",
                 "#     base: \"https://example.com\".into(),\n",
                 "#     client_id: \"taosuah\".into(),\n",
                 "#     client_secret: \"htnjdiuae\".into(),\n",
                 "#     redirect: \"https://example.com\".into(),\n",
                 "#     token: \"tsaohueaheis\".into(),\n", "# };\n",
                 "let client = Mastodon::from(data);\n", "client.", stringify
                 ! ($ name), "(\"some-id\");\n", "#   Ok(())\n", "# }\n",
                 "```"), fn $ name(& self, id : & str) -> Result < Page < $
                ret >>
                {
                    let url = self .
                    route(& format ! (concat ! ("/api/v1/", $ url), id)) ; let
                    response = self . send(self . client . $ method(& url)) ?
                    ; Page :: new(self, response)
                }
            } paged_routes_with_id ! { $ ($ rest) * }
        } ; () => { }
    }
}
/// Automatically import the things you need
pub mod prelude {
    pub use crate::scopes::Scopes;
    pub use crate::Data;
    pub use crate::Mastodon;
    pub use crate::MastodonClient;
    pub use crate::NewStatus;
    pub use crate::Registration;
    pub use crate::StatusBuilder;
    pub use crate::StatusesRequest;
}
/// Your mastodon application client, handles all requests to and from Mastodon.
pub struct Mastodon {
    client: Client,
    /// Raw data about your mastodon instance.
    pub data: Data,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Mastodon {
    #[inline]
    fn clone(&self) -> Mastodon {
        match *self {
            Mastodon { client: ref __self_0_0, data: ref __self_0_1 } =>
            Mastodon{client: ::core::clone::Clone::clone(&(*__self_0_0)),
                     data: ::core::clone::Clone::clone(&(*__self_0_1)),},
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Mastodon {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            Mastodon { client: ref __self_0_0, data: ref __self_0_1 } => {
                let mut debug_trait_builder = f.debug_struct("Mastodon");
                let _ = debug_trait_builder.field("client", &&(*__self_0_0));
                let _ = debug_trait_builder.field("data", &&(*__self_0_1));
                debug_trait_builder.finish()
            }
        }
    }
}
impl Mastodon {
    fn get<T: for<'de> serde::Deserialize<'de>>(&self, url: String)
     -> Result<T> {
        let response = self.send(self.client.get(&url))?;
        deserialise(response)
    }
    fn post<T: for<'de> serde::Deserialize<'de>>(&self, url: String)
     -> Result<T> {
        let response = self.send(self.client.post(&url))?;
        deserialise(response)
    }
    fn delete<T: for<'de> serde::Deserialize<'de>>(&self, url: String)
     -> Result<T> {
        let response = self.send(self.client.delete(&url))?;
        deserialise(response)
    }
    fn route(&self, url: &str) -> String {
        {
            let res =
                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["", ""],
                                                                    &match (&self.base,
                                                                            &url)
                                                                         {
                                                                         (arg0,
                                                                          arg1)
                                                                         =>
                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                       ::core::fmt::Display::fmt),
                                                                          ::core::fmt::ArgumentV1::new(arg1,
                                                                                                       ::core::fmt::Display::fmt)],
                                                                     }));
            res
        }
    }
    pub(crate) fn send(&self, req: RequestBuilder) -> Result<Response> {
        let req = req.bearer_auth(&self.token).build()?;
        Ok(self.client.execute(req)?)
    }
}
impl From<Data> for Mastodon {
    /// Creates a mastodon instance from the data struct.
    fn from(data: Data) -> Mastodon {
        let mut builder = MastodonBuilder::new();
        builder.data(data);
        builder.build().expect("We know `data` is present, so this should be fine")
    }
}
impl MastodonClient for Mastodon {
    #[doc =
      "Equivalent to `get /api/v1/favourites`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.favourites();\n#   Ok(())\n# }\n```"]
    async fn favourites(&self) -> Result<Page<'_, Status>> {
        let url = self.route("/api/v1/favourites");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/blocks`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.blocks();\n#   Ok(())\n# }\n```"]
    async fn blocks(&self) -> Result<Page<'_, Account>> {
        let url = self.route("/api/v1/blocks");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/domain_blocks`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.domain_blocks();\n#   Ok(())\n# }\n```"]
    async fn domain_blocks(&self) -> Result<Page<'_, String>> {
        let url = self.route("/api/v1/domain_blocks");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/follow_requests`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.follow_requests();\n#   Ok(())\n# }\n```"]
    async fn follow_requests(&self) -> Result<Page<'_, Account>> {
        let url = self.route("/api/v1/follow_requests");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/timelines/home`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_home_timeline();\n#   Ok(())\n# }\n```"]
    async fn get_home_timeline(&self) -> Result<Page<'_, Status>> {
        let url = self.route("/api/v1/timelines/home");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/custom_emojis`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_emojis();\n#   Ok(())\n# }\n```"]
    async fn get_emojis(&self) -> Result<Page<'_, Emoji>> {
        let url = self.route("/api/v1/custom_emojis");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/mutes`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.mutes();\n#   Ok(())\n# }\n```"]
    async fn mutes(&self) -> Result<Page<'_, Account>> {
        let url = self.route("/api/v1/mutes");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/notifications`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.notifications();\n#   Ok(())\n# }\n```"]
    async fn notifications(&self) -> Result<Page<'_, Notification>> {
        let url = self.route("/api/v1/notifications");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/reports`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.reports();\n#   Ok(())\n# }\n```"]
    async fn reports(&self) -> Result<Page<'_, Report>> {
        let url = self.route("/api/v1/reports");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/accounts/search`\n# Errors\nIf `access_token` is not set."]
    async fn search_accounts<'a>(&self, q: &'a str, limit: Option<u64>,
                                 following: bool)
     -> Result<Page<'_, Account>> {
        use serde_urlencoded;
        struct Data<'a> {
            q: &'a str,
            #[serde(skip_serializing_if = "Option::is_none")]
            limit: Option<u64>,
            following: bool,
            #[serde(skip)]
            _marker: ::std::marker::PhantomData<&'a ()>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_Data: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'a> _serde::Serialize for Data<'a> {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "Data",
                                                                       false
                                                                           as
                                                                           usize
                                                                           + 1
                                                                           +
                                                                           if Option::is_none(&self.limit)
                                                                              {
                                                                               0
                                                                           } else {
                                                                               1
                                                                           } +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "q",
                                                                            &self.q)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        if !Option::is_none(&self.limit) {
                            match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                                "limit",
                                                                                &self.limit)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(&mut __serde_state,
                                                                           "limit")
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "following",
                                                                            &self.following)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        let qs_data =
            Data{q: q,
                 limit: limit,
                 following: following,
                 _marker: ::std::marker::PhantomData,};
        let qs = serde_urlencoded::to_string(&qs_data)?;
        let url =
            {
                let res =
                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/search?"],
                                                                        &match (&&qs,)
                                                                             {
                                                                             (arg0,)
                                                                             =>
                                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                                           ::core::fmt::Display::fmt)],
                                                                         }));
                res
            };
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/endorsements`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_endorsements();\n#   Ok(())\n# }\n```"]
    async fn get_endorsements(&self) -> Result<Page<'_, Account>> {
        let url = self.route("/api/v1/endorsements");
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/accounts/{}/followers`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.followers(\"some-id\");\n#   Ok(())\n# }\n```"]
    fn followers(&self, id: &str) -> Result<Page<Account>> {
        let url =
            self.route(&{
                            let res =
                                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                      "/followers"],
                                                                                    &match (&id,)
                                                                                         {
                                                                                         (arg0,)
                                                                                         =>
                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                     }));
                            res
                        });
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/accounts/{}/following`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.following(\"some-id\");\n#   Ok(())\n# }\n```"]
    fn following(&self, id: &str) -> Result<Page<Account>> {
        let url =
            self.route(&{
                            let res =
                                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                      "/following"],
                                                                                    &match (&id,)
                                                                                         {
                                                                                         (arg0,)
                                                                                         =>
                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                     }));
                            res
                        });
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/statuses/{}/reblogged_by`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.reblogged_by(\"some-id\");\n#   Ok(())\n# }\n```"]
    fn reblogged_by(&self, id: &str) -> Result<Page<Account>> {
        let url =
            self.route(&{
                            let res =
                                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/",
                                                                                      "/reblogged_by"],
                                                                                    &match (&id,)
                                                                                         {
                                                                                         (arg0,)
                                                                                         =>
                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                     }));
                            res
                        });
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `get /api/v1/statuses/{}/favourited_by`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.favourited_by(\"some-id\");\n#   Ok(())\n# }\n```"]
    fn favourited_by(&self, id: &str) -> Result<Page<Account>> {
        let url =
            self.route(&{
                            let res =
                                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/",
                                                                                      "/favourited_by"],
                                                                                    &match (&id,)
                                                                                         {
                                                                                         (arg0,)
                                                                                         =>
                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                     }));
                            res
                        });
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      "Equivalent to `delete /api/v1/domain_blocks`\n# Errors\nIf `access_token` is not set."]
    fn unblock_domain(&self, domain: String) -> Result<Empty> {
        let form_data =
            ::serde_json::Value::Object({
                                            let mut object =
                                                ::serde_json::Map::new();
                                            let _ =
                                                object.insert(("domain").into(),
                                                              ::serde_json::to_value(&domain).unwrap());
                                            object
                                        });
        let response =
            self.send(self.client.delete(&self.route("/api/v1/domain_blocks")).json(&form_data))?;
        let status = response.status().clone();
        if status.is_client_error() {
            return Err(Error::Client(status));
        } else if status.is_server_error() {
            return Err(Error::Server(status));
        }
        deserialise(response)
    }
    #[doc =
      "Equivalent to `get /api/v1/instance`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.instance();\n#   Ok(())\n# }\n```"]
    fn instance(&self) -> Result<Instance> {
        self.get(self.route("/api/v1/instance"))
    }
    #[doc =
      "Equivalent to `get /api/v1/accounts/verify_credentials`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.verify_credentials();\n#   Ok(())\n# }\n```"]
    fn verify_credentials(&self) -> Result<Account> {
        self.get(self.route("/api/v1/accounts/verify_credentials"))
    }
    #[doc =
      "Equivalent to `post /api/v1/reports`\n# Errors\nIf `access_token` is not set."]
    fn report(&self, account_id: &str, status_ids: Vec<&str>, comment: String)
     -> Result<Report> {
        let form_data =
            ::serde_json::Value::Object({
                                            let mut object =
                                                ::serde_json::Map::new();
                                            let _ =
                                                object.insert(("account_id").into(),
                                                              ::serde_json::to_value(&account_id).unwrap());
                                            let _ =
                                                object.insert(("status_ids").into(),
                                                              ::serde_json::to_value(&status_ids).unwrap());
                                            let _ =
                                                object.insert(("comment").into(),
                                                              ::serde_json::to_value(&comment).unwrap());
                                            object
                                        });
        let response =
            self.send(self.client.post(&self.route("/api/v1/reports")).json(&form_data))?;
        let status = response.status().clone();
        if status.is_client_error() {
            return Err(Error::Client(status));
        } else if status.is_server_error() {
            return Err(Error::Server(status));
        }
        deserialise(response)
    }
    #[doc =
      "Equivalent to `post /api/v1/domain_blocks`\n# Errors\nIf `access_token` is not set."]
    fn block_domain(&self, domain: String) -> Result<Empty> {
        let form_data =
            ::serde_json::Value::Object({
                                            let mut object =
                                                ::serde_json::Map::new();
                                            let _ =
                                                object.insert(("domain").into(),
                                                              ::serde_json::to_value(&domain).unwrap());
                                            object
                                        });
        let response =
            self.send(self.client.post(&self.route("/api/v1/domain_blocks")).json(&form_data))?;
        let status = response.status().clone();
        if status.is_client_error() {
            return Err(Error::Client(status));
        } else if status.is_server_error() {
            return Err(Error::Server(status));
        }
        deserialise(response)
    }
    #[doc =
      "Equivalent to `post /api/v1/accounts/follow_requests/authorize`\n# Errors\nIf `access_token` is not set."]
    fn authorize_follow_request(&self, id: &str) -> Result<Empty> {
        let form_data =
            ::serde_json::Value::Object({
                                            let mut object =
                                                ::serde_json::Map::new();
                                            let _ =
                                                object.insert(("id").into(),
                                                              ::serde_json::to_value(&id).unwrap());
                                            object
                                        });
        let response =
            self.send(self.client.post(&self.route("/api/v1/accounts/follow_requests/authorize")).json(&form_data))?;
        let status = response.status().clone();
        if status.is_client_error() {
            return Err(Error::Client(status));
        } else if status.is_server_error() {
            return Err(Error::Server(status));
        }
        deserialise(response)
    }
    #[doc =
      "Equivalent to `post /api/v1/accounts/follow_requests/reject`\n# Errors\nIf `access_token` is not set."]
    fn reject_follow_request(&self, id: &str) -> Result<Empty> {
        let form_data =
            ::serde_json::Value::Object({
                                            let mut object =
                                                ::serde_json::Map::new();
                                            let _ =
                                                object.insert(("id").into(),
                                                              ::serde_json::to_value(&id).unwrap());
                                            object
                                        });
        let response =
            self.send(self.client.post(&self.route("/api/v1/accounts/follow_requests/reject")).json(&form_data))?;
        let status = response.status().clone();
        if status.is_client_error() {
            return Err(Error::Client(status));
        } else if status.is_server_error() {
            return Err(Error::Server(status));
        }
        deserialise(response)
    }
    #[doc =
      "Equivalent to `get /api/v1/search`\n# Errors\nIf `access_token` is not set."]
    fn search<'a>(&self, q: &'a str, resolve: bool) -> Result<SearchResult> {
        use serde_urlencoded;
        struct Data<'a> {
            q: &'a str,
            resolve: bool,
            #[serde(skip)]
            _marker: ::std::marker::PhantomData<&'a ()>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_Data: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'a> _serde::Serialize for Data<'a> {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "Data",
                                                                       false
                                                                           as
                                                                           usize
                                                                           + 1
                                                                           +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "q",
                                                                            &self.q)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "resolve",
                                                                            &self.resolve)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        let qs_data =
            Data{q: q,
                 resolve: resolve,
                 _marker: ::std::marker::PhantomData,};
        let qs = serde_urlencoded::to_string(&qs_data)?;
        let url =
            {
                let res =
                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/search?"],
                                                                        &match (&&qs,)
                                                                             {
                                                                             (arg0,)
                                                                             =>
                                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                                           ::core::fmt::Display::fmt)],
                                                                         }));
                res
            };
        Ok(self.get(self.route(&url))?)
    }
    #[doc =
      "Equivalent to `get /api/v1/timelines/public`\n# Errors\nIf `access_token` is not set."]
    fn get_public_timeline<'a>(&self, local: bool) -> Result<Vec<Status>> {
        use serde_urlencoded;
        struct Data<'a> {
            local: bool,
            #[serde(skip)]
            _marker: ::std::marker::PhantomData<&'a ()>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_Data: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'a> _serde::Serialize for Data<'a> {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "Data",
                                                                       false
                                                                           as
                                                                           usize
                                                                           +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "local",
                                                                            &self.local)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        let qs_data =
            Data{local: local, _marker: ::std::marker::PhantomData,};
        let qs = serde_urlencoded::to_string(&qs_data)?;
        let url =
            {
                let res =
                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/timelines/public?"],
                                                                        &match (&&qs,)
                                                                             {
                                                                             (arg0,)
                                                                             =>
                                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                                           ::core::fmt::Display::fmt)],
                                                                         }));
                res
            };
        Ok(self.get(self.route(&url))?)
    }
    #[doc =
      "Equivalent to `post /api/v1/follows`\n# Errors\nIf `access_token` is not set."]
    fn follows(&self, uri: Cow<'static, str>) -> Result<Account> {
        let form_data =
            ::serde_json::Value::Object({
                                            let mut object =
                                                ::serde_json::Map::new();
                                            let _ =
                                                object.insert(("uri").into(),
                                                              ::serde_json::to_value(&uri).unwrap());
                                            object
                                        });
        let response =
            self.send(self.client.post(&self.route("/api/v1/follows")).json(&form_data))?;
        let status = response.status().clone();
        if status.is_client_error() {
            return Err(Error::Client(status));
        } else if status.is_server_error() {
            return Err(Error::Server(status));
        }
        deserialise(response)
    }
    #[doc =
      "Equivalent to `post /api/v1/media`\n# Errors\nIf `access_token` is not set."]
    fn media(&self, file: Cow<'static, str>) -> Result<Attachment> {
        use reqwest::multipart::Form;
        let form_data = Form::new().file("file", file.as_ref())?;
        let response =
            self.send(self.client.post(&self.route("/api/v1/media")).multipart(form_data))?;
        let status = response.status().clone();
        if status.is_client_error() {
            return Err(Error::Client(status));
        } else if status.is_server_error() {
            return Err(Error::Server(status));
        }
        deserialise(response)
    }
    #[doc =
      "Equivalent to `post /api/v1/notifications/clear`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.clear_notifications();\n#   Ok(())\n# }\n```"]
    fn clear_notifications(&self) -> Result<Empty> {
        self.post(self.route("/api/v1/notifications/clear"))
    }
    #[doc =
      "Equivalent to `post /api/v1/notifications/dismiss`\n# Errors\nIf `access_token` is not set."]
    fn dismiss_notification(&self, id: &str) -> Result<Empty> {
        let form_data =
            ::serde_json::Value::Object({
                                            let mut object =
                                                ::serde_json::Map::new();
                                            let _ =
                                                object.insert(("id").into(),
                                                              ::serde_json::to_value(&id).unwrap());
                                            object
                                        });
        let response =
            self.send(self.client.post(&self.route("/api/v1/notifications/dismiss")).json(&form_data))?;
        let status = response.status().clone();
        if status.is_client_error() {
            return Err(Error::Client(status));
        } else if status.is_server_error() {
            return Err(Error::Server(status));
        }
        deserialise(response)
    }
    #[doc =
      "Equivalent to `get /api/v1/push/subscription`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_push_subscription();\n#   Ok(())\n# }\n```"]
    fn get_push_subscription(&self) -> Result<Subscription> {
        self.get(self.route("/api/v1/push/subscription"))
    }
    #[doc =
      "Equivalent to `delete /api/v1/push/subscription`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.delete_push_subscription();\n#   Ok(())\n# }\n```"]
    fn delete_push_subscription(&self) -> Result<Empty> {
        self.delete(self.route("/api/v1/push/subscription"))
    }
    #[doc =
      "Equivalent to `get /api/v1/filters`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_filters();\n#   Ok(())\n# }\n```"]
    fn get_filters(&self) -> Result<Vec<Filter>> {
        self.get(self.route("/api/v1/filters"))
    }
    #[doc =
      "Equivalent to `get /api/v1/suggestions`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_follow_suggestions();\n#   Ok(())\n# }\n```"]
    fn get_follow_suggestions(&self) -> Result<Vec<Account>> {
        self.get(self.route("/api/v1/suggestions"))
    }
    #[doc =
      "Equivalent to `get /api/v2/search`\n# Errors\nIf `access_token` is not set."]
    fn search_v2<'a>(&self, q: &'a str, resolve: bool)
     -> Result<SearchResultV2> {
        use serde_urlencoded;
        struct Data<'a> {
            q: &'a str,
            resolve: bool,
            #[serde(skip)]
            _marker: ::std::marker::PhantomData<&'a ()>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes,
                unused_qualifications)]
        const _IMPL_SERIALIZE_FOR_Data: () =
            {
                #[allow(rust_2018_idioms, clippy :: useless_attribute)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try {
                    ($ __expr : expr) =>
                    {
                        match $ __expr
                        {
                            _serde :: export :: Ok(__val) => __val, _serde ::
                            export :: Err(__err) =>
                            { return _serde :: export :: Err(__err) ; }
                        }
                    }
                }
                #[automatically_derived]
                impl <'a> _serde::Serialize for Data<'a> {
                    fn serialize<__S>(&self, __serializer: __S)
                     -> _serde::export::Result<__S::Ok, __S::Error> where
                     __S: _serde::Serializer {
                        let mut __serde_state =
                            match _serde::Serializer::serialize_struct(__serializer,
                                                                       "Data",
                                                                       false
                                                                           as
                                                                           usize
                                                                           + 1
                                                                           +
                                                                           1)
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "q",
                                                                            &self.q)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                                                                            "resolve",
                                                                            &self.resolve)
                            {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
        let qs_data =
            Data{q: q,
                 resolve: resolve,
                 _marker: ::std::marker::PhantomData,};
        let qs = serde_urlencoded::to_string(&qs_data)?;
        let url =
            {
                let res =
                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v2/search?"],
                                                                        &match (&&qs,)
                                                                             {
                                                                             (arg0,)
                                                                             =>
                                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                                           ::core::fmt::Display::fmt)],
                                                                         }));
                res
            };
        Ok(self.get(self.route(&url))?)
    }
    #[doc =
      "Equivalent to `get /api/v1/accounts/{}`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_account(\"42\");\n#   Ok(())\n# }\n```"]
    fn get_account(&self, id: &str) -> Result<Account> {
        self.get(self.route(&{
                                 let res =
                                     ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/"],
                                                                                         &match (&id,)
                                                                                              {
                                                                                              (arg0,)
                                                                                              =>
                                                                                              [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                            ::core::fmt::Display::fmt)],
                                                                                          }));
                                 res
                             }))
    }
    #[doc =
      "Equivalent to `post /api/v1/accounts/{}/follow`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.follow(\"42\");\n#   Ok(())\n# }\n```"]
    fn follow(&self, id: &str) -> Result<Relationship> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                            "/follow"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    #[doc =
      "Equivalent to `post /api/v1/accounts/{}/unfollow`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.unfollow(\"42\");\n#   Ok(())\n# }\n```"]
    fn unfollow(&self, id: &str) -> Result<Relationship> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                            "/unfollow"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    #[doc =
      "Equivalent to `post /api/v1/accounts/{}/block`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.block(\"42\");\n#   Ok(())\n# }\n```"]
    fn block(&self, id: &str) -> Result<Relationship> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                            "/block"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    #[doc =
      "Equivalent to `post /api/v1/accounts/{}/unblock`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.unblock(\"42\");\n#   Ok(())\n# }\n```"]
    fn unblock(&self, id: &str) -> Result<Relationship> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                            "/unblock"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    #[doc =
      "Equivalent to `get /api/v1/accounts/{}/mute`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.mute(\"42\");\n#   Ok(())\n# }\n```"]
    fn mute(&self, id: &str) -> Result<Relationship> {
        self.get(self.route(&{
                                 let res =
                                     ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                           "/mute"],
                                                                                         &match (&id,)
                                                                                              {
                                                                                              (arg0,)
                                                                                              =>
                                                                                              [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                            ::core::fmt::Display::fmt)],
                                                                                          }));
                                 res
                             }))
    }
    #[doc =
      "Equivalent to `get /api/v1/accounts/{}/unmute`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.unmute(\"42\");\n#   Ok(())\n# }\n```"]
    fn unmute(&self, id: &str) -> Result<Relationship> {
        self.get(self.route(&{
                                 let res =
                                     ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                           "/unmute"],
                                                                                         &match (&id,)
                                                                                              {
                                                                                              (arg0,)
                                                                                              =>
                                                                                              [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                            ::core::fmt::Display::fmt)],
                                                                                          }));
                                 res
                             }))
    }
    #[doc =
      "Equivalent to `get /api/v1/notifications/{}`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_notification(\"42\");\n#   Ok(())\n# }\n```"]
    fn get_notification(&self, id: &str) -> Result<Notification> {
        self.get(self.route(&{
                                 let res =
                                     ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/notifications/"],
                                                                                         &match (&id,)
                                                                                              {
                                                                                              (arg0,)
                                                                                              =>
                                                                                              [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                            ::core::fmt::Display::fmt)],
                                                                                          }));
                                 res
                             }))
    }
    #[doc =
      "Equivalent to `get /api/v1/statuses/{}`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_status(\"42\");\n#   Ok(())\n# }\n```"]
    fn get_status(&self, id: &str) -> Result<Status> {
        self.get(self.route(&{
                                 let res =
                                     ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/"],
                                                                                         &match (&id,)
                                                                                              {
                                                                                              (arg0,)
                                                                                              =>
                                                                                              [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                            ::core::fmt::Display::fmt)],
                                                                                          }));
                                 res
                             }))
    }
    #[doc =
      "Equivalent to `get /api/v1/statuses/{}/context`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_context(\"42\");\n#   Ok(())\n# }\n```"]
    fn get_context(&self, id: &str) -> Result<Context> {
        self.get(self.route(&{
                                 let res =
                                     ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/",
                                                                                           "/context"],
                                                                                         &match (&id,)
                                                                                              {
                                                                                              (arg0,)
                                                                                              =>
                                                                                              [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                            ::core::fmt::Display::fmt)],
                                                                                          }));
                                 res
                             }))
    }
    #[doc =
      "Equivalent to `get /api/v1/statuses/{}/card`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_card(\"42\");\n#   Ok(())\n# }\n```"]
    fn get_card(&self, id: &str) -> Result<Card> {
        self.get(self.route(&{
                                 let res =
                                     ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/",
                                                                                           "/card"],
                                                                                         &match (&id,)
                                                                                              {
                                                                                              (arg0,)
                                                                                              =>
                                                                                              [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                            ::core::fmt::Display::fmt)],
                                                                                          }));
                                 res
                             }))
    }
    #[doc =
      "Equivalent to `post /api/v1/statuses/{}/reblog`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.reblog(\"42\");\n#   Ok(())\n# }\n```"]
    fn reblog(&self, id: &str) -> Result<Status> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/",
                                                                                            "/reblog"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    #[doc =
      "Equivalent to `post /api/v1/statuses/{}/unreblog`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.unreblog(\"42\");\n#   Ok(())\n# }\n```"]
    fn unreblog(&self, id: &str) -> Result<Status> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/",
                                                                                            "/unreblog"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    #[doc =
      "Equivalent to `post /api/v1/statuses/{}/favourite`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.favourite(\"42\");\n#   Ok(())\n# }\n```"]
    fn favourite(&self, id: &str) -> Result<Status> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/",
                                                                                            "/favourite"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    #[doc =
      "Equivalent to `post /api/v1/statuses/{}/unfavourite`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.unfavourite(\"42\");\n#   Ok(())\n# }\n```"]
    fn unfavourite(&self, id: &str) -> Result<Status> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/",
                                                                                            "/unfavourite"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    #[doc =
      "Equivalent to `delete /api/v1/statuses/{}`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.delete_status(\"42\");\n#   Ok(())\n# }\n```"]
    fn delete_status(&self, id: &str) -> Result<Empty> {
        self.delete(self.route(&{
                                    let res =
                                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/statuses/"],
                                                                                            &match (&id,)
                                                                                                 {
                                                                                                 (arg0,)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Display::fmt)],
                                                                                             }));
                                    res
                                }))
    }
    #[doc =
      "Equivalent to `get /api/v1/filters/{}`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.get_filter(\"42\");\n#   Ok(())\n# }\n```"]
    fn get_filter(&self, id: &str) -> Result<Filter> {
        self.get(self.route(&{
                                 let res =
                                     ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/filters/"],
                                                                                         &match (&id,)
                                                                                              {
                                                                                              (arg0,)
                                                                                              =>
                                                                                              [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                            ::core::fmt::Display::fmt)],
                                                                                          }));
                                 res
                             }))
    }
    #[doc =
      "Equivalent to `delete /api/v1/filters/{}`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.delete_filter(\"42\");\n#   Ok(())\n# }\n```"]
    fn delete_filter(&self, id: &str) -> Result<Empty> {
        self.delete(self.route(&{
                                    let res =
                                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/filters/"],
                                                                                            &match (&id,)
                                                                                                 {
                                                                                                 (arg0,)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Display::fmt)],
                                                                                             }));
                                    res
                                }))
    }
    #[doc =
      "Equivalent to `delete /api/v1/suggestions/{}`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.delete_from_suggestions(\"42\");\n#   Ok(())\n# }\n```"]
    fn delete_from_suggestions(&self, id: &str) -> Result<Empty> {
        self.delete(self.route(&{
                                    let res =
                                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/suggestions/"],
                                                                                            &match (&id,)
                                                                                                 {
                                                                                                 (arg0,)
                                                                                                 =>
                                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                               ::core::fmt::Display::fmt)],
                                                                                             }));
                                    res
                                }))
    }
    #[doc =
      "Equivalent to `post /api/v1/accounts/{}/pin`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.endorse_user(\"42\");\n#   Ok(())\n# }\n```"]
    fn endorse_user(&self, id: &str) -> Result<Relationship> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                            "/pin"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    #[doc =
      "Equivalent to `post /api/v1/accounts/{}/unpin`\n# Errors\nIf `access_token` is not set.\n```no_run# extern crate elefren;\n# use elefren::prelude::*;\n# fn main() -> Result<(), Box<::std::error::Error>> {\n# let data = Data {\n#     base: \"https://example.com\".into(),\n#     client_id: \"taosuah\".into(),\n#     client_secret: \"htnjdiuae\".into(),\n#     redirect: \"https://example.com\".into(),\n#     token: \"tsaohueaheis\".into(),\n# };\nlet client = Mastodon::from(data);\nclient.unendorse_user(\"42\");\n#   Ok(())\n# }\n```"]
    fn unendorse_user(&self, id: &str) -> Result<Relationship> {
        self.post(self.route(&{
                                  let res =
                                      ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/accounts/",
                                                                                            "/unpin"],
                                                                                          &match (&id,)
                                                                                               {
                                                                                               (arg0,)
                                                                                               =>
                                                                                               [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::core::fmt::Display::fmt)],
                                                                                           }));
                                  res
                              }))
    }
    fn add_filter(&self, request: &mut AddFilterRequest) -> Result<Filter> {
        let url = self.route("/api/v1/filters");
        let response = self.send(self.client.post(&url).json(&request))?;
        let status = response.status();
        if status.is_client_error() {
            return Err(Error::Client(status.clone()));
        } else if status.is_server_error() {
            return Err(Error::Server(status.clone()));
        }
        deserialise(response)
    }
    #[doc = " PUT /api/v1/filters/:id"]
    fn update_filter(&self, id: &str, request: &mut AddFilterRequest)
     -> Result<Filter> {
        let url =
            self.route(&{
                            let res =
                                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["/api/v1/filters/"],
                                                                                    &match (&id,)
                                                                                         {
                                                                                         (arg0,)
                                                                                         =>
                                                                                         [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::core::fmt::Display::fmt)],
                                                                                     }));
                            res
                        });
        let response = self.send(self.client.put(&url).json(&request))?;
        let status = response.status();
        if status.is_client_error() {
            return Err(Error::Client(status.clone()));
        } else if status.is_server_error() {
            return Err(Error::Server(status.clone()));
        }
        deserialise(response)
    }
    fn update_credentials(&self, builder: &mut UpdateCredsRequest)
     -> Result<Account> {
        let changes = builder.build()?;
        let url = self.route("/api/v1/accounts/update_credentials");
        let response = self.send(self.client.patch(&url).json(&changes))?;
        let status = response.status();
        if status.is_client_error() {
            return Err(Error::Client(status.clone()));
        } else if status.is_server_error() {
            return Err(Error::Server(status.clone()));
        }
        deserialise(response)
    }
    #[doc = " Post a new status to the account."]
    fn new_status(&self, status: NewStatus) -> Result<Status> {
        let response =
            self.send(self.client.post(&self.route("/api/v1/statuses")).json(&status))?;
        deserialise(response)
    }
    #[doc =
      " Get timeline filtered by a hashtag(eg. `#coffee`) either locally or"]
    #[doc = " federated."]
    fn get_tagged_timeline(&self, hashtag: String, local: bool)
     -> Result<Vec<Status>> {
        let base = "/api/v1/timelines/tag/";
        let url =
            if local {
                self.route(&{
                                let res =
                                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["",
                                                                                          "",
                                                                                          "?local=1"],
                                                                                        &match (&base,
                                                                                                &hashtag)
                                                                                             {
                                                                                             (arg0,
                                                                                              arg1)
                                                                                             =>
                                                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                           ::core::fmt::Display::fmt),
                                                                                              ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                           ::core::fmt::Display::fmt)],
                                                                                         }));
                                res
                            })
            } else {
                self.route(&{
                                let res =
                                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["",
                                                                                          ""],
                                                                                        &match (&base,
                                                                                                &hashtag)
                                                                                             {
                                                                                             (arg0,
                                                                                              arg1)
                                                                                             =>
                                                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                                                           ::core::fmt::Display::fmt),
                                                                                              ::core::fmt::ArgumentV1::new(arg1,
                                                                                                                           ::core::fmt::Display::fmt)],
                                                                                         }));
                                res
                            })
            };
        self.get(url)
    }
    #[doc =
      " Get statuses of a single account by id. Optionally only with pictures"]
    #[doc = " and or excluding replies."]
    #[doc = ""]
    #[doc = " # Example"]
    #[doc = ""]
    #[doc = " ```no_run"]
    #[doc = " # extern crate elefren;"]
    #[doc = " # use elefren::prelude::*;"]
    #[doc = " # use std::error::Error;"]
    #[doc = " # fn main() -> Result<(), Box<Error>> {"]
    #[doc = " # let data = Data {"]
    #[doc = " #   base: \"\".into(),"]
    #[doc = " #   client_id: \"\".into(),"]
    #[doc = " #   client_secret: \"\".into(),"]
    #[doc = " #   redirect: \"\".into(),"]
    #[doc = " #   token: \"\".into(),"]
    #[doc = " # };"]
    #[doc = " let client = Mastodon::from(data);"]
    #[doc = " let statuses = client.statuses(\"user-id\", None)?;"]
    #[doc = " # Ok(())"]
    #[doc = " # }"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " ```no_run"]
    #[doc = " # extern crate elefren;"]
    #[doc = " # use elefren::prelude::*;"]
    #[doc = " # use std::error::Error;"]
    #[doc = " # fn main() -> Result<(), Box<Error>> {"]
    #[doc = " # let data = Data {"]
    #[doc = " #   base: \"\".into(),"]
    #[doc = " #   client_id: \"\".into(),"]
    #[doc = " #   client_secret: \"\".into(),"]
    #[doc = " #   redirect: \"\".into(),"]
    #[doc = " #   token: \"\".into(),"]
    #[doc = " # };"]
    #[doc = " let client = Mastodon::from(data);"]
    #[doc = " let mut request = StatusesRequest::new();"]
    #[doc = " request.only_media();"]
    #[doc = " let statuses = client.statuses(\"user-id\", request)?;"]
    #[doc = " # Ok(())"]
    #[doc = " # }"]
    #[doc = " ```"]
    fn statuses<'a, 'b: 'a, S>(&'b self, id: &'b str, request: S)
     -> Result<Page<Status>> where S: Into<Option<StatusesRequest<'a>>> {
        let mut url =
            {
                let res =
                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["",
                                                                          "/api/v1/accounts/",
                                                                          "/statuses"],
                                                                        &match (&self.base,
                                                                                &id)
                                                                             {
                                                                             (arg0,
                                                                              arg1)
                                                                             =>
                                                                             [::core::fmt::ArgumentV1::new(arg0,
                                                                                                           ::core::fmt::Display::fmt),
                                                                              ::core::fmt::ArgumentV1::new(arg1,
                                                                                                           ::core::fmt::Display::fmt)],
                                                                         }));
                res
            };
        if let Some(request) = request.into() {
            url =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["",
                                                                              ""],
                                                                            &match (&url,
                                                                                    &request.to_querystring()?)
                                                                                 {
                                                                                 (arg0,
                                                                                  arg1)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt),
                                                                                  ::core::fmt::ArgumentV1::new(arg1,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                };
        }
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc =
      " Returns the client account\'s relationship to a list of other accounts."]
    #[doc = " Such as whether they follow them or vice versa."]
    fn relationships(&self, ids: &[&str]) -> Result<Page<Relationship>> {
        let mut url = self.route("/api/v1/accounts/relationships?");
        if ids.len() == 1 {
            url += "id=";
            url += &ids[0];
        } else {
            for id in ids { url += "id[]="; url += &id; url += "&"; }
            url.pop();
        }
        let response = self.send(self.client.get(&url))?;
        Page::new(self, response)
    }
    #[doc = " Add a push notifications subscription"]
    fn add_push_subscription(&self, request: &AddPushRequest)
     -> Result<Subscription> {
        let request = request.build()?;
        let response =
            self.send(self.client.post(&self.route("/api/v1/push/subscription")).json(&request))?;
        deserialise(response)
    }
    #[doc =
      " Update the `data` portion of the push subscription associated with this"]
    #[doc = " access token"]
    fn update_push_data(&self, request: &UpdatePushRequest)
     -> Result<Subscription> {
        let request = request.build();
        let response =
            self.send(self.client.put(&self.route("/api/v1/push/subscription")).json(&request))?;
        deserialise(response)
    }
    #[doc = " Get all accounts that follow the authenticated user"]
    fn follows_me(&self) -> Result<Page<Account>> {
        let me = self.verify_credentials()?;
        Ok(self.followers(&me.id)?)
    }
    #[doc = " Get all accounts that the authenticated user follows"]
    fn followed_by_me(&self) -> Result<Page<Account>> {
        let me = self.verify_credentials()?;
        Ok(self.following(&me.id)?)
    }
}
impl ops::Deref for Mastodon {
    type Target = Data;
    fn deref(&self) -> &Self::Target { &self.data }
}
struct MastodonBuilder {
    client: Option<Client>,
    data: Option<Data>,
}
impl MastodonBuilder {
    pub fn new() -> Self { MastodonBuilder{client: None, data: None,} }
    pub fn client(&mut self, client: Client) -> &mut Self {
        self.client = Some(client);
        self
    }
    pub fn data(&mut self, data: Data) -> &mut Self {
        self.data = Some(data);
        self
    }
    pub fn build(self) -> Result<Mastodon> {
        Ok(if let Some(data) = self.data {
               Mastodon{client: self.client.unwrap_or_else(|| Client::new()),
                        data,}
           } else {
               return Err(Error::MissingField("missing field 'data'"));
           })
    }
}
/// Client that can make unauthenticated calls to a mastodon instance
pub struct MastodonUnauth {
    client: Client,
    base: url::Url,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for MastodonUnauth {
    #[inline]
    fn clone(&self) -> MastodonUnauth {
        match *self {
            MastodonUnauth { client: ref __self_0_0, base: ref __self_0_1 } =>
            MastodonUnauth{client:
                               ::core::clone::Clone::clone(&(*__self_0_0)),
                           base:
                               ::core::clone::Clone::clone(&(*__self_0_1)),},
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for MastodonUnauth {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            MastodonUnauth { client: ref __self_0_0, base: ref __self_0_1 } =>
            {
                let mut debug_trait_builder =
                    f.debug_struct("MastodonUnauth");
                let _ = debug_trait_builder.field("client", &&(*__self_0_0));
                let _ = debug_trait_builder.field("base", &&(*__self_0_1));
                debug_trait_builder.finish()
            }
        }
    }
}
impl MastodonUnauth {
    /// Create a new unauthenticated client
    pub fn new(base: &str) -> Result<MastodonUnauth> {
        let base =
            if base.starts_with("https://") {
                base.to_string()
            } else {
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["https://"],
                                                                            &match (&base,)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }));
                    res
                }
            };
        Ok(MastodonUnauth{client: Client::new(),
                          base: url::Url::parse(&base)?,})
    }
}
impl MastodonUnauth {
    fn route(&self, url: &str) -> Result<url::Url> {
        Ok(self.base.join(url)?)
    }
    fn send(&self, req: RequestBuilder) -> Result<Response> {
        let req = req.build()?;
        Ok(self.client.execute(req)?)
    }
}
impl MastodonUnauthenticated for MastodonUnauth {
    /// GET /api/v1/statuses/:id
    fn get_status(&self, id: &str) -> Result<Status> {
        let route = self.route("/api/v1/statuses")?;
        let route = route.join(id)?;
        let response = self.send(self.client.get(route))?;
        deserialise(response)
    }
    /// GET /api/v1/statuses/:id/context
    fn get_context(&self, id: &str) -> Result<Context> {
        let route = self.route("/api/v1/statuses")?;
        let route = route.join(id)?;
        let route = route.join("context")?;
        let response = self.send(self.client.get(route))?;
        deserialise(response)
    }
    /// GET /api/v1/statuses/:id/card
    fn get_card(&self, id: &str) -> Result<Card> {
        let route = self.route("/api/v1/statuses")?;
        let route = route.join(id)?;
        let route = route.join("card")?;
        let response = self.send(self.client.get(route))?;
        deserialise(response)
    }
}
fn deserialise<T: for<'de> serde::Deserialize<'de>>(response: Response)
 -> Result<T> {
    let mut reader = Tap::new(response);
    match serde_json::from_reader(&mut reader) {
        Ok(t) => {
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level()
                   {
                    ::log::__private_api_log(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&String::from_utf8_lossy(&reader.bytes),)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }),
                                             lvl,
                                             &("elefren", "elefren",
                                               "src/lib.rs", 845u32));
                }
            };
            Ok(t)
        }
        Err(e) => {
            {
                let lvl = ::log::Level::Error;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level()
                   {
                    ::log::__private_api_log(::core::fmt::Arguments::new_v1(&[""],
                                                                            &match (&String::from_utf8_lossy(&reader.bytes),)
                                                                                 {
                                                                                 (arg0,)
                                                                                 =>
                                                                                 [::core::fmt::ArgumentV1::new(arg0,
                                                                                                               ::core::fmt::Display::fmt)],
                                                                             }),
                                             lvl,
                                             &("elefren", "elefren",
                                               "src/lib.rs", 851u32));
                }
            };
            if let Ok(error) = serde_json::from_slice(&reader.bytes) {
                return Err(Error::Api(error));
            }
            Err(e.into())
        }
    }
}
